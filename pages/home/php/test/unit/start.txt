**[[home:|Start]]** -> **[[home:php:|PHP]]** -> **[[home:php:test:|PHP Unit testing]]** -> **PHP Unit**

====== PHPUnit ======

  * [[https://www.udemy.com/course/php-unit-testing|PHP Unit Testing with PHPUnit]]
  * [[https://www.linkedin.com/learning/php-test-driven-development-with-phpunit/welcome|PHP: Test-Driven Development with PHPUnit]]

[[https://phpunit.de/|PHPUnit (Project Homepage)]] is the **de-facto standard testing framework for PHP**.
It provides assertions, mocks, coverage integration, and CLI tooling for reliable, automated unit and integration tests. The Code of PHPUnit is open-Source and available at  [[https://github.com/sebastianbergmann/phpunit/releases|GitHub]], therefore check the [[https://phpunit.de/announcements/index.html|Announcements for PHPUnit]] to get hold of new releases.

  * [[home:php:test:pest:|Pest]] — Alternative test runner

**Tip**: PHPUnit tests are written as classes extending PHPUnit\Framework\TestCase.
Each test method should verify one specific behavior.

<code php>
<?php
declare(strict=1);
use PHPUnit\Framework\TestCase;

final class ExampleTest extends TestCase
{
   public function testTwoValuesAreTheSame(): void
   {
      require 'function.php';
      
      $this->assertEquals(4, add(2, 2);
   }
}
</code>
To run those tests, you need to install some software, like phpunit-12.1.6.phar. If PHPUnit is installed you can check the version by running the **phpunit** command in the command line application of your operating system (PowerShell or Terminal). You don't need a web server in order to run the tests.

===== Installation =====
There a multiple ways to install PHPUnit. The first is to download it as a PHP Archive Archive File. This is the recommended way to install and use PHPUnit by the developers from PHPUnit.

==== Installation as a PHP Archive File ====
Installing Documentation for installing [[https://docs.phpunit.de/en/12.1/installation.html#installing-phpunit|PHPUnit as PHAR]] (PHP Archive Archive File). To do this, go to [[https://phar.phpunit.de/|phar.phpunit.de]] in a browser. Tin the **Latest Release** section, click the file named **PHPUnit followed by a numeric version with the .par suffix**. This will download the file.
<code bash>
wget -O phpunit.phar https://phar.phpunit.de/phpunit-12.1.6.phar
</code>
It is **common practice to install PHPUnit into each project** instead of installing it globally. This avoids version issues between different projects. To do this from the root of your project folder, create a folder called tools. Then copy the file you just downloaded into that folder and rename it to just phpunit.phar. So now the tools folder contains the PHP executable file. you should now be able to run this directly like this.
<code bash>
php tools/phpunit.phar --version
</code>
We can make running this a bit simpler. On Windows you can create a script with a command like this, which results in a script called phpunit.cmd in the project root folder. You can then run this with just  the phpunit command
<code powershell>
echo @php "%~dp0tools/phpunit.phar" %* > phpunit.cmd
</code>
On Mac or Linux you can make the file executable 
<code bash>
chmod +x tools/phpunit.phar
tools/phpunit.phar --version
</code>
You can then run this with out having to prefix it with the php command, but you have to include the tools directory or add an alias after make the file executable
<code bash>
alias phpunit=tools/phpunit.phar
phpunit --version
</code>
Now you can runit on macOS or Linux with just the phpunit command.

If you prefer, you can install the phar file using Phive, as described in the [[https://docs.phpunit.de/en/12.1/installation.html#installing-phpunit-with-phive|PHPUnit Documentation Section - Installing PHPUnit with Phive]]. 

==== Installation with Composer ====
The other way to **install PHPUnit with Composer**. To do this you need to make sure you have Composer installed and working on the command line. You can check this by running the composer command with the uppercase -V flag to output the installed version.
<code bash>
composer -V
</code>
If you don't have Composer installed, it's simple to install and full instructions are shown on the [[https://getcomposer.org/|officiel Composer website]]. Choose the [[https://getcomposer.org/doc/00-intro.md|instructions]] that match your operating system. On Linux you can use your package manager to install it, with all needed dependencies.

Installing PHPUnit as an development dependency (not needed in production) in our project 
<code bash>
$ composer require --dev phpunit/phpunit 
</code>
Check the composer.json and composer.lock file in the project root folder or check the version:
<code bash>
$ vendor/bin/phpunit --version 
</code>
To make this easier you can add an optional alias or create a shell script as descripted above. In Windows Powershell you can add with this command
<code powershell>
Set-Alias -Name phpunit -Value "./vendor/bin/phpunit"
</code>
With the alias, we can now run PHPUnit with just the phpunit command
<code powershell>
phpunit --version
</code>

==== Install PHPUnit globally using Phive ====
Alternatively you can also **install PHPUnit globally using Phive** (not recommended):
<code bash>
$ phive install phpunit 
</code>
As long as you can run PHPUnit on the command line it doesn't matter which method you use to install PHPUnit.
===== Testing Basics - Getting started =====
==== Writing a First Test ====
First let's create a **folder to store the test code**. You can call this folder whatever you like, but it's typical to **call the folder tests**

A test in PHPUnit is just a PHP class. So inside of this folder let's create a new file called Test.php. The test class is final as we're not going to need to extend this class. Make sure that the **class name matches the file name** so autoloading works. Test classes needs to **extend a specific class from the PHPUnit** framework.
<code php>
<?php
declare(strict_types=1);
use PHPUnit\Framework\TestCase;

final class Test extends TestCase
{
   public function testTwoValuesAreTheSame(): void
   {
      $this->assertSame(1, 1); /* assert that two values are the same */
   }
}
</code>
In the this class we define **public methods that perform tests**. Inside the test methods we use assert messages. These are used to assert or check that something is as expected.
<code bash>
phpunit tests/Test.php
</code>
If the output says OK,there was one test and one assertion, we're fine, because this means that the test passed. If we get output that says there was a FAILURE! then the test failed. The output includes the location in the method and the class where the failure occurred. We get a message describing exactly what the failure was.

This example test isn't actually doing  anything useful. It just contains an assertion with literal values. Instead of tests like this, normally we write tests to test application code. This code is typically defined inside function and classes.

==== Testing Application Code ====

=== Project Layout ===
The normal PHP Project should have the following file and folder structure
^ Path ^ Purpose ^
| **bootstrap.php** | Optional autoloader/environment setup |
| **composer.json** | |
| **composer.lock** | |
| **lib** | Application library's folder |
| **phpunit.xml.dist** | Default PHPUnit configuration |
| **public** | **index.php** as application entry point |
| **src/** | Application code |
| **tests/** | Test classes (unit/integration) |
| **vendor/** | Composer dependencies |

> Commit the //phpunit.xml.dist// file to version control and let developers copy it to //phpunit.xml// for local overrides.

=== Application Code Example ===
The Application Code to test: **src/Calculator.php**
<code php> 
<?php 
declare(strict_types=1);

namespace App;

class Calculator {
  public function addIntegers(int $a, int $b): int {
    return $a + $b;
  }
}
</code>
This code could be part of an application or a library function. This class contains a single function called  addInteger, that takes two integer and returns the sum of those two integers. This is a trivial function  that you wouldn't typically write, but it serves to demonstrate how we would test a function like this. 

Without PHPUnit, you might test it by running it from another script, providing it with different values for its arguments, and printing the results. With PHPUnit though, we can test this programmatically.
 
=== Application Test Example ===
The Unit test code file: **tests/CalculatorTest.php**, in the tests folder, should refer with it's name to the file name to be tested. In the test file we'll start as in other classes. So the PHP opening tag, we'll enable strict type checking, and defining a class called CalculatorTest that extends the PHPUnit test case class. Then we add a test function. Inside this method using the assertSame method to check that the return value from the function is as expected. The first argument to this function is the expected value, and the second argument is the actual value. Before we can test this we need to explicitly load the file where the function is defined, as this isn't done automatically. So before the class definition lets require that file. As this will be relative to this test file use the dirname function with the DIR constant to go up to the parent folder before adding the path
<code php> 
<?php 
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
require dirname(__DIR__) . '../src/Calculator.php'; /* use App\Calculator; */

final class CalculatorTest extends TestCase
{
  /** @test */
  public function testAddIntegers(): void 
  {
    $calc = new Calculator();
    $this->assertSame(5, $calc->addIntegers(2, 3)); /* 2 + 3 = 5 */
  }
}
</code>
**tests/CalculatorTest.php**

On the command line, let's run that test, passing the path of the functions test file to the test
<code bash> 
$ vendor/bin/phpunit tests/CalculatorTest.php
</code>
If we get an OK output, we know we passed the test. So ew just wrote a test that executed the addIntegers function, and tested that its return value was as we expected it to be.
<code php>
/** @test */ 
public function test_AddIntegers(): void 
{ 
</code>
The **@test annotation** tells PHPUnit this is a test method not a normal method. The **test_** prefix, with or without underscore, tells PHPUnit this is a **test method** as an alternative naming convention. You can choose which way you will take to mark a test method as a test method, but be consistent.

**To comprehensively test this function, we should test as many aspects of it as we can**. For example, let's test that the function adds two negative number together correctly. To do this, we could add another assertion to the existing test method like this.
<code php> 
<?php 
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
require dirname(__DIR__) . '../src/Calculator.php'; /* use App\Calculator; */

final class CalculatorTest extends TestCase
{
  /** @test */
  public function testAddIntegers(): void 
  {
    $calc = new Calculator();
    $this->assertSame(5, $calc->addIntegers(2, 3)); /* 2 + 3 = 5 */
    $this->assertSame(-5, $calc->addIntegers(-2, -3)); /* -2 + -3 = -5 */
  }
}
</code>
The result of phpunit should give us OK (1 test, 2 assertions). However, best practice when it comes to writing tests is for each test method to just assert one condition. This makes the test much clearer and easier to maintain.  We also get better output from the test runner.
<code php> 
<?php 
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
require dirname(__DIR__) . '../src/Calculator.php'; /* use App\Calculator; */

final class CalculatorTest extends TestCase
{

  public function testAddTwoPositivIntegers(): void 
  {
    $calc = new Calculator();
    $this->assertSame(5, $calc->addIntegers(2, 3)); /* 2 + 3 = 5 */
  }

  public function testAddTwoNegativeIntegers(): void 
  {
    $calc = new Calculator();
    $this->assertSame(-5, $calc->addIntegers(-2, -3)); /* -2 + -3 = -5 */
  }
}
</code>
It's a good idea to make the names of the test methods as verbose as you can, as ultimately this is a form of documentation and tells you exactly what the method is testing. So now we have two test methods, each with one assertion. Each method is testing just one specific aspect of the code. Now when we run this, it's still OK, but now with two tests and two assertions.

To get the full range of test methods add some more like adding positive and negative integers and adding zero to an integer, is addition in this function commutative (2+3=3+2).
<code php> 
<?php 
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
require dirname(__DIR__) . '../src/Calculator.php'; /* use App\Calculator; */

final class CalculatorTest extends TestCase
{

  public function testAddTwoPositivIntegers(): void 
  {
    $calc = new Calculator();
    $this->assertSame(5, $calc->addIntegers(2, 3)); /* 2 + 3 = 5 */
  }

  public function testAddTwoNegativeIntegers(): void 
  {
    $calc = new Calculator();
    $this->assertSame(-5, $calc->addIntegers(-2, -3)); /* -2 + -3 = -5 */
  }

  public function testAddTwoNegativeIntegers(): void 
  {
    $calc = new Calculator();
    $this->assertSame(-5, $calc->addIntegers(-2, -3)); /* -2 + -3 = -5 */
  }

  public function testAddPositivAndNegativeIntegers(): void 
  {
    $calc = new Calculator();
    $this->assertSame(1, $calc->addIntegers(3, -2)); /* 3 + -2 = 1 */
  }

  public function testAddZeroToInteger(): void 
  {
    $calc = new Calculator();
    $this->assertSame(3, $calc->addIntegers(3, 0)); /* 3 + 0 = 3 */
  }

  public function testAddingIsCommutative(): void 
  {
    $calc = new Calculator();
    $this->assertSame($calc->addIntegers(2, 3), $calc->addIntegers(3, 2)); /* 3 + 2 = 2 + 3 */
  }
}
</code>
Output, if we run this, should be five teste and five assertions. Note that the output shows one dot for each time a test method passes, so we should have five dots. As his is a simple test, it executed very quickly, but for more complex tests, the appearance of  these dots shows the progress of the tests as they run.

To see what happens when a test fails, change the expected value of a test. If you run this you'll see you get an F instead of a dot for that test and instead of a OK a FAILURES with Tests: 5, Assertions: 5 Failures: 1. Additionally you'll get a message which test failed, why and where it failed. This is the reason why having one assertion per test is the best way to write tests. We can see straight away which test method is failing.

As each test method is responsible for testing a special aspect of the code and as we've been verbose when naming each method, it's much clearer what each test is doing. If you want to test a class, it's common practise to match the name of the test class to the class you're using. 
===== Configuring the Command-Line Test-Runner =====

As we learned **PHPUnit** is run on the command line. The application that runs is known as the **command line test runner**. So far we've run the test class we want by passing the path to this application.
<code bash>
phpunit tests/PersonTest.php
</code>
In Addition to this, there are many different options we can pass in when running tests. For example, to get colours in the output, we can specify the colors flag.

==== Controlling the Test Runner Output ====
to get colours in the output, we can specify the colors flag.
<code bash>
phpunit tests/PersonTest.php --colors
</code>
Now the output contains colours - specifically for this test in which all the test passed, the summary is highlighted in green.

If you run a test that fails, then you'll get different colours. In the characters that are printed out for each test, in addition to the one that failed being shown as the letter F, this is highlighted in red. Likewise for the summary, which is also highlighted in red. 

If you like, you can get the test runner to **stop running the tests when one fails** by specifying the **stop-on-failure** flag
<code bash>
phpunit tests/PersonTest.php --colors --stop-on-failure 
</code>
Now only the test passing will run and stop after the first failure. When a test does fail, we get the name of the test method printed out. However, even with the colours option, this isn't highlighted in any way, and we don't get any details at all about the test that passed only a dot for each one. the main advantage of this default output format is that it is concise. So if you have a lot of tests, it gives you a good overview. If you want **more details**, try specifying the **testdox option**.
<code bash>
phpunit tests/PersonTest.php --colors --testdox
</code>
This gives much more detail in output, converting the test method names into text descriptions of each one. When used along with the colours option, this shows green ticks for the tests that pass, and failed tests are highlighted with a red cross. This format is much more descriptive, and this output can even be used **as a base for documenting your tests**. This is why it's important to give as much details as possible when naming test methods. The testdox output will help you to do this. See a comprehensive list on [[http://docs.phpunit.de/en/12.1/textui.html#command-line-options|Command-Line Options documentation]] at the official [[http://docs.phpunit.de/en|PHPUnit Manual]]. You can also get a list of all options by specifying the help flag on the command line.
<code bash>
phpunit tests/PersonTest.php --help
</code>
==== Run a Script before Test execution ====
One of the options available when running PHPUnit is the bootstrap option, which runs a PHP script before any of the tests run. While you could in theory put any PHP code in such a script, this is typically used to just load the files that the test requires.

So, for example, in the case of a function test, in order to run a test we need to require a PHP library in the lib folder. This require can be stored in a separate script instead. So let's create a new file **in the tests folder** called **bootstrap.php**. Note you can name this script anything you like, but bootstrap.php is a typical name. Now move the required statements from the tests file to the bootstrap.php
<code php>
<?php
require dirname(__DIR__) . '/lib/functions.php';
</code> 
Running the tests now, will lead to a lot of expected errors due to missing require statement in the tests file. If you specify the bootstrap option followed by the path to the bootstrap.php file, then the test works.
<code bash>
phpunit tests/FunctionTests.php --bootstrap tests/bootstrap.php
</code>
Now the testrunner will run without any errors, even if you still get a failure in a test.
==== Add Autoloader to load Classes Automatically ====
In testing classes the test file will contain a require line that loads the file where that class is defined. We could require this file explicitly in the bootstrap.php, but we can add this with an autoloader. This means any class will be loads automatically, which is useful if we have tests that test lots of different classes.

We can call the spl_autoload_register function in the bootstrap.php, passing in an anonymous callback function as the only argument. 
<code php>
<?php
require dirname(__DIR__) . '/lib/functions.php';
spl_autoload_register(function($class) {
  $file = require dirname(__DIR__) . '/src/' . str_replace('\\', '/',$class) . '.php';
  if (file_exists($file)) {
    require $file;
  }
});
</code>
Assuming we're using PSR-4 autoloading we can get the path to the class by converting any namespaces to folder names and str_replace will convert this for us by converting backslash to forward slashes.
<code bash>
phpunit tests/PersonTest.php --bootstrap /tests/bootstrap.php
</code>
Try running your test again and it should work as before.

==== Using Composer's Autoloader ====
For simple projects it might be enough to define a simple autoloader in the bootstrap file. However, and especially as we're assuming a PSR-4 autoloader structure, it's much more common to use Composer to autoload classes. First, we need to tell Composer where to autoload the classes from. We do this in the composer.json file.
<code json>
{
  "autolad": {
    "psr-4": {
      "": "src/"
    }
  }
}
</code>
Use an empty prefix, so any class or namespace will be looked for inside the specified folder as the value of the empty prefix use the src folder as the value.
<code bash>
composer dump-autoload
</code>
To generate the autoload script, we run the **composer dump-autoload** command on the command line. This will create a vendor folder containing a script called autoload.php, if you already had this file, it will have been updated. If we run the test again, we can use the vendor/autolader.php script as the bootstrap option.
<code bash>
phpunit test/PersonTest.php --bootstrap vendor/autoload.php
</code>
This is typically how PHPUnit tests are configured -using Composer to autoload the code being tested. Note that if you run a functions test and specify Composer's autoloader, then this no longer works, as we're not requiring the file where the function beeing teste is defined.

We can autoload specific files in Composer by adding a files section to the autoloader section in composer.json
<code json>
{
  "autolad": {
    "psr-4": {
      "": "src/"
    },
    "files": [
    "lib/functions.php"
    ]
  }
}
</code>
To regenerate the autoload script we need to run composer dump-autoload. Now if we run a function test again, it works.
<code bash>
phpunit test/Function.php --bootstrap vendor/autoload.php
</code>
==== The PHPUnit Configuration File ====

We can specify various options by passing flags to the PHPUnit test rummer. Instead of having to include these options every time we run a test, we can specify them in a configuration file. 
<code bash>
phpunit --generate-configuration
</code>
While we could create that file directly, the test runner can generate it with the generate-configuration option. This will ask what some questions
  * The **bootstrap script** should be with a default of vandor/autload.php, you can press enter to accept the default, or you type the path to the bootstrap script. 
  * Next question is the **tests directory** location. The default directory is called tests which you can accept by pressing enter
  * The same for the **source code directory** where the classes are defined.
  * The **cache directory** is where PHPUnit stores its cache, which speeds up testing when rerunning tests. **Note** to exclude the .phpuni.cache directory from version control. Add it to your .gitignore file
This are the current question and it has generated a file called phpunit.xml in the root of the project.

If you don't want to generate a phpunit.xml, you can copy default configuration file **phpunit.xml.dist** into the project root. The phpunit.xml.dist is a very minimalistic version of a phpunit.xml configuration. 
<code xml>
<?xml version="1.0" encoding="UTF-8"?>
<phpunit bootstrap="tests/bootstrap.php" colors="true">
  <testsuites>
    <testsuite name="TabKeeper API">
      <directory>tests</directory>
    </testsuite>
  </testsuites>
</phpunit>
</code>

In that file, which is XML, we can see that some options are specified as attributes to the root phpunit element, such as the bootstrap.
<code xml> 
<?xml version="1.0" encoding="UTF-8"?>
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="vendor/phpunit/phpunit/phpunit.xsd"
         bootstrap="vendor/autoload.php"
         cacheDirectory=".phpunit.cache"
         executionOrder="depends,defects"
         shortenArraysForExportThreshold="10"
         requireCoverageMetadata="true"
         beStrictAboutCoverageMetadata="true"
         beStrictAboutOutputDuringTests="true"
         displayDetailsOnPhpunitDeprecations="true"
         failOnPhpunitDeprecation="true"
         failOnRisky="true"
         failOnWarning="true">
    <testsuites>
        <testsuite name="default">
            <directory>tests</directory>
        </testsuite>
    </testsuites>
    <source ignoreIndirectDeprecations="true" restrictNotices="true" restrictWarnings="true">
        <include>
            <directory>src</directory>
        </include>
    </source>
    <coverage includeUncoveredFiles="true"> 
      <include> 
        <directory>
          src
        </directory> 
      </include> 
      <report> 
        <html outputDirectory="build/coverage"/> 
        <text outputFile="php://stdout" showUncoveredFiles="false"/> 
      </report> 
    </coverage> 
</phpunit> 
</code>
To keep this simple, you can remove all the options from executionOrder to the end of phpunit attributes
This configuration file is a minimalistic version of a configuration file.

As for the test suites and the source elements, these define where the test classes are and where the classes we're testing are. In your own minimalistic version you could also remove the rest from source to the end, but leave the last line with **</phpunit>**. So now PHPUnit will read this file when running tests and apply the specified options.

Add **colors="true"** to the <phpunit xmlns ... as the last attribute, if you want to automat the color flag. If you run tests the colors option is now included.  There is a [[https://docs.phpunit.de/en/12.5/configuration.html#the-phpunit-element|full list of available configuration attributes]] in the official documentation

As for naming the configuration file, by default, this is named phpunit.xml. Although you can name this whatever you like, and specify the name of the configuration file when you run phpUnit with the configuration option, but it's best practice to name this file phpunit.xml or phpunit.xml.dist. If phpunit.xml exists, then PHPUnit will use that. Otherwise it will use the .dist file, it won't use both. So the best practice is to name th file phpunit.xml.dist. This is the file that you store in source code control. The phpunit.xml should be ignored from source code control, for example in a .gitignore file. This will allow a developer to use a custom configuration file called phpunit.xml without the risk of accidently checking it in to source code control.
<code bash>
phpunit -c phpunit.api-server.xml
</code>

**Code coverage** 
<code php>
    ...
    <coverage includeUncoveredFiles="true"> 
      <include> 
        <directory>
          src
        </directory> 
      </include> 
      <report> 
        <html outputDirectory="build/coverage"/> 
        <text outputFile="php://stdout" showUncoveredFiles="false"/> 
      </report> 
    </coverage> 
</phpunit> 
</code>

Run with coverage:
<code bash>
$ vendor/bin/phpunit --coverage-html build/coverage 
</code>

> Open build/coverage/index.html in your browser for a visual report.

----
Check the [[https://docs.phpunit.de/en/12.1/organizing-tests.html#composing-a-test-suite-using-xml-configuration|Composing a Test Suite Using XML Configuration]] section of the [[https://docs.phpunit.de/en/12.1/index.html|PHPUnit Manual]]
===== Organising Tests and managing Test Methods =====
==== Running Multiple Tests and Organising Tests in Test Suits ====
How to organise tests and interpret the different results that we get wen we run then, is one of the main questions in testing. So far, we've been running specific test classes by specifying them on the command line, passing the path to the file to the test runner. We can also pass a wildcard in the path.
<code bash>
phpunit tests/*Test.php
</code>
For example, this will run all the files with a suffix of Test.php. The output will show the results of all the tests. We can also just pass in the folder where the test classes are, and this will run all tests as well. Even through there are PHP files in the tests folder, the test runner only runs files that end in Test.php. 

Although you can configure PHPUnit to run specific files that aren't named like this. Naming a test class with the Test.php suffix is the best practice. When generating an PHPUnit XML configuration file, it included a test suites element. 
<code xml>
    <testsuites>
        <testsuite name="default">
            <directory>tests</directory>
        </testsuite>
    </testsuites>
</code>
This part of the configuration file allow us to organise folders containing test files into test suites. We can then run those separately if we need to. The default test suite that has been added defines a test suite called default that points to the tests folder. You can add as many suites as you like here, organising your tests however you like. For example, as shown in the [[https://docs.phpunit.de/en/12.1/organizing-tests.html#composing-a-test-suite-using-xml-configuration|Composing a Test Suite Using XML Configuration]] of the [[https://docs.phpunit.de/en/12.1/|PHPUnit Manual]], this configuration defines one suite containing unit tests and another containing integration tests.

On the command line, we can list the available test suites with the list-suites option.
<code bash>
phpunit --list-suites
</code>
We can then run a particular suit with the testsuite option, specifying the name of the suite we want to run.
<code bash>
phpunit --testsuite default
</code>
If we run the default test suite, this runs all the test files in the specified folder that have the suffix Test.php. 

Now that we have a configuration file with the suites defined we can just run PHPUnit with no arguments at all. This will run all the tests in all suites.
==== Running Individual Tests with Filters ====
Running a test suite my lead to having a couple of failures. Typical workflow is to run the test suit and fix any failing tests until everything passes. On every test we run the entire test suite through. If the test suite contains a lot of tests, this can take time. If we just want to **run a single test** while we fix it, we can do that. We can list all available teste in the test suite with the **list tests option**.
<code bash>
phpunit --list-tests
</code>
We can run an individual test with the filter option passing in the class and the test method name.
<code bash>
phpunit --filter FunctionTest::testAddTwoPositiveIntegers
</code>
Note that you can run this without the test class name if you like, but if there are methods with the same name in different classes, then it will run these as well. 
==== Two Ways of Marking Methods as Test Methods Tests with Filters ====

You can name your test Methods as you like Snakecase or CamelCase. Although CamelCase is the recommended way to name PHP methods, you will see tests that are named using Snakecase like this. If a method, doesn't start with the word test. For test methods to be run automatically, they need to be **public methods that start with the word test**. However, there is an alternative way **to mark a method as a test method**. The other way we can mark a test as a test method is to use an attribute. To do this, first let's add a us statement to input the test attribute from the PHPUnit Framework. Therefore you need to add a use statement to input the **test attribute from the PHPUnit framework** into the current namespace. Then you can specify that **attribute before the test method**.

<code php>
<?php
declare(stricttypes=1);
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\Attributes\Test;

#[Test]
public function ...
</code>
So to get a method recognized as a test method, it either needs to start with the word test or have the test attribute.

==== Mark a Test Methods as to implement later ====

A method with no assertions will be marked as a risky test when running the tests. This is because it doesn't perform any assertions. Risky tests are shown with a letter R in the test runner output, and if you have colours enabled, note that the result is orange instead of red or green. 

If you want to **ignore test** like these, you can specify the **don't report useless tests** option.
<code php>
phpunit --dont-report-useless-tests
</code>
You can also specify this in the configuration file if you like, see [[https://docs.phpunit.de/en/12.1/configuration.html#the-bestrictaboutteststhatdonottestanything-attribute|The be Strict About Tests That Do Not Test Anything Attribute]].

When writing tests, you might add some test methods that you intend to implement later on, just adding them so you don't forget them. You could leave them empty and they would be reported as risky tests. An alternative could be to add a meaningless assertion. For example, the Assert true method just asserts that the first argument is true. If we pass false to this it will defiantly fail. 
<code php>
   #[Test]
   public function fll_name_is_first_name_when_no_surname(): void
   {
      $this->assertTrue(false, 'Test not implemented yet');
   }  
</code>
When calling assertion methods, we can include a custom message that will be shown in the Test runner. When we run this, it fails as expected, showing the optional message, //Test not implemented yet//, that we added. however, this isn't generally a good idea as a failure is not the same thing as a test that hasn't been implemented yet.

So instead of doing this, if we don't **want to implement a test yet**, we can call the **mark test incomplete** method providing an optional message.
<code php>
   #[Test]
   public function fll_name_is_first_name_when_no_surname(): void
   {
      $this->markTestIncomplete('This test has not been implemented yet');
   }  
</code>
Now if we run this, we get an **I** in the output and the number of incomplete tests is shown in the summary. If you add the **display-incomplete** flag, then we see the details of the incomplete tests, including any custom messages that we added.
<code php>
phpunit --display incomplete
</code>
==== Fixing a Bug Through Testing ====
**The Difference Between Errors and Failures**

When you have a test that outputs an **E** and **ERRORS!**, then we get an error, not that this is different to a  failed test. This is an actual error in the code under test, not a failure of an assertion. Getting and fixing errors like this is one of the ways writing unit tests helps us to write better code. If we identify and fix errors while testing when the code is running in production, it's going to be more robust.

The goal of unit testing is to isolate each part of an application and show that each individual unit works as expected. 
==== Simplifying Tests with Test Method Arguments and Data Providers ====

If you run multiple tests on a single function, many of the test methods are almost the same. The only difference being the values that we're passing to the assert same method. When this occurs, you can refactor this to mark the test simpler. 

Add a generic test method, the name of this method isn't specific to the test it's performing like the other test methods. Test methods can accept any arguments. Add three arguments to this method two that will be used as arguments and one for the expected result. To provide values to this method, we use a data provider. This is a method that returns a traversable value that provides one or more sets of values. This method has to be public and static and returns an array with sets of values. each set of values is itself an array that contains the arguments that will be used when calling the test method we just added. The first array in the result array contains the values for the first test method, the next array contains the values from the next test method. Likewise for the next methods. If a test method doesn't follow the same structure as the other methods, so we can't include a set of values for this method. To specify this method as a data provider to the new test method, use an attribute, therefor you need to add a use statement to input the data provider attribute into the current namespace. Then you can add an attribute to the test, specifying the name of the data provider. We can add names to the array by providing string keys for each element, we can get these from the names of the individual test methods. This text will be shown in the output if we run the test runner with the testdox flag. 
<code php> 
<?php 
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\Attributes\DataProvider;

final class CalculatorTest extends TestCase
{

  public static function additionProvider(): array
  {
    return [
      'two positive integers' => [2, 3, 5],
      'two negative integers' => [-2, -3, -5],
      'positive and negative integers' => [3, -2, 1],
      'adding zero' => [3, 0, 3 
    ];
  }
  
  #[DataProvider('additionProvider')]
  public function tesAddIntegers(int $a, int $b, int $expected): void
  {
     $this-> assertSame($expected, addIntegers($a, $b));
  }
  
  public function testAddingIsCommutative(): void 
  {
    $calc = new Calculator();
    $this->assertSame($calc->addIntegers(2, 3), $calc->addIntegers(3, 2)); /* 3 + 2 = 2 + 3 */
  }
}
</code>
Not that the last method doesn't follow the same structure, so we have to leave that un touched. So even we have two test methods, five test and five assertions are run. So this class tests the same as before, only now it's much simpler. If we want to add a new set of values to test, it's much easier to do. So instead of adding a new test method, we can just add new set of values to the data provider.
==== Multiple Assertions in a single Test Methods and Dependencies ====
One question in testing is how to reduce repetition in tests. Note the only way we can test a class is through the public methods of the class. We have no way of accessing the private properties of the class. This is particular to the implementation of the code. That's why we typically only test classes via their public interfaces.

An example for mor then on assertion in a test is removing an item from a queue.
<code php>
<?php
declare(strict_types=1);
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\Attributes\Depends;

final class QueueTest extends TestCase
{
  #[Depends('testNewQueueIsEmpty')]
  public function testPopRemovesAndReturnsItem(Queue $queue): void
  {
    $queue->push('an item');
    
    $this->assertSame('an item', $queue->pop());
    $this->assertSame(0, $queue->getSize()); /* multiple assertion in one test method */
  }
  
  #[Depends('testNewQueueIsEmpty')]
  public function testPushAddsItem(Queue $queue): void
  {
    $queue->push('an item');
    
    $this->assertSame(1, $queue->getSize());
  }
  
  public function testNewQueueIsEmpty(): Queue
  {
    $queue = new Queue;
    
    $this->assertSame(0, $queue->getSize());
    return $queue;
  } 
  
  public function testPopEmtyQueue(): void
  {
    $this->markTestIncomplete('This test has not been implemented yet');
  }  
}
</code>
Every test creates a new Queue object, so we could make the test methods depending on it. Therefore we add an attribute to the depending test. The independent test has to return the object the other tests depend on. This may lead to a bit different walk through the tests. The method returning the object is known as the producer. The method that depends on is known as a consumer. With this you can remove some repletion by using test dependencies.
==== Fixtures ====
Having dependencies in test can make it difficult to understand where tests data are coming from. It's also generally good practice for each unit test to be independent and not affect any other test. If you are not using dependencies, you need repeating code in each test that **set up data to a known state** before we actually made any assertions, **like creating a needed object**. This known state is **called fixture of the test**.

So instead of making tests dependent on each other, we can add code that sets this state up before each test method. We do this in a **method called setUp**. This function can be public if you like, but to make it protected as it makes the actual methods more obvious. The setUp method will be called before each test method.
<code php>
<?php
declare(strict_types=1);
use PHPUnit\Framework\TestCase;
 
final class QueueTest extends TestCase
{
  private Queue $queue;
  
  protected function setUp(): void
  {
    $this->queue = new Queue;
  }
  
  protected function tearDown(): void
  {
    unset($this->queue); /* destroy object created in setUp */
  }

  public function testNewQueueIsEmpty(): void
  {
    $this->assertSame(0, $this->queue->getSize());
  } 
 
  public function testPushAddsItem(Queue $queue): void
  {
    $this->queue->push('an item');
 
    $this->assertSame(1, $this->queue->getSize());
  }

  public function testPopRemovesAndReturnsItem(): void
  {
    $this->queue->push('an item');
 
    $this->assertSame('an item', $this->queue->pop());
    $this->assertSame(0, $this->queue->getSize()); /* multiple assertion in one test method */
  }
  
  public function testAnItemIsRemovedFromTheFrontOfTheQueue(): void
  {
     $this->queue->push('first');
     $this->queue->push('second');
     
     $this-AssertSame('first', $$this->queue->pop());
  }
 
  public function testPopEmtyQueue(): void
  {
    $this->expectException(\UnderflowException::class);
    $this-queue-pop();
  }
}
</code>
Try an run one test to see it's working
<code bash>
phpunit --filter testNewQueueIsEmpty
</code>
The method without dependency is more independent and arguably much clearer if we do it this way. Now, however, it's easier to see what each method does. In addition to the setUp method, there's also a **tearDown method**, this runs after each test method. In here, you would typically put code to clean up after each test. For examply you might want to destroy objects you created in the setUp method. However, in practice this isn't really necessary. The only time you might need to unset variables like this is if they used a lot of memory, or you were allocating external resources such as files or database connections. Most of the time through, you won't need to use this tearDown method.

==== Testing Exceptions ====
So far we've been using assertions to test that code works the way we expect it to. Sometimes, through, things can go wrong in your code, and the way PHP signals that something has gone wrong is to throw an exception. In this situations we use **expectException** with the exception we expect to be thrown, instead of an assertion. 

Hint: **The test of the exception has to be called before the line that causes the exception to be thrown.**

In an empty Queue you can't pop an item, because there is none, then an exception will be thrown.
<code php>
  // ...
 
  public function testPopThrowsExceptionWhenQueueIsEmpty(): void
  {
    $this->expectException(\UnderflowException::class);
    $this->expectExceptionMessage('Queue is empty');
    
    $this-queue-pop();
  }
}
</code>
There are also methods to check the [[https://docs.phpunit.de/en/12.1/writing-tests-for-phpunit.html#expecting-exceptions|Expecting Exceptions code]] and the message.

Note that the test runner includes the expect exception methods in the number of assertions that were run. They are not counted separately.
===== Stubbing and Mocking =====
===== PHPUnit Assertions, Expectations, and Other Test Methods =====

PHPUnit provides several groups of methods to help you write clean, structured, and reliable tests.

The main categories are:

  * **Assertions (`assert*`)** – Check that a condition holds true.
  * **Expectations (`expect*`)** – Define expected behavior (e.g., exceptions or output).
  * **Helper & Lifecycle Methods** – Prepare and clean up test environments.

==== Assert Methods ====

^ Method ^ Description ^
| **assertTrue($condition)** | Checks that the condition is true. |
| **assertFalse($condition)** | Checks that the condition is false. |
| **assertNull($value)** | Checks that the value is `null`. |
| **assertNotNull($value)** | Checks that the value is **not** `null`. |
| **assertEmpty($value)** | Checks that the value is empty (`[], '', null, 0`, etc.). |
| **assertNotEmpty($value)** | Checks that the value is **not** empty. |
| **assertEquals($expected, $actual)** | Compares two values for equality (not identical, `==`). |
| **assertSame($expected, $actual)** | Checks for strict equality (`===`). |
| **assertNotEquals($expected, $actual)** | Checks that two values are **not** equal. |
| **assertNotSame($expected, $actual)** | Checks that two values are **not** identical. |
| **assertInstanceOf($class, $object)** | Checks that an object is an instance of a class. |
| **assertNotInstanceOf($class, $object)** | Checks that an object is **not** an instance of a class. |
| **assertContains($needle, $haystack)** | Checks that a value exists in an array or string. |
| **assertNotContains($needle, $haystack)** | Checks that a value does **not** exist in an array or string. |
| **assertCount($expectedCount, $array)** | Checks that an array has a specific length. |
| **assertGreaterThan($expected, $actual)** | Checks that `$actual` is greater than `$expected`. |
| **assertLessThan($expected, $actual)** | Checks that `$actual` is less than `$expected`. |
| **assertStringContainsString($needle, $haystack)** | Checks that a string contains a substring. |
| **assertStringStartsWith($prefix, $string)** | Checks that a string starts with a prefix. |
| **assertStringEndsWith($suffix, $string)** | Checks that a string ends with a suffix. |
| **assertFileExists($filename)** | Checks that a file exists. |
| **assertFileDoesNotExist($filename)** | Checks that a file does **not** exist. |
| **assertJson($string)** | Checks that a string is valid JSON. |
| **assertMatchesRegularExpression($pattern, $string)** | Checks that a regex matches the string. |

==== Expect Methods ====

^ Method ^ Description ^
| **expectException($class)** | Expects a specific exception to be thrown. |
| **expectExceptionMessage($message)** | Expects a specific exception message. |
| **expectExceptionCode($code)** | Expects a specific exception code. |
| **expectOutputString($string)** | Expects a specific output (`echo`, `print`). |
| **expectOutputRegex($pattern)** | Expects output that matches a regex pattern. |

**Example:**
<code php>
$this->expectException(InvalidArgumentException::class);
$this->expectExceptionMessage('Invalid user ID');
</code>

==== Other Useful Methods and Hooks ====

^ Method ^ Description ^
| **setUp(): void** | Runs before each test – used for initialization. |
| **tearDown(): void** | Runs after each test – used for cleanup. |
| **setUpBeforeClass(): void** | Runs once per test class before all tests. |
| **tearDownAfterClass(): void** | Runs once per test class after all tests. |
| **markTestSkipped($reason)** | Marks a test as skipped. |
| **markTestIncomplete($reason)** | Marks a test as incomplete. |
| **@dataProvider** | Provides test data to a test method (declared with annotation). |

==== Category Overview ====

^ Category ^ Purpose ^ Example ^
| Assertions | Verify conditions | assertEquals(5, $result) |
| Expectations | Define expected behavior (exceptions, output) | $this->expectException(...) |
| Lifecycle Hooks | Setup and cleanup | setUp(), tearDown() |
| Data Provider | Supply test data | @dataProvider provideValues |

==== Tips on Tests ====

Combine setUp() and tearDown() with assertions to make your tests clean, isolated, and repeatable.
For example, prepare a database connection in setUp() and close it in tearDown().

==== PHPUnit Command Line Options ====

Below is a list of commonly used PHPUnit CLI options.  
Use **./vendor/bin/phpunit [options] [tests]** to run your tests.

==== Basic Options ====

^ Option ^ Description ^
| **--version** | Displays the PHPUnit version. |
| **--help** | Shows all available command line options. |
| **--list-groups** | Lists all defined test groups. |
| **--list-tests** | Lists all discovered test methods. |
| **--list-tests-xml <file>** | Saves the list of tests to an XML file. |
| **--bootstrap <file>** | Loads a PHP file before running the tests (e.g. for autoload or setup). |
| **--configuration <file>** | Specifies a custom PHPUnit configuration file (default: `phpunit.xml` or `.dist`). |
| **--no-configuration** | Runs tests without loading any configuration file. |

==== Running and Filtering Tests ====

^ Option ^ Description ^
| **--filter <pattern>** | Runs only tests whose name matches the given regex or substring. |
| **--group <name>** | Runs only tests that belong to one or more specified groups. |
| **--exclude-group <name>** | Excludes tests belonging to the given group(s). |
| **--testsuite <name>** | Runs only a specific test suite defined in the configuration. |
| **--repeat <n>** | Runs the test suite *n* times (useful for flaky tests). |
| **--stop-on-failure** | Stops execution upon the first failed test. |
| **--stop-on-error** | Stops upon the first error (not just failure). |
| **--stop-on-warning** | Stops upon the first warning. |
| **--stop-on-risky** | Stops upon the first risky test. |
| **--stop-on-skipped** | Stops upon the first skipped test. |
| **--stop-on-incomplete** | Stops upon the first incomplete test. |

==== Output and Reporting ====

^ Option ^ Description ^
| **--colors=always|never|auto** | Enables, disables, or auto-detects colored output. |
| **--verbose** | Increases verbosity level (shows more details). |
| **--display-deprecations** | Displays deprecation warnings. |
| **--display-errors** | Displays PHP errors that occur during testing. |
| **--display-warnings** | Displays PHPUnit warnings. |
| **--order-by=<order>** | Defines test execution order (`default`, `defects`, `random`, `duration`, etc.). |
| **--reverse-list** | Reverses the test execution order. |
| **--fail-on-warning** | Marks the run as failed if warnings occur. |
| **--fail-on-risky** | Marks the run as failed if risky tests are detected. |
| **--fail-on-incomplete** | Marks the run as failed if there are incomplete tests. |
| **--fail-on-skipped** | Marks the run as failed if there are skipped tests. |

==== Generating Reports ====

^ Option ^ Description ^
| **--log-junit <file>** | Writes results in JUnit XML format (used by CI tools). |
| **--testdox-text <file>** | Creates a plain text report in TestDox format. |
| **--testdox-html <file>** | Creates an HTML TestDox report. |
| **--testdox-xml <file>** | Creates an XML TestDox report. |
| **--coverage-html <dir>** | Generates an HTML code coverage report in the specified directory. |
| **--coverage-clover <file>** | Generates a Clover XML coverage report (useful for CI). |
| **--coverage-text** | Displays coverage summary in the console. |
| **--coverage-php <file>** | Exports raw coverage data as a PHP file. |

==== Miscellaneous ====

^ Option ^ Description ^
| **--debug** | Displays debugging information during test execution. |
| **--dont-report-useless-tests** | Suppresses warnings for tests without assertions. |
| **--extensions <ext>** | Loads PHPUnit extensions. |
| **--process-isolation** | Runs each test in a separate PHP process. |
| **--random-order-seed <n>** | Specifies a seed value for random test order (useful for reproducibility). |
| **--cache-result** | Enables caching of test results. |
| **--no-coverage** | Disables code coverage collection. |

==== Tip ====

You can combine multiple options.  
Example:

<code bash>
./vendor/bin/phpunit --filter "DatabaseTest" --colors=always --stop-on-failure
</code>
This command runs only tests matching DatabaseTest, uses colored output, and stops on the first failure.

===== Code Coverage =====

Enable Xdebug or PCOV for coverage reporting:
<code bash> 
php -m | grep xdebug 
</code>

Common options:
<code bash>
vendor/bin/phpunit --coverage-text
vendor/bin/phpunit --coverage-html build/coverage
</code>

> Coverage helps identify untested code paths — aim for meaningful tests, not 100 %.

===== Test Doubles (Mocks & Stubs) =====

Use PHPUnit’s built-in mocking API to isolate dependencies:

<code php> $repo = $this->createMock(UserRepository::class); $repo->method('find')->willReturn($user); </code>

Or set expectations:

<code php> $service = $this->createMock(MailService::class); $service->expects($this->once())->method('send')->with('test@example.com'); </code>

For more complex scenarios, external libraries like **Mockery** may be used.

===== Continuous Integration (GitHub Actions) =====

<code yaml> name: PHPUnit Tests

on: [push, pull_request]

jobs:
phpunit:
runs-on: ubuntu-latest
strategy:
matrix:
php: ['8.2', '8.3']
steps:
  - uses: actions/checkout@v4

  - uses: shivammathur/setup-php@v2
    with:
      php-version: ${{ matrix.php }}
      coverage: xdebug
      tools: composer

  - name: Install dependencies
    run: composer install --no-interaction --prefer-dist

  - name: Run PHPUnit tests
    run: vendor/bin/phpunit --coverage-text
</code>

**Explanation**:
  * Automatically runs on each push and pull request.
  * Tests multiple PHP versions (8.2, 8.3).
  * Generates coverage output using Xdebug.
  * Ensures consistent quality checks before merging.

===== Best Practices =====

  * Follow **AAA pattern** (Arrange–Act–Assert), alternatively use Given-When-Then 
  * Use **assertSame()** for strict comparisons.
  * Avoid hidden dependencies (DB, filesystem, HTTP).
  * Keep test data local and deterministic.
  * Run PHPUnit locally and in CI for fast feedback.


==== How to write good tests ====

  * For each test method to just assert one condition. This makes the test much clearer and easier to maintain.  We also get better output from the test runner.
  * If you want to test a class, it's common practise to match the name of the test class to the class you're using. 
  * 

=== Strategy: How to cover all methods and cases ===

Use a layered approach that combines *specification*, *systematic test design*, and *tooling*:

  - **Define the contract per method** (inputs, outputs, side effects, invariants, exceptions).
  - **Design a test matrix** (happy path, edges, invalid input, error handling).
  - **Automate completeness** with coverage (line + branch), mutation testing, and CI gates.
  - **Keep tests maintainable** with data providers, fixtures, and mocks/stubs.

==== 1) Specify each method’s contract (short) ====
For every public method, note:
  * Accepted input domains (types, ranges, nullability)
  * Output / return type and postconditions
  * Side effects (DB writes, IO, logs) and interactions
  * Error behaviour (which exceptions when, messages/codes)

This becomes your checklist for tests.

==== 2) Create a Test Matrix per method ====
Use equivalence classes + boundary analysis. Start with this minimal grid:

^ Case Type ^ Example(s) ^ Expected Outcome ^
| Happy Path | Typical valid input | Correct result, no exception |
| Boundaries | Min/Max, empty string, zero, 1 element, large sizes, locale quirks | Result correct, no exception |
| Invalid Types/Values | null, wrong type, negative where not allowed | Specific exception thrown |
| Preconditions Violated | Missing dependency, not initialized state | Specific exception or guard |
| Side Effects | Writes to DB/FS, emits event | Interaction verified (mock) |
| Concurrency/Order | Re-entrancy, double-call | Stable behavior or guarded |
| Security/Robustness | Injection-like input, huge payload | Safe handling, limits, exception |

**Tip**: Keep a small wiki page per class with one matrix per method.

==== 3) Turn the matrix into tests with Data Providers ====
Use data providers to cover many variants concisely.

**Example (PHPUnit):**
<code php>
#[DataProvider('validInputs')]
public function testCalculate_valid($input, $expected)
{
    $this->assertSame($expected, $this->svc->calculate($input));
}

public static function validInputs(): array
{
    return [
        'simple'      => [[1,2,3], 6],
        'empty'       => [[], 0],
        'large'       => [range(1, 1000), 500500],
    ];
}
</code>

**Failure/exception path:**
<code php>
public function testCalculate_throwsOnNegative()
{
    $this->expectException(InvalidArgumentException::class);
    $this->expectExceptionMessage('negative not allowed');
    $this->svc->calculate([-1]);
}
</code>

==== 4) Verify interactions with test doubles ====
Mock collaborators to assert side effects and isolation.
<code php>
$repo = $this->createMock(UserRepository::class);
$repo->expects($this->once())->method('save')->with($this->isInstanceOf(User::class));
$svc = new UserService($repo);

$svc->register('alice@example.com');
</code>

==== 5) Enforce completeness with coverage (line + branch) ====
Run coverage locally (Xdebug or PCOV):

<code bash>
$ ./vendor/bin/phpunit --coverage-html build/coverage
</code>

In phpunit.xml enable branch coverage and include paths:
<code xml>
<phpunit colors="true">
  <coverage processUncoveredFiles="true">
    <include>
      <directory>app</directory>
      <directory>src</directory>
    </include>
    <report>
      <html outputDirectory="build/coverage"/>
    </report>
  </coverage>
</phpunit>
</code>

Targets: Line ≥ 90%, Branch ≥ 80% (adjust to your risk appetite).
Remember: Coverage shows what ran, not that logic is correct → see mutation testing.

==== 6) Mutation Testing (catches weak assertions) ====
Use a mutator (e.g., Infection) to ensure your tests fail when code is subtly changed.

<code bash>
$ composer require --dev infection/infection
$ vendor/bin/infection --min-msi=80 --min-covered-msi=80
</code>

If MSI drops, add/strengthen tests.

==== 7) Property-based tests for tricky logic ====
For algorithms/validators, generate many inputs (e.g., Eris library) to discover edge cases automatically.

==== 8) CI gates to keep quality steady ====
In CI:
  * Run unit tests with --fail-on-warning and --stop-on-failure for fast feedback.
  * Publish coverage artifact, fail build if below thresholds.
  * Run mutation tests nightly or on main branch.

==== 9) Ready-to-use checklist (copy/paste) ====

^ Item ^ Done? ^
| Contract documented (input/output/errors) | |
| Happy path covered | |
| Boundary cases covered (min/max/empty/zero/1-item/large) | |
| Invalid inputs raise correct exceptions (type/value/null) | |
| Preconditions/illegal state handled (guards) | |
| Side effects verified (mocks/stubs) | |
| Error messages/codes asserted (not only class) | |
| Branch coverage ≥ target | |
| Mutation score ≥ target | |
| Data provider used where multiple variants | |
| Negative tests present for every public method | |

==== 10) Small example tying it together ====

**Method contract (summary):**
  * parseIsoDate(string $s): DateTimeImmutable
  * Accepts YYYY-MM-DD
  * Throws InvalidArgumentException on invalid format or impossible dates

Tests (sketch):
<code php>
#[DataProvider('validDates')]
public function testParseIsoDate_valid($s, $y, $m, $d)
{
    $dt = $this->svc->parseIsoDate($s);
    $this->assertSame($y, (int)$dt->format('Y'));
    $this->assertSame($m, (int)$dt->format('m'));
    $this->assertSame($d, (int)$dt->format('d'));
}

public static function validDates(): array
{
    return [
        ['2025-01-01', 2025, 1, 1],     // boundary: year start
        ['2024-02-29', 2024, 2, 29],    // leap day
    ];
}

public function testParseIsoDate_invalidFormat()
{
    $this->expectException(InvalidArgumentException::class);
    $this->expectExceptionMessage('invalid ISO date');
    $this->svc->parseIsoDate('01/02/2025');
}

public function testParseIsoDate_impossibleDate()
{
    $this->expectException(InvalidArgumentException::class);
    $this->svc->parseIsoDate('2025-02-30');
}
</code>

==== TL;DR ====

  * Write a test matrix per method (happy, boundary, invalid, state, side effects).
  * Use data providers for breadth; expectations for error paths.
  * Enforce completeness with branch coverage + mutation testing.
  * Automate via CI gates so the bar stays high.

===== Troubleshooting =====

^ Problem ^ Likely Cause ^ Fix ^
| Tests not running | Autoload missing | Include vendor/autoload.php in config |
| No coverage output | Xdebug/PCOV disabled | Enable in php.ini or via PECL |
| Class not found | Namespace mismatch | Check PSR-4 configuration |
| Flaky tests | Shared state or I/O | Mock external resources |

===== Related Topics =====

  * [[home:php:test:pest:|Pest]] – Simpler, expressive syntax on top of PHPUnit
  * [[home:php:test:overview:|PHP Unit tests]] – General concepts and best practices
  * [[home:php:pkg:composer|Composer]] – Dependency management
  * [[home:php:automation:build-tools:|Build Automation]] – CI/CD pipelines
