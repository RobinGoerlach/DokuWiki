**[[home:|Start]]** -> **[[home:php:|PHP]]** -> **[[home:php:test:|PHP Unit testing]]** -> **PHP Unit**

====== PHPUnit ======

  * [[https://www.udemy.com/course/php-unit-testing|PHP Unit Testing with PHPUnit]]
  * [[https://www.linkedin.com/learning/php-test-driven-development-with-phpunit/welcome|PHP: Test-Driven Development with PHPUnit]]

[[https://phpunit.de/|PHPUnit (Project Homepage)]] is the **de-facto standard testing framework for PHP**.
It provides assertions, mocks, coverage integration, and CLI tooling for reliable, automated unit and integration tests. The Code of PHPUnit is open-Source and available at  [[https://github.com/sebastianbergmann/phpunit/releases|GitHub]], therefore check the [[https://phpunit.de/announcements/index.html|Announcements for PHPUnit]] to get hold of new releases.

  * [[home:php:test:pest:|Pest]] — Alternative test runner

**Tip**: PHPUnit tests are written as classes extending PHPUnit\Framework\TestCase.
Each test method should verify one specific behavior.

<code php>
<?php
declare(strict=1);
use PHPUnit\Framework\TestCase;

final class ExampleTest extends TestCase
{
   public function testTwoValuesAreTheSame(): void
   {
      require 'function.php';
      
      $this->assertEquals(4, add(2, 2);
   }
}
</code>
To run those tests, you need to install some software, like phpunit-12.1.6.phar. If PHPUnit is installed you can check the version by running the **phpunit** command in the command line application of your operating system (PowerShell or Terminal). You don't need a web server in order to run the tests.

===== Installation =====
There a multiple ways to install PHPUnit. The first is to download it as a PHP Archive Archive File. This is the recommended way to install and use PHPUnit by the developers from PHPUnit.

Installing Documentation for installing [[https://docs.phpunit.de/en/12.1/installation.html#installing-phpunit|PHPUnit as PHAR]] (PHP Archive Archive File). To do this, go to [[https://phar.phpunit.de/|phar.phpunit.de]] in a browser. Tin the **Latest Release** section, click the file named **PHPUnit followed by a numeric version with the .par suffix**. This will download the file.
<code bash>
wget -O phpunit.phar https://phar.phpunit.de/phpunit-12.1.6.phar
</code>
It is **common practice to install PHPUnit into each project** instead of installing it globally. This avoids version issues between different projects. To do this from the root of your project folder, create a folder called tools. Then copy the file you just downloaded into that folder and rename it to just phpunit.phar. So now the tools folder contains the PHP executable file. you should now be able to run this directly like this.
<code bash>
php tools/phpunit.phar --version
</code>
We can make running this a bit simpler. On Windows you can create a script with a command like this, which results in a script called phpunit.cmd in the project root folder. You can then run this with just  the phpunit command
<code powershell>
echo @php "%~dp0tools/phpunit.phar" %* > phpunit.cmd
</code>
On Mac or Linux you can make the file executable 
<code bash>
chmod +x tools/phpunit.phar
tools/phpunit.phar --version
</code>
You can then run this with out having to prefix it with the php command, but you have to include the tools directory or add an alias after make the file executable
<code bash>
alias phpunit=tools/phpunit.phar
phpunit --version
</code>
Now you can runit on macOS or Linux with just the phpunit command.

If you prefer, you can install the phar file using Phive, as described in the [[https://docs.phpunit.de/en/12.1/installation.html#installing-phpunit-with-phive|PHPUnit Documentation Section - Installing PHPUnit with Phive]]. 


The other way to **install PHPUnit with Composer**. To do this you need to make sure you have Composer installed and working on the command line. You can check this by running the composer command with the uppercase -V flag to output the installed version.
<code bash>
composer -V
</code>
If you don't have Composer installed, it's simple to install and full instructions are shown on the [[https://getcomposer.org/|officiel Composer website]]. Choose the [[https://getcomposer.org/doc/00-intro.md|instructions]] that match your operating system. On Linux you can use your package manager to install it, with all needed dependencies.

Installing PHPUnit as an development dependency (not needed in production) in our project 
<code bash>
$ composer require --dev phpunit/phpunit 
</code>
Check the composer.json and composer.lock file in the project root folder or check the version:
<code bash>
$ vendor/bin/phpunit --version 
</code>
To make this easier you can add an optional alias or create a shell script as descripted above. In Windows Powershell you can add with this command
<code powershell>
Set-Alias -Name phpunit -Value "./vendor/bin/phpunit"
</code>
With the alias, we can now run PHPUnit with just the phpunit command
<code powershell>
phpunit --version
</code>

Alternatively you can also **install PHPUnit globally using Phive** (not recommended):
<code bash>
$ phive install phpunit 
</code>
As long as you can run PHPUnit on the command line it doesn't matter which method you use to install PHPUnit.
===== Writing a First Test =====
First let's create a **folder to store the test code**. You can call this folder whatever you like, but it's typical to **call the folder tests**

A test in PHPUnit is just a PHP class. So inside of this folder let's create a new file called Test.php. The test class is final as we're not going to need to extend this class. Make sure that the **class name matches the file name** so autoloading works. Test classes needs to **extend a specific class from the PHPUnit** framework.
<code php>
<?php
declare(strict_types=1);
use PHPUnit\Framework\TestCase;

final class Test extends TestCase
{
   public function testTwoValuesAreTheSame(): void
   {
      $this->assertSame(1, 1); /* assert that two values are the same */
   }
}
</code>
In the this class we define **public methods that perform tests**. Inside the test methods we use assert messages. These are used to assert or check that something is as expected.
<code bash>
phpunit tests/Test.php
</code>
If the output says OK,there was one test and one assertion, we're fine, because this means that the test passed. If we get output that says there was a FAILURE! then the test failed. The output includes the location in the method and the class where the failure occurred. We get a message describing exactly what the failure was.

This example test isn't actually doing  anything useful. It just contains an assertion with literal values. Instead of tests like this, normally we write tests to test application code. This code is typically defined inside function and classes.

===== Testing Application Code =====

==== Project Layout ====
The normal PHP Project should have the following file and folder structure
^ Path ^ Purpose ^
| **bootstrap.php** | Optional autoloader/environment setup |
| **composer.json** | |
| **composer.lock** | |
| **lib** | Application library's folder |
| **phpunit.xml.dist** | Default PHPUnit configuration |
| **public** | **index.php** as application entry point |
| **src/** | Application code |
| **tests/** | Test classes (unit/integration) |
| **vendor/** | Composer dependencies |

> Commit the //phpunit.xml.dist// file to version control and let developers copy it to //phpunit.xml// for local overrides.

==== Application Code Example ====
The Application Code to test: **src/Calculator.php**
<code php> 
<?php 
declare(strict_types=1);

namespace App;

class Calculator {
  public function addIntegers(int $a, int $b): int {
    return $a + $b;
  }
}
</code>
This code could be part of an application or a library function. This class contains a single function called  addInteger, that takes two integer and returns the sum of those two integers. This is a trivial function  that you wouldn't typically write, but it serves to demonstrate how we would test a function like this. 

Without PHPUnit, you might test it by running it from another script, providing it with different values for its arguments, and printing the results. With PHPUnit though, we can test this programmatically.
 
==== Application Test Example ====
The Unit test code file: **tests/CalculatorTest.php**, in the tests folder, should refer with it's name to the file name to be tested. In the test file we'll start as in other classes. So the PHP opening tag, we'll enable strict type checking, and defining a class called CalculatorTest that extends the PHPUnit test case class. Then we add a test function. Inside this method using the assertSame method to check that the return value from the function is as expected. The first argument to this function is the expected value, and the second argument is the actual value. Before we can test this we need to explicitly load the file where the function is defined, as this isn't done automatically. So before the class definition lets require that file. As this will be relative to this test file use the dirname function with the DIR constant to go up to the parent folder before adding the path
<code php> 
<?php 
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
require dirname(__DIR__) . '../src/Calculator.php'; /* use App\Calculator; */

final class CalculatorTest extends TestCase
{
  /** @test */
  public function testAddIntegers(): void 
  {
    $calc = new Calculator();
    $this->assertSame(5, $calc->addIntegers(2, 3)); /* 2 + 3 = 5 */
  }
}
</code>
**tests/CalculatorTest.php**

On the command line, let's run that test, passing the path of the functions test file to the test
<code bash> 
$ vendor/bin/phpunit tests/CalculatorTest.php
</code>
If we get an OK output, we know we passed the test. So ew just wrote a test that executed the addIntegers function, and tested that its return value was as we expected it to be.
<code php>
/** @test */ 
public function test_AddIntegers(): void 
{ 
</code>
The **@test annotation** tells PHPUnit this is a test method not a normal method. The **test_** prefix, with or without underscore, tells PHPUnit this is a **test method** as an alternative naming convention. You can choose which way you will take to mark a test method as a test method, but be consistent.

**To comprehensively test this function, we should test as many aspects of it as we can**. For example, let's test that the function adds two negative number together correctly. To do this, we could add another assertion to the existing test method like this.
<code php> 
<?php 
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
require dirname(__DIR__) . '../src/Calculator.php'; /* use App\Calculator; */

final class CalculatorTest extends TestCase
{
  /** @test */
  public function testAddIntegers(): void 
  {
    $calc = new Calculator();
    $this->assertSame(5, $calc->addIntegers(2, 3)); /* 2 + 3 = 5 */
    $this->assertSame(-5, $calc->addIntegers(-2, -3)); /* -2 + -3 = -5 */
  }
}
</code>
The result of phpunit should give us OK (1 test, 2 assertions). However, best practice when it comes to writing tests is for each test method to just assert one condition. This makes the test much clearer and easier to maintain.  We also get better output from the test runner.
<code php> 
<?php 
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
require dirname(__DIR__) . '../src/Calculator.php'; /* use App\Calculator; */

final class CalculatorTest extends TestCase
{

  public function testAddTwoPositivIntegers(): void 
  {
    $calc = new Calculator();
    $this->assertSame(5, $calc->addIntegers(2, 3)); /* 2 + 3 = 5 */
  }

  public function testAddTwoNegativeIntegers(): void 
  {
    $calc = new Calculator();
    $this->assertSame(-5, $calc->addIntegers(-2, -3)); /* -2 + -3 = -5 */
  }
}
</code>
It's a good idea to make the names of the test methods as verbose as you can, as ultimately this is a form of documentation and tells you exactly what the method is testing. So now we have two test methods, each with one assertion. Each method is testing just one specific aspect of the code. Now when we run this, it's still OK, but now with two tests and two assertions.

To get the full range of test methods add some more like adding positive and negative integers and adding zero to an integer, is addition in this function commutative (2+3=3+2).
<code php> 
<?php 
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
require dirname(__DIR__) . '../src/Calculator.php'; /* use App\Calculator; */

final class CalculatorTest extends TestCase
{

  public function testAddTwoPositivIntegers(): void 
  {
    $calc = new Calculator();
    $this->assertSame(5, $calc->addIntegers(2, 3)); /* 2 + 3 = 5 */
  }

  public function testAddTwoNegativeIntegers(): void 
  {
    $calc = new Calculator();
    $this->assertSame(-5, $calc->addIntegers(-2, -3)); /* -2 + -3 = -5 */
  }

  public function testAddTwoNegativeIntegers(): void 
  {
    $calc = new Calculator();
    $this->assertSame(-5, $calc->addIntegers(-2, -3)); /* -2 + -3 = -5 */
  }

  public function testAddPositivAndNegativeIntegers(): void 
  {
    $calc = new Calculator();
    $this->assertSame(1, $calc->addIntegers(3, -2)); /* 3 + -2 = 1 */
  }

  public function testAddZeroToInteger(): void 
  {
    $calc = new Calculator();
    $this->assertSame(3, $calc->addIntegers(3, 0)); /* 3 + 0 = 3 */
  }

  public function testAddingIsCommutative(): void 
  {
    $calc = new Calculator();
    $this->assertSame($calc->addIntegers(2, 3), $calc->addIntegers(3, 2)); /* 3 + 2 = 2 + 3 */
  }
}
</code>
Output, if we run this, should be five teste and five assertions. Note that the output shows one dot for each time a test method passes, so we should have five dots. As his is a simple test, it executed very quickly, but for more complex tests, the appearance of  these dots shows the progress of the tests as they run.

To see what happens when a test fails, change the expected value of a test. If you run this you'll see you get an F instead of a dot for that test and instead of a OK a FAILURES with Tests: 5, Assertions: 5 Failures: 1. Additionally you'll get a message which test failed, why and where it failed. This is the reason why having one assertion per test is the best way to write tests. We can see straight away which test method is failing.

As each test method is responsible for testing a special aspect of the code and as we've been verbose when naming each method, it's much clearer what each test is doing. If you want to test a class, it's common practise to match the name of the test class to the class you're using. 
===== Configuring the Command-Line Test-Runner =====

As we learned **PHPUnit** is run on the command line. The application that runs is known as the **command line test runner**. So far we've run the test class we want by passing the path to this application.
<code bash>
phpunit tests/PersonTest.php
</code>
In Addition to this, there are many different options we can pass in when running tests. For example, to get colours in the output, we can specify the colors flag.

==== Controlling the Test Runner Output ====
to get colours in the output, we can specify the colors flag.
<code bash>
phpunit tests/PersonTest.php --colors
</code>
Now the output contains colours - specifically for this test in which all the test passed, the summary is highlighted in green.

If you run a test that fails, then you'll get different colours. In the characters that are printed out for each test, in addition to the one that failed being shown as the letter F, this is highlighted in red. Likewise for the summary, which is also highlighted in red. 

If you like, you can get the test runner to **stop running the tests when one fails** by specifying the **stop-on-failure** flag
<code bash>
phpunit tests/PersonTest.php --colors --stop-on-failure 
</code>
Now only the test passing will run and stop after the first failure. When a test does fail, we get the name of the test method printed out. However, even with the colours option, this isn't highlighted in any way, and we don't get any details at all about the test that passed only a dot for each one. the main advantage of this default output format is that it is concise. So if you have a lot of tests, it gives you a good overview. If you want **more details**, try specifying the **testdox option**.
<code bash>
phpunit tests/PersonTest.php --colors --testdox
</code>
This gives much more detail in output, converting the test method names into text descriptions of each one. When used along with the colours option, this shows green ticks for the tests that pass, and failed tests are highlighted with a red cross. This format is much more descriptive, and this output can even be used **as a base for documenting your tests**. This is why it's important to give as much details as possible when naming test methods. The testdox output will help you to do this. See a comprehensive list on [[http://docs.phpunit.de/en/12.1/textui.html#command-line-options|Command-Line Options documentation]] at the official [[http://docs.phpunit.de/en|PHPUnit Manual]]. You can also get a list of all options by specifying the help flag on the command line.
<code bash>
phpunit tests/PersonTest.php --help
</code>
==== Run a Script before Test execution ====
One of the options available when running PHPUnit is the bootstrap option, which runs a PHP script before any of the tests run. While you could in theory put any PHP code in such a script, this is typically used to just load the files that the test requires.

So, for example, in the case of a function test, in order to run a test we need to require a PHP library in the lib folder. This require can be stored in a separate script instead. So let's create a new file **in the tests folder** called **bootstrap.php**. Note you can name this script anything you like, but bootstrap.php is a typical name. Now move the required statements from the tests file to the bootstrap.php
<code php>
<?php
require dirname(__DIR__) . '/lib/functions.php';
</code> 
Running the tests now, will lead to a lot of expected errors due to missing require statement in the tests file. If you specify the bootstrap option followed by the path to the bootstrap.php file, then the test works.
<code bash>
phpunit tests/FunctionTests.php --bootstrap tests/bootstrap.php
</code>
Now the testrunner will run without any errors, even if you still get a failure in a test.
==== Add Autoloader to load Classes Automatically ====
In testing classes the test file will contain a require line that loads the file where that class is defined. We could require this file explicitly in the bootstrap.php, but we can add this with an autoloader. This means any class will be loads automatically, which is useful if we have tests that test lots of different classes.

We can call the spl_autoload_register function in the bootstrap.php, passing in an anonymous callback function as the only argument. 
<code php>
<?php
require dirname(__DIR__) . '/lib/functions.php';
spl_autoload_register(function($class) {
  $file = require dirname(__DIR__) . '/src/' . str_replace('\\', '/',$class) . '.php';
  if (file_exists($file)) {
    require $file;
  }
});
</code>
Assuming we're using PSR-4 autoloading we can get the path to the class by converting any namespaces to folder names and str_replace will convert this for us by converting backslash to forward slashes.
<code bash>
phpunit tests/PersonTest.php --bootstrap /tests/bootstrap.php
</code>
Try running your test again and it should work as before.

==== Using Composer's Autoloader ====
For simple projects it might be enough to define a simple autoloader in the bootstrap file. However, and especially as we're assuming a PSR-4 autoloader structure, it's much more common to use Composer to autoload classes. First, we need to tell Composer where to autoload the classes from. We do this in the composer.json file.
<code json>
{
  "autolad": {
    "psr-4": {
      "": "src/"
    }
  }
}
</code>
Use an empty prefix, so any class or namespace will be looked for inside the specified folder as the value of the empty prefix use the src folder as the value.
<code bash>
composer dump-autoload
</code>
To generate the autoload script, we run the **composer dump-autoload** command on the command line. This will create a vendor folder containing a script called autoload.php, if you already had this file, it will have been updated. If we run the test again, we can use the vendor/autolader.php script as the bootstrap option.
<code bash>
phpunit test/PersonTest.php --bootstrap vendor/autoload.php
</code>
This is typically how PHPUnit tests are configured -using Composer to autoload the code being tested. Note that if you run a functions test and specify Composer's autoloader, then this no longer works, as we're not requiring the file where the function beeing teste is defined.

We can autoload specific files in Composer by adding a files section to the autoloader section in composer.json
<code json>
{
  "autolad": {
    "psr-4": {
      "": "src/"
    },
    "files": [
    "lib/functions.php"
    ]
  }
}
</code>
To regenerate the autoload script we need to run composer dump-autoload. Now if we run a function test again, it works.
<code bash>
phpunit test/Function.php --bootstrap vendor/autoload.php
</code>
==== The PHPUnit Configuration File ====

We can specify various options by passing flags to the PHPUnit test rummer. Instead of having to include these options every time we run a test, we can specify them in a configuration file. 
<code bash>
phpunit --generate-configuration
</code>
While we could create that file directly, the test runner can generate it with the generate-configuration option. This will ask what some questions
  * The **bootstrap script** should be with a default of vandor/autload.php, you can press enter to accept the default, or you type the path to the bootstrap script. 
  * Next question is the **tests directory** location. The default directory is called tests which you can accept by pressing enter
  * The same for the **source code directory** where the classes are defined.
  * The **cache directory** is where PHPUnit stores its cache, which speeds up testing when rerunning tests. **Note** to exclude the .phpuni.cache directory from version control. Add it to your .gitignore file
This are the current question and it has generated a file called phpunit.xml in the root of the project.

In that file, which is XML, we can see that some options are specified as attributes to the root phpunit element, such as the bootstrap.
<code xml> 
<?xml version="1.0" encoding="UTF-8"?>
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="vendor/phpunit/phpunit/phpunit.xsd"
         bootstrap="vendor/autoload.php"
         cacheDirectory=".phpunit.cache"
         executionOrder="depends,defects"
         shortenArraysForExportThreshold="10"
         requireCoverageMetadata="true"
         beStrictAboutCoverageMetadata="true"
         beStrictAboutOutputDuringTests="true"
         displayDetailsOnPhpunitDeprecations="true"
         failOnPhpunitDeprecation="true"
         failOnRisky="true"
         failOnWarning="true">
    <testsuites>
        <testsuite name="default">
            <directory>tests</directory>
        </testsuite>
    </testsuites>
    <source ignoreIndirectDeprecations="true" restrictNotices="true" restrictWarnings="true">
        <include>
            <directory>src</directory>
        </include>
    </source>
    <coverage includeUncoveredFiles="true"> 
      <include> 
        <directory>
          src
        </directory> 
      </include> 
      <report> 
        <html outputDirectory="build/coverage"/> 
        <text outputFile="php://stdout" showUncoveredFiles="false"/> 
      </report> 
    </coverage> 
</phpunit> 
</code>
To keep this simple, you can remove all the options from executionOrder to the end of phpunit attributes
This configuration file is a minimalistic version of a configuration file.

As for the test suites and the source elements, these define where the test classes are and where the classes we're testing are. In your own minimalistic version you could also remove the rest from source to the end, but leave the last line phpunit.

If you don't want to generate a phpunit.xml, you can copy default configuration file **phpunit.xml.dist** into the project root. The hpunit.xml.dist is a minimalistic version of a phpunit.xml configuration 
<code xml>
<?xml version="1.0" encoding="UTF-8"?>
<phpunit bootstrap="tests/bootstrap.php" colors="true">
  <testsuites>
    <testsuite name="TabKeeper API">
      <directory>tests</directory>
    </testsuite>
  </testsuites>
</phpunit>
</code>



Run with coverage:
<code bash>
$ vendor/bin/phpunit --coverage-html build/coverage 
</code>

> Open build/coverage/index.html in your browser for a visual report.

----
===== PHPUnit Assertions, Expectations, and Other Test Methods =====

PHPUnit provides several groups of methods to help you write clean, structured, and reliable tests.

The main categories are:

  * **Assertions (`assert*`)** – Check that a condition holds true.
  * **Expectations (`expect*`)** – Define expected behavior (e.g., exceptions or output).
  * **Helper & Lifecycle Methods** – Prepare and clean up test environments.

==== Assert Methods ====

^ Method ^ Description ^
| **assertTrue($condition)** | Checks that the condition is true. |
| **assertFalse($condition)** | Checks that the condition is false. |
| **assertNull($value)** | Checks that the value is `null`. |
| **assertNotNull($value)** | Checks that the value is **not** `null`. |
| **assertEmpty($value)** | Checks that the value is empty (`[], '', null, 0`, etc.). |
| **assertNotEmpty($value)** | Checks that the value is **not** empty. |
| **assertEquals($expected, $actual)** | Compares two values for equality (not identical, `==`). |
| **assertSame($expected, $actual)** | Checks for strict equality (`===`). |
| **assertNotEquals($expected, $actual)** | Checks that two values are **not** equal. |
| **assertNotSame($expected, $actual)** | Checks that two values are **not** identical. |
| **assertInstanceOf($class, $object)** | Checks that an object is an instance of a class. |
| **assertNotInstanceOf($class, $object)** | Checks that an object is **not** an instance of a class. |
| **assertContains($needle, $haystack)** | Checks that a value exists in an array or string. |
| **assertNotContains($needle, $haystack)** | Checks that a value does **not** exist in an array or string. |
| **assertCount($expectedCount, $array)** | Checks that an array has a specific length. |
| **assertGreaterThan($expected, $actual)** | Checks that `$actual` is greater than `$expected`. |
| **assertLessThan($expected, $actual)** | Checks that `$actual` is less than `$expected`. |
| **assertStringContainsString($needle, $haystack)** | Checks that a string contains a substring. |
| **assertStringStartsWith($prefix, $string)** | Checks that a string starts with a prefix. |
| **assertStringEndsWith($suffix, $string)** | Checks that a string ends with a suffix. |
| **assertFileExists($filename)** | Checks that a file exists. |
| **assertFileDoesNotExist($filename)** | Checks that a file does **not** exist. |
| **assertJson($string)** | Checks that a string is valid JSON. |
| **assertMatchesRegularExpression($pattern, $string)** | Checks that a regex matches the string. |

==== Expect Methods ====

^ Method ^ Description ^
| **expectException($class)** | Expects a specific exception to be thrown. |
| **expectExceptionMessage($message)** | Expects a specific exception message. |
| **expectExceptionCode($code)** | Expects a specific exception code. |
| **expectOutputString($string)** | Expects a specific output (`echo`, `print`). |
| **expectOutputRegex($pattern)** | Expects output that matches a regex pattern. |

**Example:**
<code php>
$this->expectException(InvalidArgumentException::class);
$this->expectExceptionMessage('Invalid user ID');
</code>

==== Other Useful Methods and Hooks ====

^ Method ^ Description ^
| **setUp(): void** | Runs before each test – used for initialization. |
| **tearDown(): void** | Runs after each test – used for cleanup. |
| **setUpBeforeClass(): void** | Runs once per test class before all tests. |
| **tearDownAfterClass(): void** | Runs once per test class after all tests. |
| **markTestSkipped($reason)** | Marks a test as skipped. |
| **markTestIncomplete($reason)** | Marks a test as incomplete. |
| **@dataProvider** | Provides test data to a test method (declared with annotation). |

==== Category Overview ====

^ Category ^ Purpose ^ Example ^
| Assertions | Verify conditions | assertEquals(5, $result) |
| Expectations | Define expected behavior (exceptions, output) | $this->expectException(...) |
| Lifecycle Hooks | Setup and cleanup | setUp(), tearDown() |
| Data Provider | Supply test data | @dataProvider provideValues |

==== Tips on Tests ====

Combine setUp() and tearDown() with assertions to make your tests clean, isolated, and repeatable.
For example, prepare a database connection in setUp() and close it in tearDown().

==== PHPUnit Command Line Options ====

Below is a list of commonly used PHPUnit CLI options.  
Use **./vendor/bin/phpunit [options] [tests]** to run your tests.

==== Basic Options ====

^ Option ^ Description ^
| **--version** | Displays the PHPUnit version. |
| **--help** | Shows all available command line options. |
| **--list-groups** | Lists all defined test groups. |
| **--list-tests** | Lists all discovered test methods. |
| **--list-tests-xml <file>** | Saves the list of tests to an XML file. |
| **--bootstrap <file>** | Loads a PHP file before running the tests (e.g. for autoload or setup). |
| **--configuration <file>** | Specifies a custom PHPUnit configuration file (default: `phpunit.xml` or `.dist`). |
| **--no-configuration** | Runs tests without loading any configuration file. |

==== Running and Filtering Tests ====

^ Option ^ Description ^
| **--filter <pattern>** | Runs only tests whose name matches the given regex or substring. |
| **--group <name>** | Runs only tests that belong to one or more specified groups. |
| **--exclude-group <name>** | Excludes tests belonging to the given group(s). |
| **--testsuite <name>** | Runs only a specific test suite defined in the configuration. |
| **--repeat <n>** | Runs the test suite *n* times (useful for flaky tests). |
| **--stop-on-failure** | Stops execution upon the first failed test. |
| **--stop-on-error** | Stops upon the first error (not just failure). |
| **--stop-on-warning** | Stops upon the first warning. |
| **--stop-on-risky** | Stops upon the first risky test. |
| **--stop-on-skipped** | Stops upon the first skipped test. |
| **--stop-on-incomplete** | Stops upon the first incomplete test. |

==== Output and Reporting ====

^ Option ^ Description ^
| **--colors=always|never|auto** | Enables, disables, or auto-detects colored output. |
| **--verbose** | Increases verbosity level (shows more details). |
| **--display-deprecations** | Displays deprecation warnings. |
| **--display-errors** | Displays PHP errors that occur during testing. |
| **--display-warnings** | Displays PHPUnit warnings. |
| **--order-by=<order>** | Defines test execution order (`default`, `defects`, `random`, `duration`, etc.). |
| **--reverse-list** | Reverses the test execution order. |
| **--fail-on-warning** | Marks the run as failed if warnings occur. |
| **--fail-on-risky** | Marks the run as failed if risky tests are detected. |
| **--fail-on-incomplete** | Marks the run as failed if there are incomplete tests. |
| **--fail-on-skipped** | Marks the run as failed if there are skipped tests. |

==== Generating Reports ====

^ Option ^ Description ^
| **--log-junit <file>** | Writes results in JUnit XML format (used by CI tools). |
| **--testdox-text <file>** | Creates a plain text report in TestDox format. |
| **--testdox-html <file>** | Creates an HTML TestDox report. |
| **--testdox-xml <file>** | Creates an XML TestDox report. |
| **--coverage-html <dir>** | Generates an HTML code coverage report in the specified directory. |
| **--coverage-clover <file>** | Generates a Clover XML coverage report (useful for CI). |
| **--coverage-text** | Displays coverage summary in the console. |
| **--coverage-php <file>** | Exports raw coverage data as a PHP file. |

==== Miscellaneous ====

^ Option ^ Description ^
| **--debug** | Displays debugging information during test execution. |
| **--dont-report-useless-tests** | Suppresses warnings for tests without assertions. |
| **--extensions <ext>** | Loads PHPUnit extensions. |
| **--process-isolation** | Runs each test in a separate PHP process. |
| **--random-order-seed <n>** | Specifies a seed value for random test order (useful for reproducibility). |
| **--cache-result** | Enables caching of test results. |
| **--no-coverage** | Disables code coverage collection. |

==== Tip ====

You can combine multiple options.  
Example:

<code bash>
./vendor/bin/phpunit --filter "DatabaseTest" --colors=always --stop-on-failure
</code>
This command runs only tests matching DatabaseTest, uses colored output, and stops on the first failure.

===== Code Coverage =====

Enable Xdebug or PCOV for coverage reporting:
<code bash> 
php -m | grep xdebug 
</code>

Common options:
<code bash>
vendor/bin/phpunit --coverage-text
vendor/bin/phpunit --coverage-html build/coverage
</code>

> Coverage helps identify untested code paths — aim for meaningful tests, not 100 %.

===== Test Doubles (Mocks & Stubs) =====

Use PHPUnit’s built-in mocking API to isolate dependencies:

<code php> $repo = $this->createMock(UserRepository::class); $repo->method('find')->willReturn($user); </code>

Or set expectations:

<code php> $service = $this->createMock(MailService::class); $service->expects($this->once())->method('send')->with('test@example.com'); </code>

For more complex scenarios, external libraries like **Mockery** may be used.

===== Continuous Integration (GitHub Actions) =====

<code yaml> name: PHPUnit Tests

on: [push, pull_request]

jobs:
phpunit:
runs-on: ubuntu-latest
strategy:
matrix:
php: ['8.2', '8.3']
steps:
  - uses: actions/checkout@v4

  - uses: shivammathur/setup-php@v2
    with:
      php-version: ${{ matrix.php }}
      coverage: xdebug
      tools: composer

  - name: Install dependencies
    run: composer install --no-interaction --prefer-dist

  - name: Run PHPUnit tests
    run: vendor/bin/phpunit --coverage-text
</code>

**Explanation**:
  * Automatically runs on each push and pull request.
  * Tests multiple PHP versions (8.2, 8.3).
  * Generates coverage output using Xdebug.
  * Ensures consistent quality checks before merging.

===== Best Practices =====

  * Follow **AAA pattern** (Arrange–Act–Assert), alternatively use Given-When-Then 
  * Use **assertSame()** for strict comparisons.
  * Avoid hidden dependencies (DB, filesystem, HTTP).
  * Keep test data local and deterministic.
  * Run PHPUnit locally and in CI for fast feedback.


==== How to write good tests ====

  * For each test method to just assert one condition. This makes the test much clearer and easier to maintain.  We also get better output from the test runner.
  * If you want to test a class, it's common practise to match the name of the test class to the class you're using. 
  * 

=== Strategy: How to cover all methods and cases ===

Use a layered approach that combines *specification*, *systematic test design*, and *tooling*:

  - **Define the contract per method** (inputs, outputs, side effects, invariants, exceptions).
  - **Design a test matrix** (happy path, edges, invalid input, error handling).
  - **Automate completeness** with coverage (line + branch), mutation testing, and CI gates.
  - **Keep tests maintainable** with data providers, fixtures, and mocks/stubs.

==== 1) Specify each method’s contract (short) ====
For every public method, note:
  * Accepted input domains (types, ranges, nullability)
  * Output / return type and postconditions
  * Side effects (DB writes, IO, logs) and interactions
  * Error behaviour (which exceptions when, messages/codes)

This becomes your checklist for tests.

==== 2) Create a Test Matrix per method ====
Use equivalence classes + boundary analysis. Start with this minimal grid:

^ Case Type ^ Example(s) ^ Expected Outcome ^
| Happy Path | Typical valid input | Correct result, no exception |
| Boundaries | Min/Max, empty string, zero, 1 element, large sizes, locale quirks | Result correct, no exception |
| Invalid Types/Values | null, wrong type, negative where not allowed | Specific exception thrown |
| Preconditions Violated | Missing dependency, not initialized state | Specific exception or guard |
| Side Effects | Writes to DB/FS, emits event | Interaction verified (mock) |
| Concurrency/Order | Re-entrancy, double-call | Stable behavior or guarded |
| Security/Robustness | Injection-like input, huge payload | Safe handling, limits, exception |

**Tip**: Keep a small wiki page per class with one matrix per method.

==== 3) Turn the matrix into tests with Data Providers ====
Use data providers to cover many variants concisely.

**Example (PHPUnit):**
<code php>
#[DataProvider('validInputs')]
public function testCalculate_valid($input, $expected)
{
    $this->assertSame($expected, $this->svc->calculate($input));
}

public static function validInputs(): array
{
    return [
        'simple'      => [[1,2,3], 6],
        'empty'       => [[], 0],
        'large'       => [range(1, 1000), 500500],
    ];
}
</code>

**Failure/exception path:**
<code php>
public function testCalculate_throwsOnNegative()
{
    $this->expectException(InvalidArgumentException::class);
    $this->expectExceptionMessage('negative not allowed');
    $this->svc->calculate([-1]);
}
</code>

==== 4) Verify interactions with test doubles ====
Mock collaborators to assert side effects and isolation.
<code php>
$repo = $this->createMock(UserRepository::class);
$repo->expects($this->once())->method('save')->with($this->isInstanceOf(User::class));
$svc = new UserService($repo);

$svc->register('alice@example.com');
</code>

==== 5) Enforce completeness with coverage (line + branch) ====
Run coverage locally (Xdebug or PCOV):

<code bash>
$ ./vendor/bin/phpunit --coverage-html build/coverage
</code>

In phpunit.xml enable branch coverage and include paths:
<code xml>
<phpunit colors="true">
  <coverage processUncoveredFiles="true">
    <include>
      <directory>app</directory>
      <directory>src</directory>
    </include>
    <report>
      <html outputDirectory="build/coverage"/>
    </report>
  </coverage>
</phpunit>
</code>

Targets: Line ≥ 90%, Branch ≥ 80% (adjust to your risk appetite).
Remember: Coverage shows what ran, not that logic is correct → see mutation testing.

==== 6) Mutation Testing (catches weak assertions) ====
Use a mutator (e.g., Infection) to ensure your tests fail when code is subtly changed.

<code bash>
$ composer require --dev infection/infection
$ vendor/bin/infection --min-msi=80 --min-covered-msi=80
</code>

If MSI drops, add/strengthen tests.

==== 7) Property-based tests for tricky logic ====
For algorithms/validators, generate many inputs (e.g., Eris library) to discover edge cases automatically.

==== 8) CI gates to keep quality steady ====
In CI:
  * Run unit tests with --fail-on-warning and --stop-on-failure for fast feedback.
  * Publish coverage artifact, fail build if below thresholds.
  * Run mutation tests nightly or on main branch.

==== 9) Ready-to-use checklist (copy/paste) ====

^ Item ^ Done? ^
| Contract documented (input/output/errors) | |
| Happy path covered | |
| Boundary cases covered (min/max/empty/zero/1-item/large) | |
| Invalid inputs raise correct exceptions (type/value/null) | |
| Preconditions/illegal state handled (guards) | |
| Side effects verified (mocks/stubs) | |
| Error messages/codes asserted (not only class) | |
| Branch coverage ≥ target | |
| Mutation score ≥ target | |
| Data provider used where multiple variants | |
| Negative tests present for every public method | |

==== 10) Small example tying it together ====

**Method contract (summary):**
  * parseIsoDate(string $s): DateTimeImmutable
  * Accepts YYYY-MM-DD
  * Throws InvalidArgumentException on invalid format or impossible dates

Tests (sketch):
<code php>
#[DataProvider('validDates')]
public function testParseIsoDate_valid($s, $y, $m, $d)
{
    $dt = $this->svc->parseIsoDate($s);
    $this->assertSame($y, (int)$dt->format('Y'));
    $this->assertSame($m, (int)$dt->format('m'));
    $this->assertSame($d, (int)$dt->format('d'));
}

public static function validDates(): array
{
    return [
        ['2025-01-01', 2025, 1, 1],     // boundary: year start
        ['2024-02-29', 2024, 2, 29],    // leap day
    ];
}

public function testParseIsoDate_invalidFormat()
{
    $this->expectException(InvalidArgumentException::class);
    $this->expectExceptionMessage('invalid ISO date');
    $this->svc->parseIsoDate('01/02/2025');
}

public function testParseIsoDate_impossibleDate()
{
    $this->expectException(InvalidArgumentException::class);
    $this->svc->parseIsoDate('2025-02-30');
}
</code>

==== TL;DR ====

  * Write a test matrix per method (happy, boundary, invalid, state, side effects).
  * Use data providers for breadth; expectations for error paths.
  * Enforce completeness with branch coverage + mutation testing.
  * Automate via CI gates so the bar stays high.

===== Troubleshooting =====

^ Problem ^ Likely Cause ^ Fix ^
| Tests not running | Autoload missing | Include vendor/autoload.php in config |
| No coverage output | Xdebug/PCOV disabled | Enable in php.ini or via PECL |
| Class not found | Namespace mismatch | Check PSR-4 configuration |
| Flaky tests | Shared state or I/O | Mock external resources |

===== Related Topics =====

  * [[home:php:test:pest:|Pest]] – Simpler, expressive syntax on top of PHPUnit
  * [[home:php:test:overview:|PHP Unit tests]] – General concepts and best practices
  * [[home:php:pkg:composer|Composer]] – Dependency management
  * [[home:php:automation:build-tools:|Build Automation]] – CI/CD pipelines
