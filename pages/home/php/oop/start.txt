**[[home:|Start]]** -> **[[home:php:|PHP]]** -> **PHP Object Oriented Programming**

====== PHP OOP ======

In procedural programming an application or a program is divided into a set of functions that operate on some sort of data that are stored in variables, so you basically have some sort of global state or variables and a bunch of functions that work with those variables. It could have functions calling other functions and so on.

In Object-Oriented Programming however you're basically combining or bundling related functions and variable into something called a class from which you create objects. You could access variable and call functions of the object if they if they are publicly available. We refer to the variables of the object or the class as properties and the functions as methods. A Class is a blueprint of an object and an object is something that you create or build from that blueprint. You could have many objects of the same class but each of those objects can be different in it's data. Objects are instances of the classes, the main advantage of object oriented programming is the ability to structure your code in a better way that is easier to maintain, test, extend, debug and so on. Through this does not mean that procedural programming is useless, there are some use cases for procedural programming, it might be a good pick for a small project that not require many features or much maintenance and you're the only one working on it. Not everything has to be object oriented but as your code grows and your project requirements increase you will find yourself in a trap where modifying extending and maintaining that code becomes difficult., especially when you're working in teams this is where object-oriented programming can help you, but do know that object-oriented programming does not mean your code will automatically be easier to maintain. Essentially it is up to you as a developer to ensure that you write your code in a way that is maintainable extendable readable and reusable. Object-oriented programming makes things easier for you to write such code. Also object-oriented programming is on demand meaning that you won't find many companies looking for programmers with experience in just procedural programming, most of them require object-oriented programming skills.

Thus object-oriented programming mean MVC? No and this is th misconception that I see a lot in object-oriented  programming. Object-oriented programming does not automatically imply MVC, object-oriented programming is a paradigm while MCV is an architecture pattern of Model-View-Controller which uses the object-oriented programming principles. Simply object-oriented programming does not imply MVC.

OOP is a fundamental programming paradigm that is based on the concept of "objects". Your code is structured to model real-world entities and their interactions within computer programs. Classes are created as "blueprints" for an object. Object-oriented programming has four main principles and these are encapsulation, abstraction, inheritance and polymorphism. 

**Core Concepts of OOP**
  * **Classes**: Blueprint or template to create and use an object
  * **Objects**: Self containing unit that encapsulates properties and methods
  * **Inheritance**: Allows one class to inherit properties/methods from another class
  * **Encapsulation**: Bundling the data and methods into a single unit
  * **Polymorphism**: Allows objects of different classes to be treated as objects of a common superclass

**Benefits of OOP**
  * **Modularity**: makes managing complex systems easier.
  * **Reusability**: code recycling in multiple projects, or reuse a single class in multiple objects in a single project.
  * **Scalability**: extend existing classes or functionality without disrupting existing code
  * **Abstraction**: allows to abstract complex systems by modelling them with simplified objects

  * Missing some [[home:php:basics:|PHP Basics]] ...
===== Classes & Objects =====

A class is like a blueprint and an object is something that you build from that blueprint or in other words an instance of that class. An object is an PHP data type with multiple variable (called properties) and fitting functions (called methods) to handle the data in such properties (variables). Check the [[https://www.php.net/manual/en/language.types.intro.php|PHP Language Reference on Types]]

PHP has a generic class implementation called std class that could use to create generic objects or you could cast your variables that are of another data types into objects. In addition to being able to create objects using generic std class you can also create your own custom classes. The definition of a class must begin with a class keyword followed by the class name which should begin either with a letter or an underscore followed by letters, numbers or underscores. Then we add curly braces to enclose the class definition. Note that you could follow different standards and conventions when it comes to naming your variables or classes or overall your code structure. The recommended way is to have a single class per file and nothing else in that file, with the file named after the class name, or the class name is named like the file containing the class code. You don't have to name your classes after your file but that is the recommended and widely used convention. You could also have more than one class definitions in a file which would work perfectly fine but again it is not the recommended way.

**controllers/User.php**
<code php>
<?php
class User {
  // Properties
  public $name; // = 'John Doe';
  public $email; // = 'john@gmail.com';
  
  // Methods
  public function login() {
    // ...
  }
}
</code>
Naming convention is to start classes with an uppercase letter. Public properties like $name can be accessed from out side the class, this is a no no use getter and setter methods (functions belonging to a class).

To create an object out of that class, what widely happens in a different file, like index.php. To create a variable pointing to the class followed by parenthesis, we have to use the new keyword followed by the class name followed by parentheses. The parentheses is not always required, depending on your constructor but it's always a good idea to stay consistent and just parentheses regardless.

**index.php**
<code php>
<?php
require_once '../controllers/User.php';

// Instantiate class as a new object
$user1 = new User();

// Set property values
$user1->name = 'John Doe';
$user1->email = 'john@gmail.com';
var_dump($user1);

// Run a method
$user1->login();
</code>
The class file has to be explicitly included or required in the file using the class, to be able to create the object.

===== Access Modifiers, Getters and Setters =====

Properties (inside class variables) should not be accessed directly. Therefore the **visibility** (or access modifier) should not be public as in the example above. Sometimes not all methods (inside class functions) should be  accessible from outside the class. To define the visibility of the property to either
  * **public**: The property or method can be accessed from anywhere inside or outside of the class. This allows interaction objects outside of the class. This is the default if no modifier is given. 
  * **protected**: The property or method can be accessed from within the class OR any class that inherits from it
  * **private**: The property or method can only be accessed from within the class
and these are also **called access modifiers** and they should be added to both properties and methods so we start with the access modifier followed by the variable name. 

Accessing properties should happen with methods, one for stetting a value (so called setter method) and on for property value reading (so called getter method). One big advantage of setters is you could check if the value to be set is within legal values of your application or getters could return a default value if non set up to now. You also could check user access rights, as is it allowed for this user to change or read the value. 

To assign this values to the properties or to access the properties inside the object or class within the class itself we need to use a **variable called $this**. The **$this variable refers to the calling object** or in other words it refers to to the instance from which the method was called from. Due to properties not being accessible from outside the class we need methods to access the values assigned to properties. This methods are called **getters to retrieve the value** assigned to an property and **setters to assign a new value** to an property. 

Only the class the property belonging to should be allowed to explicity change the values of properties. Explicitly changeing from outside the class should anything other than the class should be done through methods of the class like getters and setters or transcation methods.

**controllers/User.php**
<code php>
<?php
class User {
  // Properties
  private $name;
  private $email;
  private $status = 'active';
  
  // Getter and Setter
  public function getName() {
    return $this->name;
  }
   public function setName($chicken) {
    $this->status = $chicken;
  }
    
  public function getEmail() {
    return $this->email;
  }
   public function setEmail($email) {
    $this->status = $email;
  }
    
  public function getStatus() {
    return $this->status;
  }
   public function setStatus($status) {
    $this->status = $status;
  }
    
  // Methods
  public function login() {
    // ...
  }
}
</code>
The values of this properties will be set to null if you don't assign them the value, so null will be the default for them. There is one exception to this when using type hinting. 

Accessing public properties of methods everyone interacting with the object even outside of the class we have to do is use **object operator** which is -> followed by the method or property to be accessed. Is the method or property is not accessible due to access modifier you'll get an Uncaught Error: Cannot access private property.  
<code php>
<?php
$user2 = new User('Jane Doe', 'jane@gmail.com');
$user2->setSatus('inactive');
echo $user2->getName() . ' is ' . $user2->getSatus();
</code>
PHP 7.4 introduced typed properties, which means that you could set the type of the property in the definition. Type hinting is recommended but not required, it is up to you if you want to use it or not. **Recommendation is type hinting and strict type usage**. Note PHP is not able to determine whether a property that has a type was actually set or you simply forgot to set a value, that's why accessing a object without initialisation will lead to a Uncaugth Error: ... must not be accessed before initialisation. This is why the new state was introduced called uninitialized when type is defined and value is not assigned to a property it is in uninitialized state. If not using strict type, uninitialized properties will have the value NULL. To solve the issue of accessing properties before initialization is to actually assign some kind of value as default value either directly at the definition or in something called constructor or a so called setter. Something to note is that you're only able to assign constant values as the default values you cannot have complex expressions here like function calls and so on. If you need to the nullable property you would add the question mark in front of the type definition and you would set the default value to NULL, in that case it would work, but this kind of assignment doesn't really make sense.

Setting values can alternatively be defined within something called constructor. A method to be called when creating an object out of the class with the new keyword.

==== Magic Getters and Setters ====

<code php>
<?php
__get
__set
</code>
===== Constructors =====

Due to have properties not publicly available with the private access modifier, which could cause some unnecessary bugs where properties are changed from outside the Class we need different ways to access the properties. The constructor is a method to be called when creating an object out of the class with the new keyword. The constructor can be used to initialize class properties. The constructor  method is a special function, also known as a magic function that will be called whenever a new instance of the class is created is named **construct() with double underscore at the beginning**. The constructor has no arguments by default but it accepts arguments, so you could add values to it to initialize the object with it to assign these values to the properties. 
<code php>
<?php
class User {
  // Properties
  private $name;
  private$email;

  
  //Constructors 
  public function __construct() {
    echo 'User Constructor ran ... <br />'; 
    // ...
  }

  public function __construct($name, $email) { // Polymorphism
    echo 'User Constructor ran ... <br />'; 
    $this->name = $name;
    $this->email = $email;
  }
  
  // Methods
  public function login() {
    // ...
  }
}
</code>
If the constructor needs to get arguments and you call it without, you'll get an Uncaught ArgumentCountError. The construct method does accept the three dot variadic parameter, allowing you to pass any number of arguments when creating an object, but you should consider associative array then.
<code php>
<?php
// Instantiate class as a new object
$user1 = new User('jane Doe', 'jane@gmail.com');
$user1->login();
</code>


===== Method chaining ===== 

Lets assume we need multiple methods, of our object changing property values, that we have to call before getting the result we need. Instead calling one method after they other, or one by one you can chain methods by returning the current object from those methods so instead of returning nothing we could return 
the $this variable which refers to the calling object which is an instance of the class. So we can use the class name as return type in method declaration, there is another way to specify this by using the self keyword. 
<code php>
<?php
declare(strict_types=1);
class Transaction {
  private float $amount;
  private string $description;
  
  public function __construct(float $amount, string $description) {
    $this->amount = $amount;
    $this->description = $description;
  }
  
  public function addTax(float $rate): self {
    $this->amount += $this->amount * $rate /100;
    return $this;
  }
  
  public function applyDiscount(float $rate): self {
    $this->amount -= $this->amount * $rate /100;
    return $this;
  }
  
  public function getAmount(): float {
     return $this->amount;
  }
  
  public function setAmount(float $amount): float {
     $this->amount = $amount;
  }  
}
</code>
Instead of calling each method one by one, we can chain them. 
<code php>
<?php
declare(strict_types=1);
require_once '../Transaction.php';

$transaction = new Transaction(100, 'Initial Debit');
// $transaction->applyDiscount(10);
// $transaction->addTax(19);
$transaction->applyDiscount(10)->addTax(19);

echo 'Transaction Payload: ' . $transaction->getAmount();
</code>
Here everything still works but now we are able to do something like this where methods are changed as shown above. We could even change this to do something like the following. Put the new command in parenthesis and remove all class calls, this will still work. For better readability we could add a line break before each arrow, if we have many arrow calls, so we would have the methods on separate lines and this would still work. 
<code php>
<?php
declare(strict_types=1);
require_once '../Transaction.php';

$transaction = (new Transaction(100, 'Initial Debit'))
   ->applyDiscount(10)
   ->addTax(19);

echo 'Transaction Payload: ' . $transaction->getAmount();
</code>
Even better we can set $transaction to $amount if we don't care to have the reference to that object renamed. 
<code php>
<?php
declare(strict_types=1);
require_once '../Transaction.php';

$amount = (new Transaction(100, 'Initial Debit'))
   ->applyDiscount(10)
   ->addTax(19)
   ->getAmount();

echo 'Transaction Payload: ' . $amount;
</code>
As you can see chaining methods creates this more readable way of building your objects and shorter code. Chaining methods will not always make sense, chaining methods would not make sense if we had to return some type of value not the current instance. Also try not to force yourself creating chained method structures in all of your classes. It only makes sense for certain classes where you want to build up the object  before getting the final value.

===== Variables as Class name ===== 

Another way you could create objects is by using variables instead of class name. Everything works the same as with hard coded class names.
<code php>
<?php
declare(strict_types=1);
require_once '../Transaction.php';
$class = 'transaction';

$amount = (new $class(100, 'Initial Debit'))
   ->applyDiscount(10)
   ->addTax(19)
   ->getAmount();

echo 'Transaction Payload: ' . $amount;
</code>
Dynamic class names are used when the class can or should change at runtime, as different database classes (MySQL, Postgres, SQLite). 

===== Destructors ===== 

The destructor message is the opposite of the constructor, it's also a magic message and therefore it starts with **two underscores** before the keyword **destruct**. The destruct method is called whenever there is no more reference available to the object or when the object is destroyed. The destructor can be used to perform some sort of cleanup or release locks or close open resources or database connections and so on. You do not need to define destructors a lot only when you really need to and have the actual use case for it. It is recommended that if you have a resource or a database connection open to close it as soon as you're done working with them and as soon as you no longer need them. Just in case you have a long run in script and you don't close the connection as soon as you're done using it it's going to keep that connection open until the script finishes running so unless you have a good use case for destructors. Try to stay away from them and close your connection as soon as you're done using them. 

**Transaction.php**
<code php>
<?php
   public function __destruct() {
     echo 'Destruct Transaction' . $this->description . '<br />';
   }
}   
</code>

The destructor will show up each time the object is removed from the memory, basically it's destroyed 
<code php>
<?php
declare(strict_types=1);
$amount = (new Transaction(100, 'Initial Debit'))
  ->applyDiscount(10)
  ->addTax(8)
  ->getAmount();

echo $amount;
</code>
The Destruct Transaction message will be displayed before the amount value. This means the destruct method will be called first, this means there is no reference available to this transaction aside from here and therefore it's calling the destruct and it's printing destruct transaction and then we're printing the amount. 
<code php>
<?php
declare(strict_types=1);
$transaction = (new Transaction(100, 'Initial Debit'))
  ->applyDiscount(10)
  ->addTax(8);

echo $transaction->getAmount();
</code>
This code would first show the amount value and afterwards the Destruct Transaction message, because we still have the reference available to the transaction object in the echo statement to print the amount first and then call the destruct method.

<code php>
<?php
declare(strict_types=1);
$transaction = (new Transaction(100, 'Initial Debit'))
  ->applyDiscount(10)
  ->addTax(8);
$amount = $transaction->getAmount();
echo $amount;
</code>
In this case the reference is still available until the end of the script. When the script ends that's when the destructor is called and that is why it first prints the amount and then it calls the destruct.

<code php>
<?php
$transaction = (new Transaction(100, 'Initial Debit'))
  ->applyDiscount(10)
  ->addTax(8);
$amount = $transaction->getAmount();

unset($transaction); // $transaction=NULL; 
echo $amount;
</code>
In this code the Object is destroyed before the scripts ends, so the Destroy Transaction message will show up before the amount value is displayed. 

A couple of   things to know about destructors if you use exit statement to terminate your script you will still call the destructor. If you put an exit statement in the destruct method, whenever this specific destruct method runs no other destruct methods on other classes, which can cause some issues if you're performing some actions and relying on those methods to run that are within the destructors of other classes.

===== PHP std class ===== 

The std class can be used to create generic objects and also some functions return instances of std class and the keys of the array or the keys for the json, in the following code, will become the properties of the class and the values will become the values of those properties. so now you're able to use those properties using the object operator (->).
<code php>
<?php
$str = {"a":1,"b":2,"c":3};
$arr = json_decode($str, true); // convert to associated array
$obj = json_decode($str);  // convert to an object as an instance of std class 

var_dump($obj->a);
</code>
We can create custom objects by using the std class itself and then set the properties the way you would set a public property on your own custom class, using the object operator, so you would do objects property a equals something. 
<code php>
<?php
$obj = new \stdClass();
$obj->a = 'Hello';
$obj->b = 'World';
</code>

**Type casting** from or to stdClass, works pretty similar as type casting works. 
<code php>
<?php
$arr = [1, 2, 3];
$obj = (object) $array;  // convert array to object with keys as properties 
var_dump($obj->{0}); // = 1
</code>
The numerically indexed array is casted to an object with properties which is 0, 1 and 2. Remember to surround the properties with curly brackets.

Converting Scalar into objects (Integer, Float, Strings, Boolean)
<code php>
<?php
$obj = (object) 1;  // convert integer to object
var_dump($obj->scalar); // = 1
</code>
<code php>
<?php
$obj = (object) false;  // convert bool to object
var_dump($obj->scalar); // = 0
</code>
Null is casted into an empty object without any properties.

===== Constructor Property Promotion =====
[[https://wiki.php.net/rfc/constructor_promotion|Constructor Property promotion]] is a feature that was edit in PHP 8.0, it allows you to get ride of the boilerplate code where you define properties and then assignee them to the arguments that are passed in your constructor. Basically it lets you combine class properties constructor and assignment into one shorter syntax. The following code is perfectly fine.
<code php>
<?php
declare(strict_types = 1);
class Transaction {
  private float  $amount;
  private string $description;
  
  public function __construct(
    private float  $amount,
    private string $description
  ) {
    $this->amount      = $amount;
    $this->description = $description;
  }
}
</code>
But now there is an shorthand version of this. Basically of this now you are able to add a visibility or access modifier directly in your constructor. PHP will interpreted both in the constructor the property and the constructor argument and it will assigned the value that is passed to the constructor to that property behind the scenes to basic it still does the definition and the property reassignment for you. You don't have to do that. 
<code php>
<?php
declare(strict_types = 1);
class Transaction {
  public function __construct(
    float  $amount,
    string $description
  ) {
  }
}
</code>
This code will do the same, in PHP 8.0, as the code before. So as you see Constructor Property Promotion feature offers a shorthand version with much cleaner syntax and less boilerplate code. While PHP behind the scenes does the same as before.

There are a few things you need to be aware of. First thing you can **type hint any type except callable**, that's because can not type hint properties with callable type, PHP dose not allow that. As argument you can use callable as type hint without access modifier, because then you are not allowed to use it with an access modifier. 

You are allowed to use promoted properties with class properties. So you don' have to promote all the properties. 
<code php>
<?php
declare(strict_types = 1);
class Transaction {
  privat float $amount;
  
  public function __construct(
    float  $amount,
    string $description
  ) {
    $this->amount = $amount;
  }
}
</code>
Another thing you need to be aware of you **can not have duplicates** meaning you can not have **a property and promotes property** at the same time with the same name. You don't have to type hint properties you can also promote untyped properties. 

Next thing you should know is you could assign default value to promoted properties, but have to **follow the same rules** you can only have a simple expression or constant values as default, we can not use function calls or complex expressions. 
<code php>
<?php
declare(strict_types = 1);
class Transaction {
  privat float $amount = 100.50;
  
  public function __construct(
    float  $amount,
    private string $description = 'Hello'
  ) {
  }
}
</code>
If you are assigning a default of **NULL** you will need to make that **property nullable typed**  
<code php>
<?php
declare(strict_types = 1);
class Transaction {
  privat float $amount = 100.50;
  
  public function __construct(
    float  $amount,
    private ?string $description = null // ? makes it nullable
  ) {
  }
}
</code>
**Accessing promoted properties** is by using the $this variable. Another way is to access the **promoted property simply without $this**. 
<code php>
<?php
declare(strict_types = 1);
class Transaction {
  public function __construct(
    float  $amount,
    private string $description
  ) {
    echo amount;
  }
}
</code>
===== Nullsafe operator =====

The Nullsafe operator allows to chain methods even if they return null. The nullsafe operator is a question mark ?-> used after the method name, which could return null, in the chain and before the object operator. Without the Nullsafe operator we need to nest a lot of null checks as you see in the following code, otherwise in case of property or method access returning null, we would get a Warning Attempt to read property ... on null.
<code php>
<?php
require_once '../PaymentProfile.php';
require_once '../Customer.php';
require_once '../Transaction.php';
$transaction = new Transaction(5, 'Test');
$profileId = null;
if ($customer = $transaction->getCustomer()) {
  if ($paymentProfile = $customer->getPaymentProfile()) {
    $profileId = $paymentProfile->id;
  }
}
echo $profileId ;
</code>
How does the nullsafe operator work? The nullsafe operator basically solves this problem be short circuiting the property or method access and will return null immediately as soon as it is null without accounting the rest of the expression. In the following code, if customer is null the rest of the code in this line would be discarded. 
<code php>
<?php
require_once '../PaymentProfile.php';
require_once '../Customer.php';
require_once '../Transaction.php';
$transaction = new Transaction(5, 'Test');
echo $transaction->customer?->paymentProfile?->id;
</code>
You can chain the nullsafe operator but this isn't very helpful in most cases. It is helpful working with the Null coalescing operator. There are a few things to know and be aware of when working with nullsafe operator, first of all it's read-only, meaning you can not write or assign a value to it, so the following code will not work.
<code php>
<?php
$transaction->customer?->paymentProfile?->id = 42;
</code>
Also be careful not to pass important function calls, that needs to be executed even when null are present in the chain, be aware of short circuiting important function being not executed. Check [[https://wiki.php.net/rfc/nullsafe_operator|PHP RFC: Nullsafe operator]] 


The Null coalescing operator ?? will return an alternative value if something fails on an object being null.
<code php>
<?php
require_once '../PaymentProfile.php';
require_once '../Customer.php';
require_once '../Transaction.php';
$transaction = new Transaction(5, 'Test');
echo $transaction->getCustomer()?->getPaymentProfile()?->id ?? 'foo';
</code>
===== Namespaces =====
When you define a function a constant or a class without a namespace definition by default they will be put in a global space. In this example here transaction class has no namespace definition may cause name collision where you might have multiple classes that have the same name. PHP will not know which one to instantiate because two classes with the same name. When requiring two classes with the same name and that are not namespaced meaning that they're in a global space this will cause an **Fatal Error Cannot declare class ..., because the name is already in use**. <code php>
<?php
declare(strict_types = 1);
require_once '../PaymentGateway/Stripe/Transaction.php';
require_once '../PaymentGateway/Paddle/Transaction.php';
var_dump(new Transaction()); // which Transaction class to be use?
</code>
Before namespaces where introduced often this was solved by prefixing the class name with the vendor name or the namespace name within the class. In addition to the name collision fixes it also lets you better structure and organize your classes and code same thing would happen with the constants, interfaces, traits or functions. Think of namespaces as virtual directory structures for your classes. We can define namespaces using the namespace keyword on top of the file before any code and after declare(strict_types = 1); statement. 
<code php>
<?php
declare(strict_types = 1);
namespace core;
</code>
You could name the namespace what ever you want as an example you could take your name, a package name or whatever.
Defining a name space in a script will define this for all classes, constants, interfaces, functions and traits after this point in the PHP script, to avoid conflicts in naming with other PHP files. If you require a class with namespace the location of the file will not change, so the require statement is the same but calling the class will change, otherwise PHP will throw an Uncaught Error: Class not found, because PHP is looking for the class by default in global space. There are two ways to fix this issue, one is we need to **add qualifying class name including the namespace** in here so we would do something like Stripe\Transaction.php or Paddle\Transaction.php. Another way is to import the class from the namespace by using the **use** keyword as shown in the second following example.
Instead of single namespace you could have sub namespaces which makes more sense and you can make your namespaces follow the directory structure this could lead to a code as follows.
<code php>
<?php
declare(strict_types = 1);
require_once '../PaymentGateway/Stripe/Transaction.php';
require_once '../PaymentGateway/Paddle/Transaction.php';

var_dump(new PaymentGateway\Stripe\Transaction()); 
</code>
So everything is working, just something to note here the namespaces match the folder structure this is why you can think of namespaces as virtual directory structure, this is not a requirement, you can put the file anywhere you want and still namespace it anyway you want but it is recommended and also a standard to match namespace with the folder structure.

Importing the class namespace by using the **use** keyword followed by the namespace and class name.
<code php>
<?php
declare(strict_types = 1);
require_once '../PaymentGateway/Stripe/Transaction.php';
require_once '../PaymentGateway/Paddle/Transaction.php';

use PaymentGateway\Stripe\Transaction;
var_dump(new Transaction()); 
</code>
**PaymentGateway/Stripe/Transaction.php**
<code php>
<?php
declare(strict_types = 1);
namespace PaymentGateway\Stripe;

class Transaction
{

}
</code>
**PaymentGateway/Paddle/Transaction.php**
<code php>
<?php
declare(strict_types = 1);
namespace PaymentGateway\Paddle;

class Transaction
{

}
</code>
In addition in name spacing and importing classes you can name space constants and functions and import them as well, this is not widely used and shouldn't be used but you could name space your custom functions and constants and then import them using use and then function and specify the function name after your namespace or you could do the same thing for constants using use const. 

Instantiating classes that are within the same namespaces, there you don't need to use the namespace you can use only the class name, because PHP will try to load classes from the current namespace if you are in a name spaced file.

If you were to access PHP's build-in classes you will need to add a backslash to tell PHP to load it from the global space or you will need to import them. 
<code php>
<?php
declare(strict_types = 1);
namespace PaymentGateway\Paddle;
use DateTime;

class Transaction
{
  public function __construct()
  {
    var_dump(new DateTime());
  }
}
</code>
If you need a **class from another namespace** e.g. Notification\Email PHP would prepend this as a sub name space from the current name space, so it try's to locate the email class under PaymentGateway\Paddle\Notification\Email. To prevent this we, need to use a **full qualified namespace name** and the difference between the qualified and full qualified name is that **full qualified name is prefixed by backslash**, which indicates that this is the full namespace to that class. When you use that qualified name instead of the full qualified name, then what PHP will do this it will try to see if there is an import statement, that resolves to notification namespace and if it does then this would work otherwise it will prepend the namespace as a sub namespace. This will lead to an Uncaught Error Class not found. There are two ways we could fix this one is we could prepend it with the backslash to make it full qualified name in the new statement or we could simply import with use it and then it would work
<code php>
<?php
declare(strict_types = 1);
namespace PaymentGateway\Paddle;

class Transaction
{
  public function __construct()
  {
    var_dump(new \Notification\Email());
  }
}
</code>
The build-in functions will be resolved from the global space, this is because PHP will locate the in global space, but not with classes PHP will try to locate them in the local name space and if it doesn't exist it will throw an error unless you had the use statement where you imported that class. If a function does not exist in the local namespace then it falls back to the global namespace.
<code php>
<?php
declare(strict_types = 1);
namespace PaymentGateway\Paddle;

class Transaction
{
  public function __construct()
  {
    var_dump(explode((',', 'hello,world'));
  }
}

function explode($seperator, $arg)
{
  return 'foo';
}
</code>
This code will return the foo string, without the own explode function we would call the build-in explode function from the global namespace. Sometimes this can be intended but sometimes can cause unexpected bugs so you should want to prefix build-in functions with backslash to ensure that you're using PHP's build-in function from the global space instead of the locally defined function in that namespace. This is why you see some developers use backslash when using PHP's build-in functions in namespace classes. Another reason why they would prefix PHP's build-in functions with backslash is the possible speed improvement because you're telling PHP exactly where to load that function from and PHP does not have to resolve it which could have positive impact on performance but very negligible.

Using multiple classes with the same name can still be a problem, as in the following code example
<code php>
<?php
declare(strict_types = 1);
require_once '../PaymentGateway/Stripe/Transaction.php';
require_once '../PaymentGateway/Paddle/Transaction.php'; 

use PaymentGateway\Stripe\Transaction;
use PaymentGateway\Paddle\Transaction as PaddleTransaction;  // or name already in use error

$stripeTransaction = new Transaction();
$paddleTransaction = new PaddleTransaction(); // again which is which
var_dump($stripeTransaction, $paddleTransaction); 
</code>
Name spacing is not helping in this style of code, you could use full qualified naming in the new statement and skip the use statements or by aliasing on of the classes. You're able to do that in PHP so in here we can us **as keyword to define an alias** like PaddleTransaction.

Aliasing can also be used to deal with long class names, another use case for aliasing would be that if we were inside the PaymentGateway\paddle\Transaction class and you are using some kind of package or library that also has the transaction class in there and you want to use that transaction class or extend from in your transaction class then you would need to do something like use vendor name transaction and this would not work because the current class name is transaction and you're trying to import another class with the same name, aliasing would work as well, give it a nickname, you could name it want you want but usually the name of the package or the author of the library. 
<code php>
<?php
declare(strict_types = 1);
namespace PaymentGateway\Paddle;
require_once './PayPal/Transaction.php';
use PayPal\Transaction as VendorTransaction;  // without alias already in use error

class Transaction
{
  public function __construct()
  {
  }
}
</code>
If your importing multiple classes from the same namespace you could actually group them together by combining class names in curly braces in a single use statement. 
<code php>
<?php
declare(strict_types = 1);
require_once '../PaymentGateway/Paddle/Transaction.php'; 
require_once '../PaymentGateway/Paddle/CustomerProfile.php'; 
use PaymentGateway\Paddle\{Transaction,CustomerProfile}; // grouped instead of two use statements

$paddleTransaction = new Transaction(); 
$paddleCustomerProfile = new CustomerProfile();
var_dump($paddleTransaction, $paddleCustomerProfile); 
</code>
Another way you could do this instead of grouping them into a single line you could simply import the namespace itself. Therefore you import the qualified namespace without a class name and instantiate the class with the last part of the namespace if you have sub name spaces.
<code php>
<?php
declare(strict_types = 1);
require_once '../PaymentGateway/Paddle/Transaction.php'; 
require_once '../PaymentGateway/Paddle/CustomerProfile.php'; 
use PaymentGateway\Paddle; // importing name space

$paddleTransaction = new Paddle\Transaction(); 
$paddleCustomerProfile = new Paddle\CustomerProfile();
var_dump($paddleTransaction, $paddleCustomerProfile); 
</code>
This will work as well. In some cases this is the preferred way where you're importing a lot of classes from the same namespaces instead of listing all of them with its own use statement or a long list of combined class names. So you can import the namespace and prefix your classes with that namespace. Recommendation is import everything in the use statements because that way you will see what are all the classes that this specific class or file depends on when you open a class file.

Another thing to note about the aliasing is that it could actually alias the entire namespace as well.
<code php>
<?php
declare(strict_types = 1);
require_once '../PaymentGateway/Paddle/Transaction.php'; 
require_once '../PaymentGateway/Paddle/CustomerProfile.php'; 
use PaymentGateway\Paddle as PA; // importing name space with alias

$paddleTransaction = new PA\Transaction(); 
$paddleCustomerProfile = new PA\CustomerProfile();
var_dump($paddleTransaction, $paddleCustomerProfile); 
</code>
Something you need to know that importing rules are profile based, what that means is that if we include another file later in the script the included file will not inherit the classes that were imported in the parent file so if you want to use these classes in the included file you would need them there as well.

What still needs to be discussed is using multiple name spaces in the same file, but this us nor widely used. 
**Resources**
  * [[https://www.php.net/manual/en/language.namespaces.php|Namespaces - Table of Contents]]
  * [[https://www.php.net/manual/en/language.namespaces.rules.php|Namespaces - Name resolution rules]]
  * [[https://www.php.net/manual/en/language.namespaces.faq.php#language.namespaces.faq.full|How does a name like \my\name or \name resolve?]]
  * [[https://www.php.net/manual/en/language.namespaces.faq.php#language.namespaces.faq.shortname2|How does an unqualified function name or unqualified constant name like name resolve]]
  * [[https://www.php.net/manual/en/language.namespaces.definitionmultiple.php|Defining multiple namespaces in the same file]]







===== Coding standard =====

PHP is very forgiving when it comes to code layout or structure. You can put spaces, tabs or new line into your code, which makes code difficult to read for humans but it will still work fine, just through you  probably would not do that even if you didn't follow any conventions or standards because it would make it harder for you to maintain it so why would you follow any conventions or standards well let's say you work in a team or that you work on an open source project you preferer to structure and write it based on your own style while other developers like to follow their own style and taste like curly braces in a new line or not or camel case vs snake case and so on this will lead to a lot of inconsistencies which makes code harder to read and maintain. Take open source libraries or frameworks as an example an open source project can have hundreds of developers contributing to them if everyone followed their own conventions the code base would be a big pile of inconsistent spaghetti. This is why we have **[[https://php-fig.org/|PSR]]** which stands for **PHP Standard Recommendation** is maintained by PHP framework interoperability group or short **[[https://php-fig.org|php-fig]]**. This group was formed by several PHP framework founders and developers and since then a lot more members has joined the group. 

[[https://php-fig.org/psr|PSR standard table]] with the currently accepted standards sorted by PSR Standard number
  * **[[https://php-fig.org/psr/psr-1|PSR-1 Basic Coding Standard]]** for example files must only use <?php or <?= or first letter in class name should be capitalized, constants must be declared in all upper case and underscore as separators, methods should be camelCase 
  * **[[https://php-fig.org/psr/psr-4|PSR-4 Autoloading]]** Notice [[https://www.php.net/manual/en/language.oop5.autoload.php|Autoloading Classes]] should not throw exceptions or return a value 
  * **[[https://php-fig.org/psr/psr-12|PSR-12 Extended Coding Style]]** replaces [[https://php-fig.org/psr/psr-2|PSR-2 (Coding Style Guide)]] and adds more standards to it and it also requires you to follow [[https://php-fig.org/psr/psr-1|PSR-1]].
It's not an requirement to follow these standards but it's just a good habit that lets you write consistent code. Many PHP IDE's like [[https://www.jetbrains.com/phpstorm/|PHPStorm]] have plugins supporting coding styles like Laravel or Joomla Guide and there you could press CTRL-L and code will be formatted in PSR-12 formatting or what ever you have selected. You can set soft limits of the lines and so on. If you're not using [[https://www.jetbrains.com/phpstorm/|PHPStorm]] simply google PHP code sniffer or PSR plugin for your code editor  

See also [[https://github.com/php-fig/fig-standards/blob/master/README.md|psr@github]] and remember by following PSR standards there can be also framework specific conventions and standards. The key thing here is the consistency. 

===== Autoloader =====

As you can imagine requiring and including files can get very ugly, very fast the more classes you have the more require statements you would need. Autoloading solves this problem PHP has a function called **spl_autoload_register()** and it accepts a few arguments and the first one is that we care about which is a call-back function which is our custom auto loading function and this function receives the fully qualified class name as the argument

If a class is already loaded with require PHP will skip classes that are already loaded and therefor it doesn't need to run our autoloader so what autoloading does is that it automatically loads your classes, interfaces and trails that are not already included or in other words are undefined (Uncaught Error: Class not found). So what's happening is that when we try to use or access a class PHP will check if that class exists, if it does not exist before throwing any errors it looks for any registered autoloader functions and runs them one by one when you register auto loaders they go into queue and are executed one by one whenever class is not found we can see this in action.
==== Simple Autoloader ====

When PHP encounters a class or interface that has not yet been defined, it triggers the autoload mechanism. Functions registered with spl_autoload_register() are then called in sequence. Each of these functions receives the missing class name as an argument, and it is their responsibility to locate and load the corresponding file (for example by including it). Once the file is loaded and the class is defined, PHP continues execution as if the class had been available from the start. The goal is to **simplify require basePath('...');**, all class files needed do not have to be loaded individually by require.

**index.php**
<code php>
<?php
require '../helpers.php';

spl_autoload_register(function($class) {
   $path = basePath('core/' . $class . 'php';
   if (file_exists($path)) {
     require $path;
   }
});

//Initiate the router
$router = new Router();
</code>
You could, if needed, add multiple autoloader functions, these will run one by one. The first registered function will run first and the next registered function runs afterwards. 
<code php>
<?php
spl_autoload_register(function($class) {
   echo Autoloader 1;
});
spl_autoload_register(function($class) {
   echo Autoloader 2;
});
// ...
</code>
You can pass the third argument as true to prepend autoloader in the queue instead of appending it to the end, so we could simply use a named argument and the **third argument is the prepend argument**
<code php>
<?php
spl_autoload_register(function($class) {
   echo Autoloader 1;
});
spl_autoload_register(function($class) {
   echo Autoloader 2;
}, prepend: true);
// ...
</code>
Now second autoloader runs first.


So what has to be done by a self customized autoloader to require classes?
  * transfer name space into file pass
  * deal with uppercase and lowercase differences in namespace and file path
  * handle proper pathing ../ or magic DIR or add a path prefix like '../core/'
<code php>
<?php
require '../helpers.php';

spl_autoload_register(function($class) {
   $path = __DIR__ . '/../' . lcfirst(str_replace('\\', '/',  $class)) . 'php';
   if (file_exists($path)) {
     require $path;
   } else 
     // %
   }
});

//Initiate the router
$router = new Router();
</code>
Check the [[https://www.php-fig.org/psr/psr-4/|PSR-4: Autoloader]] [[https://www.php-fig.org/psr/psr-4/examples/|Example Implementations]]

==== Vendor Autoloader ====

The [[https://www.php-fig.org/psr/psr-4/|PSR-4: Vendor Autoloader]] is working as a package installed with the **[[home:php:pkg:composer:|Composer]]** package manager for php, like npm in Node.js, with a composer.json file as application manifest. The composer can also specify an PSR-4 autoloader. The autoloader knows how to autoload classes from vendor directory but it does not know how to load our on classes from the app or framework directory. We can fix this by simply telling composer how to autoload our own classes in the composer.json file and add an option to autoload. In the autoload/psr-4 section we map out namespace to the location of that namespace as you see with App and Framework, after editing composer.json composers autoload files need to be regenerated (check files in vendor/composer/autoload*php) especially vendor/composer/autoload_psr4.php that contains the namespaces for our dependencies but it does not contain our own namespaces without regeneration. 
<code json>
{
   "name" : "robingoerlach/workopia-php",
   "description": "Job Portal",
   "authors": [ 
      {
        "name": "Robin Goerlach",
        "email": "support@sasd.de"
      }
    ],
    "require": {
        "ramsey/uuid": "^4.1"
    }
    "autoload": {
       "psr-4": {
          "App\\": "app/",
          "Framework\\": "core/"
     }  
}
</code>
**composer.json**

  * **name**: Github Repo name
  * **psr-4**: needs namespaces used in the project

<code bash>
#composer install
composer dump-autoload
</code>

<code php>
<?php
require __DIR__ . '/../vendor/autoload.php';
require '../helpers.php';
</code>
This code does the job. The autoloader from [[home:php:pkg:composer:|Composer]] searches also in subfolders of namespace corresponding folder. Now we could start

**index.php**
<code php>
<?php
require __DIR__ . '/../vendor/autoload.php';
require '../helpers.php';

$router = new core\Router(); // crappy way because this has to be the full qualified namespace
</code>
To write clean code we should add use statements for better readable and maintainable code
**index.php**
<code php>
<?php
require __DIR__ . '/../vendor/autoload.php';
require '../helpers.php';

use core\Router;
// use PDO;  // if needed

$router = new Router(); // this together with use makes things easier to read
</code>
What we should consider is classmap (**vendor/composer/autoload_classmap.php**) currently we are using [[https://www.php-fig.org/psr/psr-4/|PSR-4]] to handle dynamic autoloading for us, whenerver we add a new class under App or Core namespace we don't need to regenerate the autoload file. It will just work because it will just be dynamically loaded for you using psr4 rules and this is the prefered way during development but in production you want things to be as fast as possible, so in the composer directory we see the autoload class map generated file. While [[https://www.php-fig.org/psr/psr-4/|PSR-4]] is already fast using class maps is even faster because dynamic autoloading needs to check file system before resolving a class name with classmade bottle loading will load the classes from the generated array and this is why it's called the class map it maps the classes to their locations in our class map (vendor/composer/autoload_classmap.php) though we only have a single element so we don't really have anything mapped yet other than this we can pass an argument to the composer dump autoload to load this array with the classes. So we can do composer dump-autoload -o as argument, this should generate optimized autoloading 
<code bash>
composer dump-autoload -o
</code>
This should retune something like //Generated optimized autoload files containing 154 classes//. If you check **vendor/composer/autoload_classmap.php** now it should populate an array with all the classes that our application needs. If you add new classes then you have to run composer dump-autoload with the optimize option again to add those classes in this array, which is not that ideal for development, you don't want to be running this command every time so that's why using composer dump-autoload for development is just fine but for production you might want to use the composer dump-autoload with the optimize option so that it's a bit faster. Note that if the class is not found in this array then composer will fall back to the psr4 auto loading to load your class. Note that you should not commit vendor directory in your version control system like git for example, instead you should add this to your git ignore file.
===== PHP Class Constants =====

As in the Basics we defined constants before, you could also define constants per class. Constants are immutable meaning that you cannot change the value once it's defined. **Constants can be defined similar to properties**, there agine we follow standard to keep constant names uppercase and use underscores as the separator 
<code php>
<?php
declare(strict_types = 1);
namespace App\PaymentGateway\Paddle;

class Transaction
{
    public const STATUS_DECLINED = 'decliened';
    public const STATUS_PAID     = 'paid';
    public const STATUS_PENDING  = 'pending';
    
    public function __construct()
    {
      
    }
}
</code>
You could also assign access modifiers or visibility to the class constant if you don't by default they will be set to public but it's recommended to always define the visibility even if it's public. In procedural world non-class constants were in global space we could access them by simply referring or using the constant name but to access the class constants we need to **access them using the class name followed by double columns which is called the scope resolution operator and then the constant name**
<code php>
<?php
declare(strict_types = 1);
use App\PaymentGateway\Paddle;
require_once __DIR__ . '/../vendor/autoload.php';

echo Transaction::STATUS_PAID; /* :: Scope resolution operator */
</code>
**Class constants are allocated once per class** and not per instance of the class which means that we **don't need to have the instance of the class to access the class constants** now. In addition to accessing constants on the class level you could actually access them on the object level as well.
<code php>
<?php
declare(strict_types = 1);
use App\PaymentGateway\Paddle;
require_once __DIR__ . '/../vendor/autoload.php';

$transaction = new Transaction();
echo $transaction::STATUS_PAID; /* :: Scope resolution operator */
</code>
If you set the class constant to private you will no longer be able to access that constant outside of the class the same way you wouldn't be able to access the class properties. However you could access them from within the class and to **access constants within the class** you need to use the class name the scope resolution operator (::) and the name of the constant.
<code php>
<?php
declare(strict_types = 1);
namespace App\PaymentGateway\Paddle;

class Transaction
{
    public const STATUS_DECLINED = 'decliened';
    public const STATUS_PAID     = 'paid';
    public const STATUS_PENDING  = 'pending';
    
    public function __construct()
    {
      var_dump(Transaction::STATUS_PAID);
    }
}
</code>
Another way to access it is by using the self keyword and self refers to the current class, so it's similar to the $this variable which refers to the calling object but self refers to the current class or the class where it's called. 
<code php>
<?php
declare(strict_types = 1);
namespace App\PaymentGateway\Paddle;

class Transaction
{
    public const STATUS_DECLINED = 'decliened';
    public const STATUS_PAID     = 'paid';
    public const STATUS_PENDING  = 'pending';
    
    public function __construct()
    {
        var_dump(self::STATUS_PAID);
    }
}
</code>
A class also has a magic constant called class which resolves at compile time and returns a fully qualified class name
<code php>
<?php
declare(strict_types = 1);
use App\PaymentGateway\Paddle;
require_once __DIR__ . '/../vendor/autoload.php';

$transaction = new Transaction();
echo $transaction::class; /* why is it lower case, tell me why */
</code>
This can work on objects and you can work on the class itself. 
<code php>
<?php
echo Transaction::class; 
</code>
There are many use cases for constants, if you have data or information that does not change and keep referencing all over the code it's better to move it into a class constant so that if it ever changes change it in one place. Another use case is to define constants as sort of enumerations or enums. It allow you not to hard code these value. If you notice that you're hard coding some piece of data that does not change that often, consider replacing them with constants.
<code php>
<?php
declare(strict_types = 1);
namespace App\PaymentGateway\Paddle;

class Transaction
{
    public const STATUS_DECLINED = 'declined';
    public const STATUS_PAID     = 'paid';
    public const STATUS_PENDING  = 'pending';
    
    private string $status;
    
    public function __construct()
    {
        $this->status = self::STATUS_PENDING;
    }
    
    public function setStatus(string $status): self
    {
      $this->status = $status;
      return $this;
    }
}
</code>
The following code is setting status to paid, this is all good and it's working. Imagine you would doing this all over your code. You're code essentially hard coding these and you might make a typo or pass something like this and it will still work right and even through this does not cause any errors you might introduce some bugs somewhere else in your code also you could pass any invalid status and it will still work and again this could introduce bugs in another part of your code.
<code php>
<?php
declare(strict_types = 1);
use App\PaymentGateway\Paddle;
require_once __DIR__ . '/../vendor/autoload.php';

$transaction = new Transaction();
$transaction->setStatus('paid');
</code>
This is where constants can hel you. 
<code php>
<?php
declare(strict_types = 1);
use App\PaymentGateway\Paddle;
require_once __DIR__ . '/../vendor/autoload.php';

$transaction = new Transaction();
$transaction->setStatus(Transaction::STATUS_PAID); /* $transaction->setStatus('Oma Meyer'); is ok */
</code>
Now we have solved on problem. The problem we solved is with the typos, now we are passing the constant so we know that we're not going to make typos. However we could still pass any invalid status like Oma Meyer as status and the code would work here. To solve this second case we could simply introduce some kind of validation.
<code php>
<?php
declare(strict_types = 1);
namespace App\PaymentGateway\Paddle;

class Transaction
{
    public const STATUS_DECLINED = 'decliened';
    public const STATUS_PAID     = 'paid';
    public const STATUS_PENDING  = 'pending';
    
    private string $status;
    
    public function __construct()
    {
        $this->status = self::STATUS_PENDING;
    }
    
    public function setStatus(string $status): self
    {
      if ($status === self::STATUS_PAID || $status === self::STATUS_PENDING || $status === self::STATUS_DECLINED ) 
      {
         $this->status = $status;
      } else {
        /* throw some kind of exception or error */
      }
      return $this;
    }
}
</code> 
If status is paid or pending or status is declined then everything is good, otherwise maybe throw an exception or throw some kind of error, but this would be bunch of conditionals here and as you would add more constants and more statuses you would need to modify this method instead of this we could simply introduce another constant called all statuses and set this to an array the keys can be the actual statuses.
<code php>
<?php
declare(strict_types = 1);
namespace App\PaymentGateway\Paddle;

class Transaction
{
    public const STATUS_DECLINED = 'declined';
    public const STATUS_PAID     = 'paid';
    public const STATUS_PENDING  = 'pending';
    
    /* Lookup table */
    public const ALL_STATUSES = [  
        self::STATUS_PAID     => 'Paid',
        self::STATUS_PENDING  => 'Pending',
        self::STATUS_DECLINED => 'Decliened'
    ];
    
    private string $status;
    
    public function __construct()
    {
        $this->status = self::STATUS_PENDING;
    }
    
    public function setStatus(string $status): self
    {
    /* if ($status === self::STATUS_PAID || $status === self::STATUS_PENDING || $status === self::STATUS_DECLINED ) */
      if (! isset(self::ALL_STATUSES[$status]))
      {
         throw new \InvalidArgumentException('Invalid status');
      } 
      $this->status = $status;
      return $this;
    }
}
</code> 
You could actually introduce some kind of friendly name to this status because you already these values available as keys and for the values of this array you could give it a friendly name that you could later use to display to the user. This array can be used as lookup table, the lookup table makes it simple to check if the given status exists in the all statuses array and if it does not exist we can throw some kind of exception or an error. Two problems solved  but there is the one thing bothering, we're kind of coupling these constants within the transaction class. The Transaction class should be responsible for processing and working with transactions and not for storing status constants. It does not make sense to refer to transaction class outside of object to access the constants. Imagine we had to access we this constant somewhere else where transaction wasn't needed maybe for display, referencing a class that has other business logic in it just to get the constant values would not look good in code. 

We could extract all Status constants into its own class, because right now we're prefixing all statuses with the status word. Changing something like self::STATUS_PAID to Status::PAID would look much cleaner and or expressive. 
<code php>
<?php
namespace App\Enums;

class Status
{
    public const DECLINED = 'declined';
    public const PAID     = 'paid';
    public const PENDING  = 'pending';
    
    /* Lookup table */
    public const ALL_STATUSES = [  
        self::PAID     => 'Paid',
        self::PENDING  => 'Pending',
        self::DECLINED => 'Declined'
    ];
}
</code> 
Some small changes, switch from self:: to Status:: and everything still works  
<code php>
<?php
declare(strict_types = 1);
namespace App\PaymentGateway\Paddle;

class Transaction
{  
    private string $status;
    
    public function __construct()
    {
        $this->status = Status::PENDING;
    }
    
    public function setStatus(string $status): self
    {
      if (! isset(Status::ALL_STATUSES[$status]))
      {
         throw new \InvalidArgumentException('Invalid status');
      } 
      $this->status = $status;
      return $this;
    }
}
</code> 
This looks a lot more readable and expressive and we are not coupling our status data with the transaction class. Something to note PHP will be adding native support to enum type so you could create enum classes so you wouldn't need to create a class like the Status class with constants. You would be able to create an enum class, see [[https://wiki.php.net/rfc/enumerations|PHP RFC: Enumerations]]
===== Static Members & Methods =====
You can define your properties and methods to be static using the static keyword. You can put the keyword static before or after the access modifier, as you like, if you following standards you should put it after the access modifier. It is up to you as long as you stay consistent. 
<code php>
<?php
declare(strict_types = 1);
namespace App\PaymentGateway\Paddle;

class Transaction {
  public static int $count = 0; /* or read only? */
  
  public static function getCount(): int {
    return self::$count;
  }
  
  
  public function __construct(
    public float $amount,
    public string $description
  ) {
    self::count++;
  }
  
  public function process()
  {
     echo 'Processing paddle transaction ...';
  }  
}
</code>
You can access static properties and methods the same way you could access constants using the scope resolution operator (::)
<code php>
<?php
declare(strict_types = 1);
namespace App\PaymentGateway\Paddle\Transaction;
require_once __DIR__ . '/../vendor/autoload.php';

$transaction = new Transaction(25, 'Transaction 1');
var_dump($transaction::$count); /* access on the object */
var_dump(Transaction::$count);  /* access on the class */
</code>
The thing is you don't actually need the object to access the static methods and properties of the class because they're not created and they're not associated per object they are created and associated o class basis so they belong to the class itself and not to any particular object or an instance and here as you can see this is perfectly valid and it  will work. You can access static properties and methods on the object but you don't have to, you could access them on the class itself the same way you where accessing class constants.
 
As mentioned static properties and functions are not associated per object, what that means is that the regular class properties every time you create an instance these properties get created and get associated to that specific object, so you could have multiple different transaction objects and each one can have different values for those properties. You can think of static properties as global variables in a way their values are shared across the objects because they're not tied to a particular object or an instance they're tied to the class itself.
<code php>
<?php
declare(strict_types = 1);
namespace App\PaymentGateway\Paddle\Transaction;
require_once __DIR__ . '/../vendor/autoload.php';

$transaction = new Transaction(25,  'Transaction A');
$transaction = new Transaction(50,  'Transaction B');
$transaction = new Transaction(75,  'Transaction C');
$transaction = new Transaction(100, 'Transaction D');
$transaction = new Transaction(125, 'Transaction F');
var_dump(Transaction::$count);  /* access on the class */
</code> 
With each new object $count will add 1 that's why we get 5. As you see the value is shared and it's kind of globally 
accessible. You don't need an instance of the class. You could simply just access them using the class itself.

If $count would be private we could use getCount() and everything is still working.
<code php>
<?php
declare(strict_types = 1);
namespace App\PaymentGateway\Paddle\Transaction;
require_once __DIR__ . '/../vendor/autoload.php';

$transaction = new Transaction(25,  'Transaction A');
$transaction = new Transaction(50,  'Transaction B');
$transaction = new Transaction(75,  'Transaction C');
$transaction = new Transaction(100, 'Transaction D');
$transaction = new Transaction(125, 'Transaction F');
var_dump(Transaction::getCount());  /* access on the class */
</code> 

===== Inheritence =====

<code php>
<?php
class Admin extends User {
  private $level;
  
  // Constructor
  public function __construct($name, $email, $level) {
    echo 'Admin Constructor ran ... <br />'; 
    $this->level = $level;
    parent::__construct($name, $email);
  }
  
  // Getter & Setter
  // ...
  
  // Methods
  public function login() { // Polymorphism 
    echo 'Admin ' . $this->name . ' is logged in<br />';
  }
}

$admin1 = new Admin('Tom Sawyer', 'tom@gmail.com', 5);
var_dump($admin1);
</code>
===== Interfaces =====

<code php>
<?php
interface ContentInterface {
  public function display();
  public function edit();
}

class Article implements ContentInterface {
  private $title;
  private $content;
  
  public function __construct($title, $content) {
    $this->title = $title;
    $this->content = $content;
  }
  
  public function display() {
    echo "<h2>{$this->title}</h2>";
    echo "<p>{$this->content}</p>";
  }
  
  public function edit() {
    echo "Editing the article '{$this->title}'";  
  }
}  

class Video implements ContentInterface {
  private $title;
  private $url;
  
  public function __construct($title, $url) {
    $this->title = $title;
    $this->url = $url;
  }
  
  public function display() {
    echo "<h2>{$this->title}</h2>";
    echo "<iframe src='{$this->url}'></iframe>";
  }
  
  public function edit() {
    echo "Editing the video '{$this->title}'";  
  }
} 

$article = new Article('Introduction to PHP', 'PHP is a versitile Scripting language');
$video = new Video('PHP for Beginners', 'https://www.youtube.com/watch?v=BUCiSSyIGGU');
?>

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  
  <title>PHP from scratch</title>
</head>

<body class="bg-gray-100">
  <header class="bg-blue-500 text-white p-4">
    <div class="container mx-auto">
      <h1 class="text-3xl font-semibold">PHP From Scratch</h1>
    </div>
  </header>
  <div class="container mx-auto p-4 mt-4">
    <!-- Output -->  
    <div class="bg-white rounded-lg shadow-md p-6 mt-6">
      <?= $article->display() ?>
    </div>
    <div class="bg-white rounded-lg shadow-md p-6 mt-6">
      <?= $video->display() ?>
    </div>
  </div>
</body>      
        
</html>
</code>
===== Abstract Classes =====

Abstract Classes are
  * incomplete
  * at least partially incomplete
  * we cannot instantiate then
  * if a class has a abstract method, the class must be marked abstract too
  * common in parent classes

<code php>
abstract class Shape {
  protected $name;
  
  abstract public function calculate();
  
  // Constrictor
  public function __construct($name) {
    $this->name = $name;
  } 

  // Concrete methods
  public function getName() {
    return $this->name;
  }
}


class Circle extends Shape {
  private $radius;

  public function __construct($name, $radius) {
    parent::__construct($name);
    $this->radius= $radius;
  }
  public function calculate(){
    return pi() * pow($this->radius, 2); // r^2
  }
}

$circle = new Circle('Circle', 5);
var_dump($circle); 


class Rectangle extends Shape {
  private $width;
  private $height;

  public function __construct($name, $width, $height) {
    parent::__construct($name);
    $this->width = $width;
    $this->height= $height;
  }
  public function calculate(){
    return $this->width * $this->height;
  }
}

$rectangle = new Rectangle ('Rectangle ', 4, 6);
var_dump($rectangle); 
</code>


===== Catch Errors =====
  * **Exception** Base class for all exceptions
  * **Error** Base class for all internal PHP errors
  * **TypeError** Raised when a function argument or return value has the wrong type
  * **ParseError** Raised when there is a syntax error in evaluated code (e.g. eval)
  * **ArgumentCountError** Raised when too few arguments are passed to a function
  * **ArithmeticError** Raised when an invalid arithmetic operation occurs (e.g. division by zero with intdiv)
  * **DivisionByZeroError** Raised specifically when dividing by zero
  * **UnhandledMatchError** Raised when a `match` expression has no matching arm
  * 

<code php>
try {

} catch (Execption $e) {
  echo $e->getMessage();
}
</code>

==== Throw own Errors ====

  * **Throwable** Base interface implemented by both Error and Exception
  * **Exception** Base class for all traditional exceptions
  * **Error** Base class for all internal PHP errors (since PHP 7)

  * **TypeError** Raised when a function argument or return value has the wrong type
  * **ParseError** Raised when there is a syntax error in evaluated code (e.g. eval, include)
  * **ArgumentCountError** Raised when too few arguments are passed to a function (since PHP 7.1)
  * **ArithmeticError** Raised when an invalid arithmetic operation occurs (since PHP 7.0)
  * **DivisionByZeroError** Raised specifically when dividing by zero (since PHP 7.0)
  * **UnhandledMatchError** Raised when a `match` expression has no matching arm (since PHP 8.0)

  * **CompileError** Raised on compilation-time errors (since PHP 7.3)
  * **ValueError** Raised when a function receives a valid type but an invalid value (since PHP 8.0)

  * **AssertionError** Raised when an `assert()` fails (since PHP 7.0)

  * **FiberError** Raised when an invalid operation is performed on a Fiber (since PHP 8.1)

  * **ClosedGeneratorException** Raised when resuming a closed generator (internal, since PHP 7)

  * **PDOException** Raised by PDO operations (extends Exception)
  * **ErrorException** Wraps traditional PHP errors as exceptions (useful with set_error_handler)

<code php>
class MyException extends Exception {}
</code>
