**[[home:|Start]]** -> **[[home:php:|PHP]]** -> **[[home:php:api:|PHP API]]** -> **PHP Rest API**

====== PHP Rest API ======
What is an API? When you visit a website, you enter a web address in the address bar of the browser. This sends a request to the web server, and that responds with some content, which is usually HTML. When the browser displays the content, you see links to click on, forms to fill in and so on. The content is laid out and formatted using HTML and CSS so that a human can easily understand it. This is the web interface for that content. It's meant for humans to understand. If a program wants the same data though, it doesn't need HTML or CSS to understand it. All the program wants is the data. It doesn't care about the text colour, font size and so on. So in order for some software to be able to read this more easily, we have an API or application programming interface. When a program makes a request to the API, it returns just the data, with no formatting. **The web interface is for humans, whereas an API is for machines.** An API is basically a way for two pieces of software to talk to each other.

So REST is not a protocol, it's an idea or a philosophy, a way of building things in a manner that's very consistent and elegant. A REST service tries to make data processing very easy over HTTP. You can do REST without HTTP, but its specially designed as an service to work with data over HTTP. It's ideally suited to situations were we do CRUD.

This site, [[https://randomuser.me/|Random User Generator]], generates random data about people. This data is useful when developing or testing software that needs user data, so you don't have to make it up yourself. Every time the page is refreshed, we get details about a new random user - the name, photo, email address, password and so on.

This is the web interface for this data. However, to use this data, it's not really very convenient to extract this from this page. You could copy and paste each item of data from the web browser and then paste it into your code or insert it into a database. Alternatively, you could **write code to parse this HTML, and extract the data from it**, a process known as **scraping**. However, this is error prone and very fragile. Any changes made to the underlying HTML could break the code that extracts the data. Instead, we want to be able to access this data programmatically.

This is where an API comes in. The API for this particular website is available at this **URL plus /api** at the end. If we open that in the browser, we get some data about a random user, although this time without all the visual formatting. As with the web interface, if I refresh this, we get some random data about another user. It's the same data - name, email address and so on, although this is in a format that is much easier for a piece of software to read. When using the API, what is returned is just data, which is all another program needs. So basically, the web interface is for people to use, whereas the API is for programs to use.

The [[https://www.php.net/manual/en/function.file-get-contents.php|file_get_contents]] function in PHP can be used to read the contents of a file into a string. However, we can also use this to retrieve the contents of a website. So let's call this function, passing in the URL we want, [[https://example.com|example.com]], and we'll assign the return value to a variable. Next, let's just print out the contents of this variable. We store this in an index.php file, as follows
<code php>
<?php
$response = file_get_contents("https://example.com");
echo $response;
</code>
Let's run this on the command line.
<code bash>
php index.php
</code>
What's printed out is the content from the [[https://example.com|example.com]] website. If we compare this with the source we just saw in the browser, it's exactly the same. So all this code does is request the given URL, and returns the response into this variable. Let's change this URL to that of the random user API we saw earlier. 
<code php>
<?php
$response = file_get_contents("https://randomuser.me/api");
echo $response;
</code>
**Note** that with APIs, a web address or URL is commonly known as an **API endpoint**. So when we run this again, we get a response from that URL. This is known as an **API call**. So instead of the browser making this request, retrieving the response and displaying it, the PHP code does it instead. And we get the response back as a string.

When we make an API call to this site and get some data, the data that's returned doesn't contain any HTML, CSS or any other presentation code. This data is in a format that is easy for the code to use. Some APIs return data formatted as XML, or even HTML, but the default is usually [[http://www.json.org/json-en.html|JSON]]. [[http://www.json.org/json-en.html|JSON]], or JavaScript Object Notation, is a simple, easy to read format used for exchanging data and is the de facto standard for web APIs. Although this is JavaScript code, it's not code that's going to be executed either on the server or in the browser, it's just used to format the data.

Basically, it's just a list of key and value pairs - raw data with no formatting. Plus, PHP has functions like this one, [[https://www.php.net/manual/en/function.json-decode.php|json_decode]], for handling JSON data, so you don't need to worry about parsing it manually. Now we have some JSON data, we can decode it and process it further. So instead of printing this out, let's call the json_decode method on it, and assign this return value to another variable. This time, let's use var_dump to print it out.
<code php>
<?php
$response = file_get_contents("https://randomuser.me/api");
$data = json_decode($response); var_dump($data);
</code>
When we run this, we get a generic PHP object with various properties that contain the various attributes of the random user data. To make this simpler, let's get this data as an associative array instead, which we can do by passing in true as the second argument to the json_decode function. 
<code php>
<?php
$response = file_get_contents("https://randomuser.me/api");
$data = json_decode($response, true); var_dump($data);
</code>
Now when we run this, we get the data in an array. Let's print out one of these items of data. As we can see, at the top level, we have an item with an index of "results", which itself contains an array with one element, and that in turn contains several arrays, for name, location and so on. The array with an index of "name" contains three values, for the title, first name and surname.

**Note** that the structure of these results is specific to this API. Most, if not all, APIs will come with documentation that describes how the results are structured.
<code php>
<?php
$response = file_get_contents("https://randomuser.me/api");
$data = json_decode($response, true); //var_dump($data);
echo $data["results"][0]["name"]["first"], "\n";
</code>
So instead of printing out the whole array, we'll access the "results" element, the first element of that array, then the "name" element, then the first element of that. Let's print out a newline character after this, so it's easy to see what's happening when we run it. All we're doing here is **accessing nested array data**, nothing unusual. When we run this, we get a random user's first name. Every time we run it, we get a new value. So when we run this, the code is making a request to the API, getting the response in JSON format, converting this to a PHP array, and getting the first name from that data.

We've been running this PHP on the command line, but let's look at how we might integrate API data into a page we view in a browser. Just like you might use a database to generate content, using an API allows you to do many more things. For example, integrating weather data into your application, looking up currency exchange rates and so on. 
For this example, we'll use the [[https://agify.io/|agify API]]. This is a simple API that predicts the age of a person given their name. 

To use [[https://agify.io/|agify API]], we pass in the name in the URL, using the query string like this [[https://api.agify.io?name=robin]], and this returns some [[http://www.json.org/json-en.html|JSON]]. For example, the name Michael is predicted to be sixty nine. Let's call this API from a form we display in the browser.
First, let's add some HTML after this PHP at the top.
<code php>
<?php
if (!empty($_GET["name"])) {
  $response = file_get_contents("https://api.agify.io?name={$_GET['name']}");
  $data = json_decode($response, true); //var_dump($data);
  //echo $data["results"][0]["name"]["first"], "\n";
  $age = $data["age"];
}  
?>
<!DOCTYPE html>
<html>
  <head>
    <title>Random User</title>
  </head>
  <body>
    <?php if(isset($age)): ?>
      Age: <?= $age ?>
    <?php endif; ?>  
    <form>
      <label for="name">Name</label>
      <input name="name" id="name">
      <button>Guess age</button>
    </form>
  </body>
</html>      
</code>
We'll add a doctype, a head element containing a title, and a body element. In here, let's at a form, a label, and input for the name, and a button to submit the form. Without any attributes, this form will use the get method, and submit to itself, so we can check for this at the top of the script. 

So before we call the API, let's keep it simple and just check to see if the "name" element of the $_GET array isn't empty, and if it isn't, we'll call the [[https://agify.io/|agify API]], which has this URL as its endpoint. We'll pass the contents of the text input in the query string. Obviously, with a real application, we'd sanitise this first, but for the purposes of this demo, we'll keep it simple. The JSON returned contains an element with an index of "age", which contains the value we want. So instead of echoing out this item of data, we'll assign the age value from the [[https://agify.io/|agify]] data to a variable called $age. Then, in the HTML, we'll check to see if this variable is set, and if so, we'll display its contents.

In the browser, there's the form. Let's submit a name, and the API predicts that the name Robin belongs to someone who is 64. I'm not there yet, but try your name with this API to see if it's more accurate. So just as with the random user data, we're calling this API from our code, passing it some user input,decoding the JSON response and displaying the results.

===== Requests and Responses using cURL =====
From the user's point of view though in the browser, the fact we're using an API is hidden. This happens on the server, and the server sends the request to the API and processes its response. As we just saw, to open a web page or use an API, the client makes a request to the server and it receives a response. The client could be a web browser, or in the case of an API, another program. To make a request, we need the URL, and the body of the response that we get contains HTML, JSON or whatever. In addition to these, there are additional parts of the request and response that we need to use when working with APIs.

==== Using cURL Library ====
These are the basics of HTTP, the protocol that the web uses. In this section, we're going to look at these in more detail. First though, we're going to change how we make an API request. In the previous section, we used the [[https://www.php.net/manual/en/function.file-get-contents.php|file_get_contents]] function. Although this is part of core PHP, using this function to make API requests requires stream contexts, and you have to make sure you format values using special characters like "\r\n".

So it's much easier to introduce errors. Plus, **if an API call fails, there's no way to get the body of the response, only the status code**. We'll see an example of this later on in this section. In addition, [[https://www.php.net/manual/en/function.file-get-contents.php|file_get_contents]] requires the [[https://www.php.net/manual/en/filesystem.configuration.php#ini.allow-url-fopen|allow_url_fopen]] setting to be enabled.

**It's common for [[https://www.php.net/manual/en/filesystem.configuration.php#ini.allow-url-fopen|allow_url_fopen]]  not to be enabled on shared hosting, so it wouldn't work**. For these reasons, we won't be using the [[https://www.php.net/manual/en/function.file-get-contents.php|file_get_contents]] function. Instead, a more common way to consume an API is using [[https://curl.se/|cURL]]. This is a tool for transferring data using URLs. You can use [[https://curl.se/|cURL]] on the command line or from code.

PHP supports [[https://www.php.net/manual/en/book.curl.php|libcurl]], and provides many functions for sending requests to URLs, and handling their responses. So instead of using [[https://www.php.net/manual/en/function.file-get-contents.php|file_get_contents]], let's use [[https://curl.se/|cURL]] to make the request to the API. 

To use [[https://curl.se/|cURL]] in PHP, First, we need to initialise a [[https://curl.se/|cURL]] session using the **curl_init** function. This returns the handle to the [[https://curl.se/|cURL]] session. You can pass in the URL you want to request as an argument if you like, or you can set it as an option.
<code php>
<?php
//$ch = curl_init("https://randomuser.me/api");
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, "https//randomuser.me/api");
curl_setopt($ch, RETURNTRANSFER, true);

$response = curl_exec($ch);
curl_close($ch);
echo $response, "\n";
</code>
To set an option for the transfer, we call the **[[http://php.net/manual/en/function.curl-setopt.php|curl_setopt]]** function, passing in the handle, a constant identifying the value we want to set, and the value itself. There are many different options we can set, as detailed in the [[http://php.net/manual/en/function.curl-setopt.php|official documentation]]. 

First, let's set the URL, which we do with the **[[[[https://curl.se/libcurl/c/CURLOPT_URL.html|CURLOPT_URL]]** constant. We'll set this to the URL we were using earlier. As I said, you can pass this in as an argument to the **[[https://www.php.net/manual/en/function.curl-init.php|curl_init]]** function if you like, but as we usually set more than one option, I prefer to do it this way. Then, we want the response to be returned as a string instead of being output directly, which we do by setting **[[https://php.watch/codex/CURLOPT_RETURNTRANSFER|CURLOPT_RETURNTRANSFER]] to true**. For this simple request, these are the only settings we need to set.

To execute the request, we call the **[[https://www.php.net/manual/en/function.curl-exec.php|curl_exec]]** function, passing in the handle. As we've set **[[https://php.watch/codex/CURLOPT_RETURNTRANSFER|CURLOPT_RETURNTRANSFER]] to true**, this will return the response as a string. So that's assign that to a variable. Finally, we call **[[https://www.php.net/manual/en/function.curl-close.php|curl_close]]** to close the handle and free up any system resources it's been using. To see the response, which is a string, let's just echo it out, followed by a newline character. 
<code php>
<?php
//$ch = curl_init("https://randomuser.me/api");
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, "https//randomuser.me/api");
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);

$response = curl_exec($ch);
curl_close($ch);
echo $response, "\n";
</code>
When we run the script, we get the JSON response we saw earlier containing the random user data. When using cURL, if you're setting multiple options, there is an alternative way to set them, which avoids calling [[https://www.php.net/manual/en/function.curl-setopt.php||curl_setopt]] multiple times. By using the  [[https://www.php.net/manual/en/function.curl_setopt_array.php|curl_setopt_array]] function, we can set multiple options at once, by passing the options in as an array. Both of these methods are equivalent, so whichever one you use is up to you. Plus, you can use a mixture of these if you like, setting some values individually, others as part of the array.
<code php>
<?php
$ch = curl_init();
//curl_setopt($ch, CURLOPT_URL, "https//randomuser.me/api");
//curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt_array($ch, [
  CURLOPT_URL => "https//randomuser.me/api",
  CURLOPT_RETURNTRANSFER => true
]);

$response = curl_exec($ch);
curl_close($ch);
echo $response, "\n";
</code>
And when we run this code, it works just as before, requesting data from the API and printing it out.

==== HTTP status code ====
Now we can look at additional parts of the request and response. We'll start with an **additional part** of the response, the **status code**. In addition to the body of the response, which is sometimes referred to as the **payload**, the server returns a status code. The status code is a numeric value that tells us how the request went. There are several possible [[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes| HTTP status codes]] that could be returned, all three digits.

Generally, **anything in the 200 range means the request was OK** and the server could successfully return a response. Anything in **the 400 range means there is something wrong with the request**, and anything **in the 500 range means the server had a problem**. If you're not familiar with [[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes|HTTP status codes]], you'll almost certainly have seen a [[https://github.com/404|404]] page, which means the URL you requested couldn't be found on the server. When this happens, the server returns a [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/404|404 status code]]. 

Let's use [[https://curl.se/|cURL]] to get the status code for the API request we're making. To do this, we call the [[https://www.php.net/manual/en/function.curl-getinfo.php|curl_getinfo]] function, passing in the handle to the [[https://curl.se/|cURL]] session and the [[https://www.php.net/manual/en/curl.constants.php#constant.curlinfo-http-code|CURLINFO_HTTP_CODE]] constant. This will return the status code as an integer, so let's assign the return value to a variable. Then lower down, let's print this out, followed by a new line character. When we run this, we get a status code of [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/200|200]]. This means the request was successful and there were no problems. 
<code php>
<?php
$ch = curl_init();
curl_setopt_array($ch, [
  CURLOPT_URL => "https//randomuser.me/api",
  CURLOPT_RETURNTRANSFER => true
]);
 
$response = curl_exec($ch);
$status_code = curl_get($ch, CURLINFO_HTTP_CODE);
curl_close($ch);

echo "Status " . $status_code, "\n";
echo "Response\n" . $response, "\n";
</code>
If I change the URL to one that doesn't exist, and then run it again, we get a [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/404|404 status code]], as that URL wasn't found on that server. 
<code php>
<?php
$ch = curl_init();
curl_setopt_array($ch, [
  CURLOPT_URL => "https//randomuser.me/apixxx",
  CURLOPT_RETURNTRANSFER => true
]);
 
$response = curl_exec($ch);
$status_code = curl_get($ch, CURLINFO_HTTP_CODE);
curl_close($ch);

echo "Status:  " . $status_code, "\n";
echo "Response\n" . $response, "\n";
</code>
**Note** that if the server isn't found, you get a status code of zero as there's no server to send back a status code. Let's try this with a different API. The [[https://openweathermap.org/api|Open Weather API]] gives us weather forecast data for a specified location. 

Let's try this from our code. We'll change the URL to the endpoint of the [[https://openweathermap.org/api|OpenWeather API]], and to specify the location we want the forecast for, we pass it in using the query string. So let's get the data for London for example. 
<code php>
<?php
$ch = curl_init();
curl_setopt_array($ch, [
  CURLOPT_URL => "https//api.openweathermap.org/data/2.5/weather?q=London",
  CURLOPT_RETURNTRANSFER => true
]);
 
$response = curl_exec($ch);
$status_code = curl_get($ch, CURLINFO_HTTP_CODE);
curl_close($ch);

echo "Status:  " . $status_code, "\n";
echo "Response\n" . $response, "\n";
</code>
When we run this, we get a **[[https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/401|401 status code]]**, which means this **page requires authentication**, but we didn't provide any. 

**Note** that we also get some data in the body of the response, the code and an error message telling us the API key is invalid. This is one reason why using [[https://curl.se/|cURL]] is better than using the [[https://www.php.net/manual/en/function.file-get-contents.php|file_get_contents]] function. For any response that doesn't have a status code of 200, [[https://www.php.net/manual/en/function.file-get-contents.php|file_get_contents]] just returns false, and there's no way to get the response's payload.

In order to use this API, we need an API key. This is similar to a username and password, but for an API. We'll cover these in more detail later on. For the moment, to get an API key for this API, you need to sign up for a free account. Once you've done this, your account will show you the API key you need to use the API, which is just a string of characters. So copy the key from the webside, then in the code, we pass in the API key as part of the query string, using the "appid" key. **Note** that there's no standard for the name of the API key variable, this one is specific to this API. 
<code php>
<?php
$ch = curl_init();
curl_setopt_array($ch, [
  CURLOPT_URL => "https//api.openweathermap.org/data/2.5/weather?q=London&appid=081532",
  CURLOPT_RETURNTRANSFER => true
]);
 
$response = curl_exec($ch);
$status_code = curl_get($ch, CURLINFO_HTTP_CODE);
curl_close($ch);

echo "Status:  " . $status_code, "\n";
echo "Response\n" . $response, "\n";
</code>
Now when we run this, we get a [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/200|200 status code]] and the weather data for the location we specified, which includes the temperature, humidity and so on. So the [[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes|response code]] tells us how the request went - if it was successful or if not, why not, so we can process the response accordingly.

==== Request Headers (Add Request meta data) ====
In addition to the URL we specify when we make the request, we can add headers to the request. Headers represent metadata about the request, the address of the server making the request, or details about the client, for example. 
Plus, they can be used to send authorisation details, like an API key, or to request data in a specific format or language. The [[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Request_fields||headers are simple key value pairs]] sent as strings. 

To show an example of how to use request headers, let's use the [[https://unsplash.com/|Unsplash API]] to retrieve data about a random photo. To use this API, as with the one we saw previously, you need an API key, which you can get by creating a free account. As before, we could pass the [[https://unsplash.com/documentation#public-authentication|API key]] in using the query string like this, but we can also do it using the Authorization header. First, let's change the API endpoint we're requesting to the [[https://unsplash.com/|Unsplash API]] endpoint that returns a random photo. 
<code php>
<?php
$ch = curl_init();
curl_setopt_array($ch, [
  CURLOPT_URL => "https//api.unsplash.com/photos/random",
  CURLOPT_RETURNTRANSFER => true
]);
 
$response = curl_exec($ch);
$status_code = curl_get($ch, CURLINFO_HTTP_CODE);
curl_close($ch);
 
echo "Status:  " . $status_code, "\n";
echo "Response\n" . $response, "\n";
</code>
Before we out of the authorisation details, let's run this, and we get a 401 status code, which tells us the request requires authorisation, and in the body of the response, we're told the access token is invalid. So let's add the API key in a request header. To do this, first, we'll **create an array which contains each header we want to pass** as a string. To authenticate with this API, we pass in the "Authorization" header, which is separated by its value by a colon, then the string "Client-ID", and finally, the API key value.

You need to change this value to your individual API key. If you want to pass in more request headers, you can simply add more elements to this array. Then, to pass these headers along with the request, we set the [[https://curl.se/libcurl/c/CURLOPT_HTTPHEADER.html|CURLOPT_HTTPHEADER]] option, setting the value to the array.
<code php>
<?php
$ch = curl_init();

$headers = [
  "Authorization: Client-ID YOUR_ACCESS_KEY"
];

curl_setopt_array($ch, [
  CURLOPT_URL => "https//api.unsplash.com/photos/random",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_HTTPHEADER => $headers
]);
 
$response = curl_exec($ch);
$status_code = curl_get($ch, CURLINFO_HTTP_CODE);
curl_close($ch);
 
echo "Status:  " . $status_code, "\n";
echo "Response\n" . $response, "\n";
</code>
When we run it, we get a 200 response code, and the body of the response contains the details of a random photo its URL, dimensions and so on. So the request headers allow us to add metadata about the request. Some APIs require specific headers to work, for example, in this case, the API key in the authorization header. Others require details about the user agent and so on, but details of these will always be covered in the [[https://unsplash.com/documentation/user-authentication-workflow|API's documentation]]. 

See [[https://help.unsplash.com/en/articles/2511245-unsplash-api-guidelines|Unsplash API Guidelines]] from the [[https://unsplash.com/documentation|official Unlash technical guidelines]] for integrating the Unsplash API into your application for mor details

==== Request Headers (Read Request meta data) ====
In addition to the request headers, the **response also includes headers** which **represent metadata about the response**. [[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Response_fields|Common response headers]] include details about the response body, like its length, the language it uses and the type, for example, HTML, JSON and so on. To view all the response headers, we set the **[[https://curl.se/libcurl/c/CURLOPT_HEADER.html|CURLOPT_HEADER]]** setting to true. Now, when we make a request, the response headers are included as part of the response body, before the payload, with a blank line separating them. 
<code php>
<?php
$ch = curl_init();
 
$headers = [
  "Authorization: Client-ID YOUR_ACCESS_KEY"
];
 
curl_setopt_array($ch, [
  CURLOPT_URL => "https//api.unsplash.com/photos/random",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_HTTPHEADER => $headers,
  CURLOPT_HEADER => true
]);
$response = curl_exec($ch);

$status_code = curl_get($ch, CURLINFO_HTTP_CODE);
$content_type = curl_getinfo($ch, CURLINFO_CONTENT_TYPE);
$content_length = curl_getinfo($ch, CURLINFO_CONTENT_LENGTH_DOWNLOAD);

curl_close($ch);
 
echo "Status:  " . $status_code, "\n";
echo "Type:    " . $content_type;
echo "Length:  " . $content_length;
echo "Response\n" . $response, "\n";
</code>
**With this response, we can see some standard headers**, like the response type, which in this case is [[https://www.json.org/json-en.html|JSON]], and the content length, which is the size of the response body below in bytes. There are also some **non-standard headers, which typically begin with an X**, for example, with this API, this account is limited to 50 requests per hour, which is shown in the x-ratelimit header, and it also reports how many are left in the remaining header. Adding this option to the cURL request does include all the headers as part of the response body. There are a few response header values that can be retrieved individually using the [[https://www.php.net/manual/en/function.curl-getinfo.php|curl_getinfo]] function, for example, the content type and its length. We're already using this function to get the status code. So let's do the same for the content type, passing in the relevant constant, and also the content length. Then, let's print these out in the same way.
 
Now when we run this, we also get the content type and the content length. As with the request headers, details of what data are included in the response headers will be covered in the [[https://unsplash.com/documentation#public-authentication|API's documentation]]. 

==== Individual Response Headers ====
Although there are a few response headers we can get using the [[https://www.php.net/manual/en/function.curl-getinfo.php|curl_getinfo]] function, we can't get all of them like this. Setting the **[[https://curl.se/libcurl/c/CURLOPT_HEADER.html|CURLOPT_HEADER]] option to true**, just adds all the headers to the top of the response, as we just saw. If you want to get all of the response headers in a more usable format, then we can use the [[https://curl.se/libcurl/c/CURLOPT_HEADERFUNCTION.html|CUROLOP_HEADERFUNCTION]]. We can set this value to a callback function that will be called once for each response header, allowing us to process each one individually.

**Note** that for this to work, the function needs to return the length of the individual header, in bytes. Before we add this, let's remove the individual header calls we added earlier for the content type and content length, and also the setting that adds the headers to the response body. Next, let's initialise an array to store each individual response header. Then create a closure, which will be our callback function, and this is the function that will be called for each response header. When [[https://curl.se/|cURL]] calls this function, it will be passed two arguments the [[https://curl.se/|cURL]] handle, and the header value itself. So we can use the array variable we just created inside this function, we have to pass it in from the parent scope with use, prefixing it with an ampersand, so it's passed by reference. Inside the body of the function, first we'll use the string length function to get the length of the header. Then for now, let's just append the value of the header to the array. Finally, we'll return the header length value. To call this function for each header, we add the HEADERFUNCTION option, setting its value to the callback function. To see the results, at the end of the script, let's print out the contents of this array, just before we print out the response body.
<code php>
<?php
$ch = curl_init();
$headers = [
  "Authorization: ClientID YOUR_ACCESS_KEY"
];
$header_callback = function($ch, $header) use (&$response_headers) {
  $len = strlen($header);
  $response_headers[] = $header;
  return $len;
}
 
curl_setopt_array($ch, [
  CURLOPT_URL => "https//api.unsplash.com/photos/random",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_HTTPHEADER => $headers,
  CURLOPT_HEADERFUNCTION => $header_callback
]);
$response = curl_exec($ch);
 
$status_code = curl_get($ch, CURLINFO_HTTP_CODE);
curl_close($ch);
 
echo "Status:  " . $status_code, "\n";
print_r($response_headers);
echo "Response\n" . $response, "\n";
</code>
When we run this, we get an array containing each individual response header as a string. Each header is the name of the header, followed by a colon and then its value. 

If you want to separate the header name from its value in the array, first we need to split the header into parts with the colon as a separator, specifying a maximum of two parts. If there are less than two parts, then it's not a valid response header. So we'll ignore it, and just return the length. Otherwise, we'll use the first part as the array key, and the second part as the value. Let's also call trim on this to remove any surrounding whitespace. Now when we run this, the array of response headers has the header names as the array keys, and the values just contain the header value.
<code php>
<?php
$ch = curl_init();
$headers = [
  "Authorization: ClientID YOUR_ACCESS_KEY"
];
$header_callback = function($ch, $header) use (&$response_headers) {
  $len = strlen($header);
  $parts = explode(":", $header, 2);
  if (count($parts < 2)) {
    return $len;
  }
  $response_headers[$parts[0]] = trim($parts[1]); // = $header;
  return $len;
}
 
curl_setopt_array($ch, [
  CURLOPT_URL => "https//api.unsplash.com/photos/random",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_HTTPHEADER => $headers,
  CURLOPT_HEADERFUNCTION => $header_callback
]);
$response = curl_exec($ch);
 
$status_code = curl_get($ch, CURLINFO_HTTP_CODE);
curl_close($ch);
 
echo "Status:  " . $status_code, "\n";
print_r($response_headers);
echo "Response\n" . $response, "\n";
</code>
So if you **need to handle the response based on one or more of the response headers**, you have various options for processing them.

==== API requires a specific Header ====
Before we learn about the request method, we need to see how to use the [[https://docs.github.com/en/rest/activity?apiVersion=2022-11-28#starring|GitHub API]] as we'll be using this to demonstrate how request methods work. We'll be using the part of the API that lets you start a repository, which, if you're unfamiliar, is like bookmarking repositories. As with the Unsplash API, the [[https://github.com/settings/tokens|GitHub API requires an access token]], which you can generate in the Personal [[https://github.com/settings/tokens|GitHub Access Token]] section of the developer settings in your GitHub account. Before we start with the [[https://docs.github.com/en/rest/using-the-rest-api/getting-started-with-the-rest-api?apiVersion=2022-11-28#user-agent-required|GitHub API]], to keep it simple, let's just remove the response header code that we added earlier.
<code php>
<?php
$ch = curl_init();
$headers = [
  "Authorization: token YOUR_ACCESS_KEY"
];
 
curl_setopt_array($ch, [
  CURLOPT_URL => "https//api.unsplash.com/photos/random",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_HTTPHEADER => $headers
]);
$response = curl_exec($ch);
 
$status_code = curl_get($ch, CURLINFO_HTTP_CODE);
curl_close($ch);
 
echo "Status:  " . $status_code, "\n";
echo "Response\n" . $response, "\n";
</code>
Then let's change the authorization header to the format required by the [[https://docs.github.com/en/rest/activity/starring?apiVersion=2022-11-28#check-if-a-repository-is-starred-by-the-authenticated-user|GitHub API]], followed by your own token value as. We'll start by using the [[https://docs.github.com/en/rest/activity/starring?apiVersion=2022-11-28#check-if-a-repository-is-starred-by-the-authenticated-user|API to check if a repository is starred]] or not, which we do by sending a **Get request** to this endpoint **
/user/starred/{owner}/{repo}**. Substituting the owner and repo name you want to check. You can check any repository you like. For this example, I'll use the [[https://github.com/httpie/cli|http repo httpie/cli]], which just happens to be a tool we'll be using later on. So let's change the URL to this endpoint, passing in the repo owner and repo name as part of the URL.
<code php>
<?php
$ch = curl_init();
$headers = [
  "Authorization: token YOUR_ACCESS_KEY"
];
 
curl_setopt_array($ch, [
  CURLOPT_URL => "https//api.github.com/user/started/httpie/httpie",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_HTTPHEADER => $headers
]);
$response = curl_exec($ch);
 
$status_code = curl_get($ch, CURLINFO_HTTP_CODE);
curl_close($ch);
 
echo "Status:  " . $status_code, "\n";
echo "Response\n" . $response, "\n";
</code>
Let's give that a try. And we get an error message with a 403 status code request forbidden us. This is because the GitHub API requires all requests to include a **valid user agent header**, which can be your GitHub username or the name of your application. For example, There are two ways you can add this header. One is to use the array of headers we're already using for the authorization token. So let's add that and I'll set it to my GitHub username a3. Now when we run this we get a 204 status code. This corresponds to the repository being starred by my user, which as we can see it is A3. The other way to add this header is with the user agent option. And when we run this it works in the same way. So in addition to the authorization token, the GitHub API requires a user agent header which you can add using either of these methods, whichever you prefer.
<code php>
<?php
$ch = curl_init();
$headers = [
  "Authorization: token YOUR_ACCESS_KEY",
  // "User-Agent: <code php>
];
 
curl_setopt_array($ch, [
  CURLOPT_URL => "https//api.github.com/user/started/httpie/httpie",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_HTTPHEADER => $headers,
  CURLOPT_USERAGENT => "robing"
]);
$response = curl_exec($ch);
 
$status_code = curl_get($ch, CURLINFO_HTTP_CODE);
curl_close($ch);
 
echo "Status:  " . $status_code, "\n";
echo "Response\n" . $response, "\n";
</code>

==== Different Methods, same URL ====
When making a request, in addition to the headers and the URL, we can also specify a request method. These are sometimes referred to as **HTTP verbs**. Unlike the request headers, which are just metadata about the request, the method can **affect what the request does**. You will be familiar with request methods if you've used [[https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/form|forms in HTML]]. **By default, a form uses the GET method**, but you can also specify POST in the "method" attribute of the form. In addition to GET and POST, there are [[https://en.wikipedia.org/wiki/HTTP#Request_methods|other methods]] such as PUT and DELETE. Note that you can't specify these additional methods in a form in HTML, but you can when using client side [[home:js:|JavaScript]] to make [[home:js:ajax:|Ajax]] requests, and of course, when using [[https://curl.se/|cURL]] from [[home:php|PHP]], as we'll see in a moment. We just learned how to use the GitHub API to check if a repository has been starred or not. However, we can also use the API to change this status. To remove a star from a repository, or to add it. Note that the endpoint URL is exactly the same for all of these actions - to check if a repository is starred, to remove it, or to add it. What differs is the method used in the request. 

The default request method is GET, which is why we haven't been setting this until now that's all we've needed to use. To change the request method, we specify the [[https://curl.se/libcurl/c/CURLOPT_CUSTOMREQUEST.html|CURLOPT_CUSTOMREQUEST]] option, setting it to the method we want, in this case DELETE. **Note** that unlike in HTML, the method has to be in uppercase, otherwise, it won't work.
<code php>
<?php
$ch = curl_init();
$headers = [
  "Authorization: token YOUR_ACCESS_KEY",
  // "User-Agent: <code php>
];

curl_setopt_array($ch, [
  CURLOPT_URL => "https//api.github.com/user/started/httpie/httpie",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_HTTPHEADER => $headers,
  CURLOPT_USERAGENT => "robing",
  CURLOPT_CUSTOMREQUEST => "DELETE"
]);
$response = curl_exec($ch);
 
$status_code = curl_get($ch, CURLINFO_HTTP_CODE);
curl_close($ch);
 
echo "Status:  " . $status_code, "\n";
echo "Response\n" . $response, "\n";
</code>
Let's try that, and we get a 204 status code, which means it worked and if we refresh the page in the browser, we can see that it's no longer starred. Let's change the code again to add a star back to the repository. Again, we don't need to change the endpoint URL, just the method. This time, we'll change it to PUT, making sure it's in uppercase. Let's run that again, we get the 204 success status code, and in the browser, we can see that the repository has been starred again.
<code php>
<?php
$ch = curl_init();
$headers = [
  "Authorization: token YOUR_ACCESS_KEY",
  // "User-Agent: <code php>
];

curl_setopt_array($ch, [
  CURLOPT_URL => "https//api.github.com/user/started/httpie/httpie",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_HTTPHEADER => $headers,
  CURLOPT_USERAGENT => "robing",
  CURLOPT_CUSTOMREQUEST => "PUT"
]);
$response = curl_exec($ch);
 
$status_code = curl_get($ch, CURLINFO_HTTP_CODE);
curl_close($ch);
 
echo "Status:  " . $status_code, "\n";
echo "Response\n" . $response, "\n";
</code>
So just by changing the request method, we can carry out different actions. The GET method will retrieve if the repository is starred or not, **DELETE will unstar a repository**, and **PUT will star a repository**.

These three different methods do different things with the same endpoint URL. This is a key part of RESTful APIs, which we'll learn about later on.

==== Add a payload to send data with a request ====
In addition to the response body, we can also send a body or payload with the request. This is in fact what happens when a regular HTML form sends a post request. The data from the form goes in the request body. To demonstrate this, we'll continue to use the [[https://docs.github.com/en/rest/repos?apiVersion=2022-11-28#create-a-repository-for-the-authenticated-user|GitHub API]], this time working with the authenticated user's repositories. To create a new repository, we send a post request to this endpoint. To specify the parameters for the new repository, like the name, description and so on, we need to send them in the body of the request.

So let's change the URL we're sending the request to to this endpoint **/user/repos**. Then we'll change the request method used to POST. To specify the body of the request, first, let's create an array containing two elements the name of the repository, and its description. The API requires this data to be JSON encoded, so we'll call the json_encode function on that array. To attach this data to the request, we use the [[https://curl.se/libcurl/c/CURLOPT_POSTFIELDS.html|CURLOPT_POSTFIELDS]] option, assigning its value to the JSON-encoded data. Before we run this, we'll have a look at the list of my current repositories, which is here.
<code php>
<?php
$ch = curl_init();
$headers = [
  "Authorization: token YOUR_ACCESS_KEY",
];

$payload = json_encode([
  "name"=> Create from API,
  "description" => "an example API-create repo"
]);

curl_setopt_array($ch, [
  CURLOPT_URL => "https//api.github.com/user/repos",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_HTTPHEADER => $headers,
  CURLOPT_USERAGENT => "robing",
  CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POSTFIELDS => $payload
]);
$response = curl_exec($ch);
 
$status_code = curl_get($ch, CURLINFO_HTTP_CODE);
curl_close($ch);
 
echo "Status:  " . $status_code, "\n";
echo "Response\n" . $response, "\n";
</code>
Let's run the script and we get a **201 created success code**, along with the details of the repository that was created. And in the browser, if we refresh the list, there's the new repository, with the name and the description set to the values we sent with the API call. When we make this request, we're explicitly setting the request method to POST. There is another way to do this, and that's to set the POST option to true. This will also set the request method to POST. Having said that, by setting the [[https://curl.se/libcurl/c/CURLOPT_POSTFIELDS.html|CURLOPT_POSTFIELDS]] option as we're doing to attach the payload, this automatically sets the request method to POST, so it's not actually necessary to explicitly set the request method in this instance, although you can if you prefer.
<code php>
<?php
$ch = curl_init();
$headers = [
  "Authorization: token YOUR_ACCESS_KEY",
];

$payload = json_encode([
  "name"=> Create from API,
  "description" => "an example API-create repo"
]);

curl_setopt_array($ch, [
  CURLOPT_URL => "https//api.github.com/user/repos",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_HTTPHEADER => $headers,
  CURLOPT_USERAGENT => "robing",
  // CURLOPT_CUSTOMREQUEST => "POST",
  CURLOPT_POST => true,
  CURLOPT_POSTFIELDS => $payload
]);
$response = curl_exec($ch);
 
$status_code = curl_get($ch, CURLINFO_HTTP_CODE);
curl_close($ch);
 
echo "Status:  " . $status_code, "\n";
echo "Response\n" . $response, "\n";
</code>
So as we've just seen in this section, the request isn't just a URL. It also consists of headers, a method and an optional body. Likewise, the response isn't just a body, which could in fact be empty. We also obtain a status code and headers when we receive a response.

===== REST and RESTful API =====

Now we know how each HTTP requests work, we can learn about REST and RESTful APIs. This is what we'll be doing in this section. Most web APIs are RESTful, which means they follow a set of rules known as **representational state transfer**, or [[https://en.wikipedia.org/wiki/REST|REST]]. **[[https://roy.gbiv.com/pubs/dissertation/rest_arch_style.htm|REST is a set of rules for how to structure an application]]**. The basic idea of REST is treating objects on the server as resources that can be created, updated or destroyed. For example, rows in a database table. Unlike a regular web application, these actions are carried out using a combination of specific URLs and HTTP methods. For example, let's say you have a **product database** and you want to create a RESTful API to access it. **Resources are best thought of as nouns such as user, post, article and so on**.

So in this case, **"product" would be a resource**. To get a list of all products, the RESTful way to do it would be to make a **GET request to /products**. Each **resource has a unique identifier**, which can be a name or a number, so to get to an **individual product, you make a request to /products, followed by a slash, and the ID of the product**. So far, the same as a regular web application. Now though, we **start to make the requests different by using different request methods**. To create a new product, you make a POST request to /products, with the **data for the new product in the body of the request**.
^ **Method** ^ **URL** ^
| GET | /products |
| GET | /products/123 |
| POST | /products |
| PUT or PATCH | /products/123 |
| DELETE | /products/123 |
Note that this is the same URL as above used for retrieving a list of products. Only the request method has changed. Likewise, to **update an existing product**, you send a **request to the URL that contains an ID**, but instead using the **PUT or PATCH method**. And to **delete an existing product**, a request to the **same URL, but using the DELETE method**. 

**Note** that to do all this, we only need two URLs: one for a collection of resources, and one for individual ones. __**These URLs refer to resources, not actions**__. The action is taken care of using the HTTP method. So for example, **/products/add would not be a restful URL because it uses the URL to describe the action**. These are the endpoints a RESTful API would have for manipulating product data on the server. Any other resources would follow the same pattern. So when designing a RESTful API, all you basically need to do is to identify the resources, then the URLs to manipulate these resources follow on naturally. So when someone refers to a REST API, generally what they mean is the API uses RESTful URLs like these for retrieving, updating and deleting data.

==== Access RESTful APIs in PHP with cURL ====
In the previous section, we used the GitHub API, which is a RESTful API. For example, if we look at the [[https://docs.github.com/en/rest/gists?apiVersion=2022-11-28|documentation for gists]], to get a list of gists, we send a GET request to /gists/{gist_id}. To get an individual gist, we send a GET request to /gists, followed by the ID of the [[https://docs.github.com/en/rest/gists/gists?apiVersion=2022-11-28#get-a-gist|individual gist]]. To update a gist, we send a PATCH request to the same URL /gists/{gist_id}, and so on.

In this case, the gist is the resource. In other parts of the API, there are equivalent endpoints for other resources, such as repositories, users and so on. Let's look at an example using both URLs the one for collections, and the one for individual resources. We'll start with this script, which you'll be familiar with. We initialise a cURL session, then set the various options we need: the [[https://curl.se/libcurl/c/CURLOPT_URL.html|CURLOPT_URL]], [[https://php.watch/codex/CURLOPT_RETURNTRANSFER|CURLOPT_RETURNTRANSFER]], which returns the response as a string, and the required User-Agent string. We send the request, retrieving the response into this variable, and then we close the cURL session. In the [[https://docs.github.com/en/rest/gists/gists?apiVersion=2022-11-28#list-gists-for-the-authenticated-user|list of gists]], the data returned includes a lot of properties, but to keep it simple, let's just print out the ID and the description. So first, let's decode the JSON response into an associative array. Then we'll loop around that array, and print out the ID, a hyphen as a separator, the description, and a new line character.
<code php>
<?php
$ch = curl_init();
 
curl_setopt_array($ch, [
  CURLOPT_URL => "https//api.github.com/gists",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_USERAGENT => "robing",
]);
$response = curl_exec($ch);
curl_close($ch);
$data = json_decode($response, true);
foreach ($data as $gist) {
  echo $gist["id"], " - ", $gist["description"], "\n";
}  
</code>
When we run this, we get a list of gist IDs and their descriptions, some of which are empty. **Note** that we only get 30 results, as this is the default number of gists per page, but you can change this by passing in a different value in the query string. Let's pick one of these IDs, and copy it. Now we can use the endpoint to get the data about an individual resource. To do that, we add the ID to the end of the URL. Then, instead of leaping around the results, we just print out the whole array. 
<code php>
<?php
$ch = curl_init();
 
curl_setopt_array($ch, [
  CURLOPT_URL => "https//api.github.com/gists/0f820ccb870c31aa232668bd4f5f5ccab6",
  CURLOPT_RETURNTRANSFER => true,
  CURLOPT_USERAGENT => "robing",
]);
$response = curl_exec($ch);
curl_close($ch);
$data = json_decode($response, true);
/*
foreach ($data as $gist) {
  echo $gist["id"], " - ", $gist["description"], "\n";
} 
*/
print_r($data); 
</code>
When we run this, we get all the details about that particular gist. These endpoints require the HTTP GET method, which is the default, so we don't have to specify it. For other endpoints that require other methods, we can set it using the [[https://curl.se/libcurl/c/CURLOPT_CUSTOMREQUEST.html|CURLOPT_CUSTOMREQUEST]] option as we saw earlier. 


So accessing a RESTful API using cURL is no different to any other API. Basically, it's just a matter of specifying the URL and the request method.

==== Guzzle HTTP client for OOP API ====
So far, we've looked at two ways to access an API using PHP: the [[https://www.php.net/manual/en/function.file-get-contents.php|file_get_contents]] function and [[https://www.php.net/manual/en/book.curl.php|cURL]].  **cURL is fairly straightforward to use, and is usually installed by default**.

However, **it doesn't produce very readable code, and it certainly isn't object oriented**. A popular alternative is [[https://docs.guzzlephp.org/en/stable/|Guzzle]]. **Guzzle is a PHP HTTP client that makes working with APIs very simple**, with easy to read object-oriented code. **Note** that by default,** Guzzle does use cURL, so you still need to have that installed**. But as I just said, it's likely that you already have it installed. To use Guzzle, first we need to install the package and its dependencies. The recommended way to do this is using Composer on the command line.
<code bash>
composer require guzzlehttp/guzzle
</code>
Once installed, first we need to require the various package classes. The simplest way to do this is just to include Composer's autoloader. Then we create a Guzzle Client object, which is in the GuzzleHttp namespace. As an example, let's make a request to the GitHub API, as we did in the previous section. To make a request, we call the request method on the Client object, **first passing in the method we want to use**, in this case GET, and **then the URL of the endpoint**. In the optional third argument, we can **pass in headers in an array**. Remember that for this request, the GitHub API requires two headers
  * first, the authorization header, set to the access token we used earlier, 
  * then the User-Agent header. 
Calling this method returns a Response object, so we'll assign that to a variable. To get the details of the response, we can call various methods on this object. For example, to get the status code, we call the getStatusCode method. Let's print that out, followed by a newline character. Headers can be accessed in a similar way. For example, let's get the Content-Type header, which will be an array just in case there are multiple headers with the same value. So we'll just get the first element of that array. Again, we'll print that out, followed by a newline character. To get the response body we call the getBody method. This will be quite a long string of JSON, so let's use the substr function to just print out the first 200 characters of this, followed by an ellipsis just so that we can see that it worked. When we run this, we see the 200 response code, the Content-Type header, which is application/json, and the first 200 characters of the JSON in the response body.
<code php>
<?php
require __DIR__ . "/vendor/autoload.php";
$client = new GuzzleHTTP\Client;
$response = $client->request("GET", "https//api.github.com/user/repos", [
  "headers" => [
    "Authorization" => "token YOUR_TOKEN",
    "User-Agent" => "robing"
  ]
]);

echo $response->getStatusCode(), "\n";
echo $response->getHeader("content-type")[0], "\n";
echo substr($response->getBody(), 0, 200), "...\n";
</code>
As you can see, having request and response objects along with clearly named methods like this makes the code much more readable than the cURL equivalent. To change the HTTP method used, you simply change the first argument to the request method. Alternatively, there are some [[https://docs.guzzlephp.org/en/stable/quickstart.html#sending-requests|magic methods like get, delete, patch]] and so on, which will do the same thing. There are many options available when making a request. For example, to [[https://docs.guzzlephp.org/en/stable/request-options.html#body|add a request body]], we simply include it in the third argument when we call request. As for working with headers, there are convenience methods like [[https://docs.guzzlephp.org/en/stable/psr7.html#accessing-headers|hasHeader]] to see if a request or response contains a certain header. And you can get individual headers as we just did, or an array containing all of them with the getHeaders method. As you can see, the official documentation is comprehensive and very clear.

So **Guzzle is another alternative to accessing APIs using PHP, which makes the code simpler and easier to read**.

=== SDK Usage ===
Using the [[https://www.php.net/manual/en/function.file-get-contents.php|file_get_contents]] function, [[https://www.php.net/manual/en/book.curl.php|cURL]] and [[https://docs.guzzlephp.org/en/|Guzzle]] all use HTTP requests to access the API directly. There is however another alternative to accessing some APIs, and that's to use a [[https://aws.amazon.com/sdk-for-php/||software development kit or SDK]]. **An SDK is a set of pre-written components in a single installable package or library**. In the context of APIs, an SDK is basically a tool that calls an API for you.  **It's a way to integrate an API into your application without having to call the API directly**. Also, an SDK could include functionality for accessing more than one API or just a limited part of an API. Not all APIs will have an SDK. It depends on the provider, and there's **no standard structure for how an SDK works**. You'll have to look at the documentation for each individual SDK. [[https://www.google.com/search?q=php+sdk|Many popular APIs have an SDK]]. Consult the API vendor to see if there is an SDK available. 

For this example, we're going to use [[https://stripe.com/en-de|Stripe]], which is a service for managing online payments. They have a RESTful API along [[https://docs.stripe.com/sdks|with SDK]], so we can see how the two compare. We'll use the API and SDK to create a new [[http://stripe.com/docs/api/customers?lang?php|customer]]. Let's start with the API, using cURL. In this script, we already have the basic cURL code to make an API request to the endpoint to create a new customer, and we're printing out the response. As with other APIs that we've already seen, we need to authenticate. So let's add a variable containing an API key.
<code php>
<?php
$api_key = 'YOUR_API_KEY';
$data = [
  "name" => "Alice",
  "email" => "alice@example.com"
];

$ch=curl=init();
curl_setopt_array($ch, [
   CURLOPT_URL => 'https://api.stripe.com/v1/customers',
   CURLOPT_RETURNTRANSFER => true,
   CURL_USERPWD=> $api_key,
   CURLOPT_POSTFIELDS => http_build_query($data)
];

$response = curl_exec($ch);
curl_close($ch);

echo $response;
</code>
These can be generated in the Stripe account dashboard. Instead of a header, this particular API requires the key to be passed using HTTP basic authentication, which we do using the CURLOPT_USERPWD option. Next, let's add an array containing the data for the new customer. This will be an associative array with the customer's name and email address. There are other fields available which we could specify, but these are enough for this example. To pass this data to the API, we set the **CURLOPT_POSTFIELDS option** passing in the array of data. **This will automatically set the request method to POST**. Instead of formatting the data using JSON though, this API requires the data to be formatted as a URL-encoded query string, which we can do using the [[https://www.php.net/manual/en/function.http-build-query.php|http_build_query]] function. So finally, let's call that on the array of data we're passing in the request. In the [[https://dashboard.stripe.com/test/customers|Stripe dashboard]], the list of customers for this account is currently empty. Let's run the script, and the response is some JSON that represents the new customer record. And in the list of customers, there's the new customer record, created using the API.

Now, let's do the same thing using the SDK. First, let's install the SDK using Composer.
<code bash>
customer require stripe/stripe-php 
</code>
Then in the code, let's comment out to the cURL code. We still need the API key and the customer data, but we'll change the customer data to differentiate it in the dashboard. Then, so the classes in the SDK are loaded automatically, we'll require Composer's autoloader. Then we'll create a StripeClient object, passing in the API key as an argument. To create a new customer, we simply access the customers property of this object. Then call the create method on that, passing in the array of data. This returns an object that represents the new customer, and we can just print that out using echo. Let's run that, and we get the new customer details printed out.
<code php>
<?php
$api_key = 'YOUR_API_KEY';
$data = [
  "name" => "Bob",
  "email" => "bob@example.com"
];
require __DIR__ . "/vedor/autoload.php";

$stripe = new \Stripe\StripeClient($api_key);
$customer = $stripe->customers->create($data);
echo $customer;

/*
$ch=curl=init();
curl_setopt_array($ch, [
   CURLOPT_URL => 'https://api.stripe.com/v1/customers',
   CURLOPT_RETURNTRANSFER => true,
   CURL_USERPWD=> $api_key,
   CURLOPT_POSTFIELDS => http_build_query($data)$data
];

$response = curl_exec($ch);
curl_close($ch);

echo $response;
*/

</code>
In the [[https://dashboard.stripe.com/test/customers|list of customers]], there's the new customer record, this time created using the SDK. As you can see, the SDK code is much simpler than the API call. So **if an API has an SDK available, it will almost certainly be much easier** to use than making direct calls to the API.



===== Build a RESTful API framework =====
Now we understand how APIs work and how to use them, we can write our own RESTful API using PHP. We'll create an API to process tasks on a todo list. This is what we'll be doing in this and the next two sections. I'm going to use the Apache web server, installed locally, but you can use another server if you prefer. Details of how to install a web server are covered at the start of the course. I'm going to be developing the code in a sub folder of the web root, called "api". So let's start by creating that folder. Then we'll create a new file in here, called index.php. In here, we'll add the PHP opening tag, and for now, let's just print out a message so we can check it's working. 
<code bash>
mkdir api
echo '<?php' > api/index.php
echo 'echo "Hello User";' >> api/index.php
</code>
If we [[http://localhost/api/|open this script in a browser]], we see the message, meaning all is working properly. The URL though, contains the folder and name of the script index.php. However, in our RESTful API, we want URLs like /tasks, /tasks followed by  the ID and so on. By default, there's a direct mapping between the request URL and the file and folder on the web server. So these RESTful URLs, which don't follow this pattern won't work, as the web server doesn't know what to do with them.

==== Enable URL rewriting ====
We can change this by using the URL rewriting capability of the web server. By adding some rewrite rules to the web server configuration, we can associate each URL with whatever script we want. In Apache, we can do this with an .htaccess file. So let's create a new file in the api folder called **.htaccess**. **Note the name has to be exactly that, starting with the dot and lowercase**. In here, we'll **turn the rewrite engine on**, then add a rewrite rule that says for **any URL, run the index.php script**. At the end we'll **add the "L" flag**, which just tells the rewrite engine to stop processing. **Note this is not PHP, these are Apache configuration directives.**
<code config>
RewriteEngine On
RewriteRule . index.php [L]
</code>
Before we test this, we need to add **some rules to ignore existing files**, such as images or other assets on the same web server. This will effectively **deactivate the URL rewriting for any existing file**, **directory** or **symbolic link**. 
<code config>
RewriteEngine On
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteCond %{REQUEST_FILENAME} !-l
RewriteRule . index.php [L]
</code>
**.htaccess**

In the browser, **now we can specify whatever URL we like, and it always runs the index.php script**.

==== Front Controller ====
We saw earlier that a resource in a RESTful API has two URLs - one for a collection, and one for an individual resource. And we also decide what action to take based on the request method. **Now we're rewriting all the URLs to go through this one script, index.php**, we can do this in here. __**This is known as a front controller. This simply means that all requests are sent through one single script and the script decides what to do**__. First, let's process the URL. So instead of printing out this message, let's print out the URL. We can get this from the **REQUEST_URI element of the $_SERVER** superglobal.
<code php>
<?php
echo $_SERVER["REQUEST_URI"];
</code>
In the browser, we get the [[http://localhost/api/task?page=1|path part]] of the URL printed out - **basically everything after the hostname** like /api/task?page=1. However, this also includes the query string, which we could be using for things like pagination, for example. To remove this, we can use the **[[https://www.php.net/manual/en/function.parse-url.php|parse_url]] function**, passing in the **PHP_URL_PATH** as the second argument. **This will parse the URL and remove the query string** like ?page=1, so this will return /api/task. 
<code php>
<?php
echo parse_url($_SERVER["REQUEST_URI"];, PHP_URL_PATH);
</code>
In the browser, even though the query string is still part of the URL in the address bar, now we're just getting the path. **Note that this does include the sub folder though**. As far as the URL goes, all we're interested in is the segment that identifies the resource - in this case, "tasks" and if there is an ID or not like /api/tasks/123?page=1. So let's process this path to get these parts. First we'll assign this path to a variable instead of printing it out. Then we'll **use the explode function to split this into segments** using the **forward slash character as a separator**.
<code php>
<?php
$path = parse_url($_SERVER["REQUEST_URI"];, PHP_URL_PATH);
$parts = explode("/", $path);
print_r($parts);
</code>
Let's print that out to see what we get. In the browser, for a URL containing an ID, we get an array with four elements 
  - [0] =>
  - [1] => api
  - [2] => tasks
  - [3] => 123
If we remove the ID in the URL, then we get just three elements
  - [0] =>
  - [1] => api
  - [2] => tasks
So we're just interested in **the third element, which identifies the resource**, and **the optional fourth element, which is the ID**. So instead of printing this out, we'll create a variable called $resource, which will be the third element of this array, and one called $id, which will be the **fourth element, or if this isn't set, we'll set it to null**.
<code php>
<?php
$path = parse_url($_SERVER["REQUEST_URI"];, PHP_URL_PATH);
$parts = explode("/", $path);
//print_r($parts);
$resource = $parts[2];
$id = $parts[3] ?? null;
echo $resource, ", ", $id;
</code>
Then let's just print these out to see what we get. In the browser, we get the two values printed out, including the ID value if present, and not otherwise. In addition to the URL, we also need to take action based on the request method. Again, we can get this from the $_SERVER superglobal. 
<code php>
<?php
$path = parse_url($_SERVER["REQUEST_URI"];, PHP_URL_PATH);
$parts = explode("/", $path);
//print_r($parts);
$resource = $parts[2];
$id = $parts[3] ?? null;
echo $resource, ", ", $id;
echo $_SERVER["REQUEST_METHOD"];
</code>
So let's print that out to see what it contains. In the browser, the method used was GET. __**So using this code, we're identifying the three elements we need: the resource, in this case "tasks"; the optional ID; and the request method**__.

==== Testing the Front Controller ====
We're getting the URL and request method, and to test this up to now, we've used the browser. However, using the browser like this, we can only make GET requests. To use other request methods, we could create an HTML form to test the POST method, and write some JavaScript code that uses Ajax requests to test other methods. This would  effectively be writing a client for working with an API though, and there are already several of these available.

We've already been using [[https://www.php.net/manual/en/function.curl-exec.php|cURL]] from [[https://www.php.net/manual/en/book.curl.php|PHP]] to access various APIs. [[https://curl.se|cURL]] is also available on the command line.
It is installed by default on most desktop operating systems, but you can download it for free from [[https://curl.se/download.html|here]] if you don't already have it. **To make a GET request in cURL, you just call the curl command followed by the URL**. 
<code bash>
curl https://localhost/api/tasks
</code>
This will request the URL and print out the body of the response, just like we saw in the browser.** To use a different request method, we specify the --request option**, for example, using the PATCH method. 
<code bash>
curl https://localhost/api/tasks --request PATCH
</code>
You can abbreviate this option to -X if you prefer. 
<code bash>
curl https://localhost/api/tasks -X PATCH
</code>
If you prefer a graphical user interface, **an alternative to [[https://curl.se|cURL]] is [[https://www.postman.com/downloads/|Postman]]**. This is available for all operating systems. You can download this and run it locally, or use the browser-based version. Instead of working on the command line, you specify the URL, request method, headers and so on using a GUI. Another alternative is **[[https://httpie-io|HTTPie]]**, which, like [[https://curl.se|cURL]], is a command-line tool. **[[https://httpie-io|HTTPie]] is more user friendly** than [[https://curl.se|cURL]] though, and is specifically designed with API development in mind. To install [[https://httpie-io|HTTPie]], just follow the instructions for your particular operating system. Once installed, to use [[https://httpie-io|HTTPie]] on the command line, we simply enter the "http" command, followed by the URL. 
<code bash>
http https://localhost/api/tasks
</code>
**GET is the default method**, so we don't need to specify it. To **specify another request method, we simply include it before the URL**. 
<code bash>
http patch https://localhost/api/tasks
</code>
As you can see, in addition to the response body, the headers are also shown, highlighted in different colours. **All these API clients are cross-platform and free**. On this course, I'm going to use [[https://httpie-io|HTTPie]], as it's simpler than [[https://curl.se|cURL]] and more lightweight than [[https://www.postman.com/|Postman]]. As far as the course content is concerned though, it doesn't matter. So feel free to use whichever you prefer.

==== Set the HTTP status code ====
When we make a request to our API, the status code of the response, is 200, which means the request was successful. 
<code bash>
http http://localhost/api/taskd
</code>
This request was for /tasks. At the moment, we're not checking the path of the URL, so any request will be successful. We're going to develop an API for managing tasks on a to-do list, so only two URLs are needed: /tasks and /tasks followed by an ID. **Any other URL should return a 404 status code**. So once we've extracted the resource segment out of the URL, if this doesn't equal "tasks", we can set the status code to 404.
<code php>
<?php
$path = parse_url($_SERVER["REQUEST_URL"], PHP_URL_PATH);
$parts = explode("/", $path);
$resource = $parts[2];
$id = $parts[3] ?? null;
//echo $resource, ", ", $id;
//echo $_SERVER["REQUEST_METHOD"], "\n";
if ($resource != "tasks") {
  header ("{$_SERVER['SERVER_PROTOCOL']} 404 Not Found");
  exit;
}
</code>
There are two ways we can do this. The first is to set the **response header containing the status code using the [[https://www.php.net/manual/en/function.header.php|header function]]**. Note that the status code header contains the **HTTP version, in this case 1.1, the status code itself, and some status text**, which is also known as a reason phrase, which we'll get to in a moment. So let's call the header function, passing in a string with the HTTP version, the status code and the **reason phrase**. My server is using HTTP 1.1, so this is the version of HTTP that I'll pass in. If you don't want to hardcode this, you can get it from the **SERVER_PROTOCOL element of the $_SERVER superglobal**. Then we'll exit from the script, as there's no need to continue processing if the [[http://localhost/api/failtasks|URL is incorrect]]. Let's try that with a URL that doesn't match our task API. And we get the 404 not found status code.
<code bash>
http http://localhost/api/failtasks
</code>
For a [[http://localhost/api/tasks|valid URL]], we continue to get the 200 status code. 
<code bash>
http http://localhost/api/tasks
</code>
The second option is to use the **[[https://www.php.net/manual/en/function.http-response-code.php|http_response_code function]]**. This sets the reason phrase automatically from a hardcoded list in the PHP source code. So instead of writing the header directly, we **just call the http_response_code function**, passing in 404 as the code we want.
<code php>
<?php
$path = parse_url($_SERVER["REQUEST_URL"], PHP_URL_PATH);
$parts = explode("/", $path);
$resource = $parts[2];
$id = $parts[3] ?? null;
//echo $resource, ", ", $id;
//echo $_SERVER["REQUEST_METHOD"], "\n";
if ($resource != "tasks") {
  // header ("{$_SERVER['SERVER_PROTOCOL']} 404 Not Found");
  header_response_code (404);
  exit;
}
</code>
[[https://localhost/api/failtasks/|Let's try]] that, and we get the 404 status code along with the Not Found recent phrase. 
<code bash>
http https://localhost/api/failtasks
</code>
If you really want to change the reason phrase, then you'll have to set the status code using the header function. However, these reason phrases aren't really meant for the client anyway, and **in HTTP 2, they're not actually supported**. If you want to **return details about the response, the best place to do it is in the response body**, as we'll see later on. So the **recommended way to set the status code is to use the http_response_code function**. **We don't need to call this to set the 200 status code, as this is the default**. Note that we're only developing an API for task resources. **If you have other resources you want to deal with in here, you'll need additional processing in here, or alternatively, you could use a third-party router to process the URL**. For the purposes of the course, we'll keep it simple, and just have an API for tasks.

==== Add a controller class ====
Now we've isolated the parts of the URL we need, and the request method, we can process the request. **Rather than do this in here in the front controller, let's add a separate class to do this**. First, we'll create a folder to store classes, called "src". Then we'll create a new file in here. This will be controlling the interaction with task resources, so we'll call it **TaskController.php**. In this new file, we'll add the opening PHP tag, and the class definition, **matching the class name to the file name**. This is **important later on for autoloading**. I won't use a namespace in order to keep it simple, but feel free to add one if you like. Then let's add a new public method called processRequest. Remember, we're going to do different things based on the request method and the URL - 
whether the URL includes an ID or not. So let's pass two arguments to this method - the first being the request method, then the ID. 
<code php>
<?php

class TaskController
{
  public function processRequest($method, $id) 
  {
  
  }
}
</code>
**File: ./src/TaskController.php**

Back in the front controller, let's call this method. First, let's load the file the class is in, which for now, we'll do using require. We'll use the **dirname function and __DIR__ constant to get the parent folder** of the current folder so that this will be an absolute path. This is the safest way to require a file, as **relative paths might not always work in all PHP configurations**. Then we'll create a new object of the class, and **call the processRequest method**. The first argument is the request method, which we can get directly from the $_SERVER global. The next argument is the ID, which we're creating up here. If the ID isn't set, we're assigning the variable a value of null. 
<code php>
<?php
$path = parse_url($_SERVER["REQUEST_URL"], PHP_URL_PATH);
$parts = explode("/", $path);
$resource = $parts[2];
$id = $parts[3] ?? null;
//echo $resource, ", ", $id;
//echo $_SERVER["REQUEST_METHOD"], "\n";
if ($resource != "tasks") {
  // header ("{$_SERVER['SERVER_PROTOCOL']} 404 Not Found");
  header_response_code (404);
  exit;
}

require dirname(__DIR__) . "/src/TaskController.php";
$controller = new TaskController;
$controller->processRequest($_SERVER['REQUEST_METHOD']], $id);
</code>
**File: ./index.php**

So in this method in the controller, we can check for this. If the ID is null, the URL is the one for collections, i.e. the one that doesn't contain an ID. So we need to act based on the request method. If it's GET, we want to retrieve a list of tasks. For now, we'll just print out a message. If the method is POST, we want to create a new task, and again, we'll just print out a message. If the idea isn't null, we're dealing with an existing task. This time, let's add a switch statement to decide what to do, based on the method. If it's GET, we want to show the task with that ID. For editing resources, we'll specify the PATCH request method. So if it's PATCH, we'll update that task. Finally, if it's DELETE, we'll delete that task.
<code php>
<?php

class TaskController
{
  public function processRequest($method, $id) 
  {
     if ($id === null) {
       if ($method == "GET") {
         echo "index";
       } elseif ($method == "POST") {
         echo "create";
       }    
     } else {
        switch ($method)
        case "GET":
          echo "show $id";
          break;
        case "Patch":
          echo "update $id";
          break;
        case "DELETE":
          echo "delete $id";
          break;             
     }
  }
}
</code>
**File: ./src/TaskController.php**

Before we test this, let's remove these lines where we're printing out the resource and method at the top of the front controller, as we no longer need them.
<code php>
<?php
$path = parse_url($_SERVER["REQUEST_URL"], PHP_URL_PATH);
$parts = explode("/", $path);
$resource = $parts[2];
$id = $parts[3] ?? null;
//echo $resource, ", ", $id;
//echo $_SERVER["REQUEST_METHOD"], "\n";
if ($resource != "tasks") {
  // header ("{$_SERVER['SERVER_PROTOCOL']} 404 Not Found");
  header_response_code (404);
  exit;
}

require dirname(__DIR__) . "/src/TaskController.php";
$controller = new TaskController;
$controller->processRequest($_SERVER['REQUEST_METHOD']], $id);
</code>
**File: ./index.php**

[[http://localhost/api/tasks|Let's give that a try]]. If we make a GET request to /tasks, we get the index method printed out in the response body. 
<code bash>
http http://localhost/api/tasks
</code>
If we send a POST request to the same URL, it says create. 
<code bash>
http post http://localhost/api/tasks
</code>
Let's add an ID to the URL. and change it to a GET request, and we get the message to show the resource with that ID. 
<code bash>
http http://localhost/api/tasks/123
</code>
With the PATCH method it will be updated,
<code bash>
http patch http://localhost/api/tasks/123
</code>
and with the DELETE method, it will be deleted.
<code bash>
http delete http://localhost/api/tasks/123
</code>
__**So the controller is deciding what to do based on the request method and if there is an ID in the URL or not.**__
==== Use Composers autoloader ====
In the front controller, we're explicitly loading the file where the TaskController class is defined, using the  require statement. As we'll be adding more classes and therefore more files to the project, it will be simpler to load these automatically. We could do this by registering an **auto loader using the [[https://www.php.net/manual/en/function.spl-autoload-register.php|spl_autoload_register function]]**, but it's simpler to use, **[[https://getcomposer.org/doc/01-basic-usage.md#autoloading|Composer's autoloader]]**. To do this, first let's create a new **file called composer.json**. Note we're **creating this file in the root, not in the API folder**. In here, let's add an "autoload" field, then inside there, a "psr-4" field, and in there, a key of an empty string, and the value of the "src" folder. **This means that the autoloader will try and load classes from the src folder**. PSR-4 autoloading simply means that classes are loaded automatically when the **file name matches the class name**, which is why **we created the TaskController class in a file called TaskController.php**, making sure that the case matches. 
<code json>
{
  "autolad": {
    "psr-4": {
       "": "src/"
    }
  }
}
</code>
**File: ./composer.json**

To generate the autoload script, on the command line in the same folder as the **composer.json file**, we run the **composer dump-autoload** command. This generates an autoload.php script in the vendor folder.
<code bash>
composer dump-autoload
</code>
**Note that you never need to edit this file and the files it includes directly** - they're generated automatically by Composer whenever you run the dump-autoload command. To use this, at the top of the front controller, we'll require the file using the dirname function and __DIR__ constant as we did below. Now we can remove the line where we're requiring the controller class. 
<code php>
<?php
require dirname(__DIR__) . "/vendor/autoload.php";
$path = parse_url($_SERVER["REQUEST_URL"], PHP_URL_PATH);
$parts = explode("/", $path);
$resource = $parts[2];
$id = $parts[3] ?? null;
//echo $resource, ", ", $id;
//echo $_SERVER["REQUEST_METHOD"], "\n";
if ($resource != "tasks") {
  // header ("{$_SERVER['SERVER_PROTOCOL']} 404 Not Found");
  header_response_code (404);
  exit;
}

//require dirname(__DIR__) . "/src/TaskController.php";
$controller = new TaskController;
$controller->processRequest($_SERVER['REQUEST_METHOD']], $id);
</code>
**File: ./index.php**

[[http://localhost/api/tasks|Let's try making a request again]], and it still works as before. 
<code bash>
http http://localhost/api/tasks
</code>
Now though, this class is being loaded automatically, which will also work for any other class we add to the src folder in the same way.
==== Make debugging easier ====
In the TaskController class, we have the processRequest method, which has two arguments: the request method, and the resource ID. In the interests of good coding practices, and to help us debug the code more easily, let's add [[https://www.php.net/manual/en/language.types.declarations.php|type declarations]] to the method arguments and its return value. The method argument will be a string, as will the id. Even if this id is numeric, it's still coming from the URL, so it will be a string. For now, we're not returning anything from this method, so we'll declare its return value as void.
<code php>
<?php
 
class TaskController
{
  public function processRequest(string $method, string $id): void
  {
</code>
**File: ./src/TaskController.php (partial)** 

In the front controller, let's enable strict type checking with the declare statement, **setting the strict_types declaration to 1**. Note that this has to be the first statement in the script. This is optional, but I find if you're going to use type declarations, you might as well make them strict. __**As all requests are going through this script, this setting will be applied globally.**__
<code php>
<?php
declare/strict_types=1);
require dirname(__DIR__) . "/vendor/autoload.php";
$path = parse_url($_SERVER["...
</code>
**File: ./index.php (partial)** 

Let's request the endpoint to get the details of an individual resource. And this continues to work as before with no problems.
<code bash>
http http://localhost/api/tasks/123
</code>
However, if I try to get the index of tasks, in the body of the response, we get an error.
<code bash>
http http://localhost/api/tasks/
</code>
If you're following along and you don't see this error, it could be that PHP isn't configured to display errors. This is controlled by the [[https://www.php.net/manual/en/errorfunc.configuration.php#ini.display-errors|display_errors option]] in the **PHP configuration file**. You need to set this to the string "on". If you don't have access to the configuration file to change this setting, **you can do it in code with ini_set function, setting display_errors to "on"**.
<code php>
<?php
declare/strict_types=1);
ini_set("display_errors", "on");
require dirname(__DIR__) . "/vendor/autoload.php";
$path = parse_url($_SERVER["...
</code>
If we look at the error message, we can see the error is occurring because the second argument to the processRequest method is expected to be a string, but null was given. If there's no ID in the URL, the ID variable is set to null. We can mark the type declaration on the ID argument as a nullable by prefixing it with a question mark. 
<code php>
<?php
 
class TaskController
{
  public function processRequest(string $method, ?string $id): void
  {
</code>
Now when we make the request, the error has gone and it works as expected. 
<code bash>
http http://localhost/api/tasks/
</code>
If we try it with an ID, this also still works. 
<code bash>
http http://localhost/api/tasks/123
</code>
With type declarations and strict type checking enabled, finding bugs will be easier and the code will be more readable.
==== Always return JSON ====
In the previous video, we saw an error message when the type declaration for this argument wasn't nullable. Let's remove this question mark temporarily so we can reproduce this. And when we make the request again, there's the error. **By default, the details of the error are formatted with HTML tags**, as it's assumed that this will be being viewed in a browser. However, as this is an API, this isn't the case. **We'll be accessing the API using code, or a tool like [[https://httpie.io/|HTTPie]] while we're developing it**. __**We're going to return all successful responses formatted as JSON, as this is the de facto standard**__. So we should do the same with errors and exceptions. We can define a **generic exception handler using the [[https://www.php.net/manual/en/function.set-exception-handler.php|set_exception_handler function]]**. This will catch all unhandled exceptions like the one we just saw, and allow us to control the output. 

We'll leave this bug we just added here in the controller for now and fix it at the end. Instead of writing the **error handling code here in the front controller**, let's put it in a separate class. So let's create a new file in the src folder, called **ErrorHandler.php**. In here, we'll add the PHP opening tag and the class definition to match the file name, so that the PSR-4 autoloading we configured earlier works. In here, we'll add a **public static method called handleException**. This has one argument which is an object of the [[https://www.php.net/manual/en/class.throwable.php|Throwable class]], which we'll call $exception. This doesn't return anything, so we'll type hint it has void. The [[https://www.php.net/manual/en/class.throwable.php|Throwable class]] is the base for all errors and exceptions thrown in PHP, so we have access to various methods to get details about the error. So in the body of the exception handler, we'll output some JSON, passing the json_encode function an array containing a "code" element, which is the code of the exception, and likewise, a "message" element, a "file" element, which is the path of the file where it occurred, and a "line" element for the line number.
<code php>
<?php

class ErrorHandler
{
  public static function handleException(Throwable $exception): void
  {
    echo json_encode([
      "code" => $exception->getCode(),
      "message" => $exception->getMessage(),
      "file" => $exception->getFile(),
      "line" => $execption->getLine()
  }
}
</code>
**File: ./src/ErrorHandler.php**

You can add more details to this if you like, but I'll keep it simple and just provide these details. To enable this in the front controller, we call this [[https://www.php.net/manual/en/function.set-exception-handler.php|set_exception_handler function]], passing in the class and method name of the handler we just added.
<code php>
<?php
declare(strict_types=1);
//init_set("display_errors", "on");
require dirname(__DIR__) . "/vendor/autoload.php";
set_exception_handler("ErroroHandler::handlerException");

$path = parse_url($_SERVER["REQUEST_URL"], PHP_URL_PATH);
$parts = explode("/", $path);
$resource = $parts[2];
$id = $parts[3] ?? null;
//echo $resource, ", ", $id;
//echo $_SERVER["REQUEST_METHOD"], "\n";
if ($resource != "tasks") {
  // header ("{$_SERVER['SERVER_PROTOCOL']} 404 Not Found");
  header_response_code (404);
  exit;
}
 
$controller = new TaskController;
$controller->processRequest($_SERVER['REQUEST_METHOD']], $id);
</code>
**File: ./index.php**

[[http://localhost/api/tasks|Let's give that a try]], repeating the same request, and now the body of the request contains the details about the error in JSON format. **Note that we didn't need to explicitly require the file containing the ErrorHandler class** - this was loaded automatically by the autoloader we configured earlier. If we look at the response headers, we can see the status code is 200, which is incorrect as this response isn't OK, and the Content-Type is still shown as text/html. To fix the Content-Type, let's add the Content-Type header to the front controller. All response bodies in our API will be formatted using JSON so we can safely put it in here and it will apply to all requests. We do this using the header function, setting the Content-Type to application/json. We'll also include the character set, which is UTF-8. Note the hyphen, and also that I've put it in uppercase. **This is case insensitive, but the de facto standard is to put it in capitals**. As for the status code, in the error handler, let's set it to 500, which means a generic server error, using the [[https://www.php.net/manual/en/function.http-response-code.php|http_response_code function]].
<code php>
// ...
  header_response_code (404);
  exit;
}
header("Content-type: application/json; charset=UTF-8");
$controller = new TaskController;
$controller->processRequest($_SERVER['REQUEST_METHOD']], $id);
</code>
**File: ./index.php**

Now if we make the request again, we get a 500 internal server error status code, and the JSON content type. **Note that you probably don't want to output all these details like this in a production environment**. Instead, you'd probably log these details and output a generic error message here. This is beyond the scope of the course though, so we'll keep it simple and just output these basic error details.
<code php>
<?php

class ErrorHandler
{
  public static function handleException(Throwable $exception): void
  {
    http_response_code(500);
    echo json_encode([
      "code" => $exception->getCode(),
      "message" => $exception->getMessage(),
      "file" => $exception->getFile(),
      "line" => $execption->getLine()
  }
}
</code>
**File: ./src/ErrorHandler.php**

Now we've configured the error handler, we can remove the error from the task controller that we introduced at the start of the section, and make this type declaration nullable again.

==== Allow header for invalid request methods ====
In the task controller, we're outputting the response based on the request method, and if the URL contains an ID or not. Some actions will be different for the same URL, but with a different method. For example, a GET request to /tasks will return the list of tasks, whereas a POST request to the same URL will create a new task resource. However, what happens if we use a different request method with this URL, for example DELETE. We get a 200 status code, but no response body. There's no body because we're only outputting something if it's a GET or a POST request. These are the only two valid request methods for this URL.

In fact, if any other request method is used, it's an invalid request and we should send an appropriate status code. The one to send is [[https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/405|405: method not allowed]]. When we send this status code, we must also send an "Allow" header field that lists the methods that are allowed on this resource. This header is simply called "[[https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Allow|Allow]]", followed by a comma-separated list of the HTTP methods that are allowed, in uppercase. So let's add an else statement to this if, then we'll call the http_response_code function with an argument of 405. To send the header, we call the header function, and we'll allow the GET and POST methods. 
<code php>
<?php
 
class TaskController
{
  public function processRequest($method, $id) 
  {
     if ($id === null) {
       if ($method == "GET") {
         echo "index";
       } elseif ($method == "POST") {
         echo "create";
       } else {
         http_response_code(405);
         header("Allow: GET, POST");
       }   
     } else {
        switch ($method)
        case "GET":
          echo "show $id";
          break;
        case "Patch":
          echo "update $id";
          break;
        case "DELETE":
          echo "delete $id";
          break;             
     }
  }
}
</code>
**File: ./src/TaskController.php**

Now if we use an invalid method, we get the 405 status code, and the Allow header is shown with the methods that are allowed.
<code bash>
http delete http://localhost/api/tasks
</code>
Let's do the same for an individual resource. For example, let's make a POST request to the URL that contains an ID. 
<code bash>
http post http://localhost/api/tasks/123
</code>
Again, we get to 200 status code and an empty response body. To fix this, we'll send a similar response for requests like this. So we don't repeat ourselves though, first, we'll extract this code out into a separate method. So let's create a new private method called respondMethodNotAllowed, passing in a string argument of the list of allowed methods. This won't return anything, so we'll add the void return type declaration. In here, we'll copy the code we just added, and paste it in the body of the new method. In the Allow header, we'll replace these hardcoded methods with the contents of the $allowed_methods argument.
<code php>
private function responseMethodNotAllowed(string $allowed_methods): void
{
  http_response_code(405);
  header(Allow: $allowed_methods");
}
</code>
Then we can replace the older else two lines with a call to this new method, passing in GET and POST as the allowed methods. To fix the problem with an invalid request to the URL containing an ID, let's add a default block to the switch statement. In here, we'll call the new method we just added, passing in GET, PATCH and DELETE as allowed methods. 
<code php>
<?php
 
class TaskController
{
  public function processRequest($method, $id) 
  {
     if ($id === null) {
       if ($method == "GET") {
         echo "index";
       } elseif ($method == "POST") {
         echo "create";
       } else {
         $this->respondMethodNotAllowed("GET, POST");
       } 
     } else {
        switch ($method)
        case "GET":
          echo "show $id";
          break;
        case "Patch":
          echo "update $id";
          break;
        case "DELETE":
          echo "delete $id";
          break; 
        default:
          $this->respondMethodNotAllowed("GET, PATCH, DELETE");              
     }
  }
}

private function responseMethodNotAllowed(string $allowed_methods): void
{
  http_response_code(405);
  header(Allow: $allowed_methods");
}
</code>
If we repeat the POST request, now we get the 405 status code with the relevant Allow header. 
<code bash>
http post http://localhost/api/tasks/123
</code>
If we make a valid request such as GET, then it still works as before, with the status code of 200, and the response body. 
<code bash>
http get http://localhost/api/tasks/123
</code>
If we make an invalid request to the tasks URL, this gives us the 405 status as before, with the appropriate Allow header.
<code bash>
http patch http://localhost/api/tasks/
</code>
With a valid method, we get a successful response.
<code bash>
http http://localhost/api/tasks/123
</code>
====== Create a RESTful Database API ======
Now we have the basic framework of our API application set up, instead of outputting these placeholder messages from the task controller, we can manipulate some data in a database using the API. In this section, we'll learn how to read and output data from the database.

First, we'll create a database. I'll be doing this in the [[https://mariadb.com/downloads/|MariaDB]] database server that I have installed locally, which for all intents and purposes is the same as [[https://www.mysql.com/downloads/|MySQL]]. All commands shown valid for either DBMS. You'll have a similar setup if you installed the suggested software at the start of the course, although feel free to use any relational database you like. I'll be doing this on the command line, but if you prefer, you can use your GUI of choice, such as [[https://www.phpmyadmin.net/downloads/|phpMyAdmin]] or [[https://dev.mysql.com/downloads/workbench/|MySQL Workbench]].

===== Create a new database and a database user to access it =====
Let's start by connecting to the database server on the command line using the root account. 
<code bash>
mysql -uroot -p
</code>
Then we'll create a new database, which I'll just call "api_db". 
<code sql>
CREATE DATABASE api_db;
</code>
Then we'll create a user just for accessing this database, so we don't have to do it using the root account. This user will have full privileges on all the tables in the new database. I'll call the user "api_db_user", it's on the localhost server and we'll assign a random password. You need to make a note of this password for when we connect to the database later on from PHP. 
<code sql>
GRANT ALL PRIVILEGES ON api_db.* TO api_db_user@localhost IDENTIFIED BY 'k5cWTeqs6GXK2hzF';
</code>
To check this works, we can exit from the console, and reconnect using the user and password we just created. 
<code bash>
mysql -uapi_db_user -p
</code>
Then we can select the database with use, and that selects it with no problems.
<code sql>
use api_db;
</code>
===== Create a table to store resource data =====
Now we can add a table to the database to store task data. Let's create a table called "task" with the following fields: an ID field that's an integer, it can't be null, and will set this to auto increment to assign values automatically. Then a name field, which is a 128 character varchar, that can't be null. 
Next, a field called priority, which is an integer, and this can be null, with null as the default value. Finally, a field called is_completed, which is a boolean, can't be null and is false by default. We'll make the ID column the primary key, and add a non-unique index to the name column. 
<code sql>
CREATE TABLE task (
  id INT NOT NULL AUTO_INCREMENT,
  name VARCHAR(128) NOT NULL,
  PRIORITY INT DEFAULT NULL,
  is_completed BOOLEAN NOT NULL DEFAULT FALSE,
  PRIMARY KEY (id),
  INDEX (name)
);  
</code>
I've included columns of various different types so that we can see how these are encoded into JSON format later on. Let's have a look at the table we just created, and there it is. Let's view the indexes, and there they are.
<code sql>
DESCRIBE task;
SHOW INDEXES FROM task;
</code>
As mentioned before, you can do this using a GUI like phpMyAdmin if you prefer.
===== Connect to the database from PHP =====
Now we have the database set up, we can connect to it from PHP. Let's create a new class to do this, so we'll create a file in the src folder called **Database.php**. We'll add the PHP opening tag, and the class definition. When we connect to the database, we need various data like the hostname, database name and so on. We'll pass these data in when we create a new database object, so as arguments to the constructor. So let's add the constructor method and string arguments for the database host, name, username and password. You can add an argument for the database port if you're using a non-standard one as well if you need to. Next, we'll assign these values to private properties. We could declare individual properties like this for the host value, for example, and assign values to them in the body of the constructor. However, if that's all we're doing in the constructor, we can use [[https://www.php.net/manual/en/language.oop5.decon.php#language.oop5.decon.constructor.promotion|constructor promotion]] instead. This is shorthand for doing just that. If we had a visibility modifier to each property, PHP will automatically create the property and assign the value to it. So instead of declaring this property and the assigning a value to it in the body of the constructor, we just add the visibility modifier to the function arguments, which will do the same thing. We'll do this for each of the constructor's arguments.
<code php>
<?php

class Database
{
   public function __construct(
     private string $host,
     private string $name,
     private string $user,
     private string $password
   ) {
   }
}
</code>
**File: ./src/Database.php**

Next, let's add a method that will connect to the database called getConnection. I'll connect using PDO, but you can use MySQLi for example, if you prefer. First, we'll create a string variable that contains the data source name. We'll use the MySQL database driver, the host is the value of the host property, the db name the value of the name property, and will specify utf8 as the character set. Then we'll create a PDO object, passing in this variable, followed by the username and password properties. We want PDO to throw an exception when a database error occurs, so we'll set the error mode to do just that. Finally, we'll return this object from this method, so we can add a return type declaration, specifying 
a PDO object. 
<code php>
  public function getConnection(): PDO
  {
    $dsn = "mysql:host={$this->host};dbname={$this->name};charset=utf8";
    
    return new PDO($dsn, $this-user, $this->password, [
      PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION
    ]);
  }
}
</code>
**File: ./src/Database.php**

Then in the front controller, let's create a new object of the Database class, which again will be loaded automatically. Then we'll pass in values for the host, which in my case is localhost, the database name, user and password, which we created earlier in this section when we created the database.
<code php>
<?php
declare(strict_types=1);
//init_set("display_errors", "on");
require dirname(__DIR__) . "/vendor/autoload.php";
set_exception_handler("ErroroHandler::handlerException");
 
$path = parse_url($_SERVER["REQUEST_URL"], PHP_URL_PATH);
$parts = explode("/", $path);
$resource = $parts[2];
$id = $parts[3] ?? null;
//echo $resource, ", ", $id;
//echo $_SERVER["REQUEST_METHOD"], "\n";
if ($resource != "tasks") {
  // header ("{$_SERVER['SERVER_PROTOCOL']} 404 Not Found");
  header_response_code (404);
  exit;
}

header("Content-type: application/json; charset=UTF-8");
$database = new Database("localhost", "api_db", "api_db_user", "geheim");
$database->getConnection();
$controller = new TaskController;
$controller->processRequest($_SERVER['REQUEST_METHOD']], $id);
</code>
**File: ./src/Database.php**

To check we can connect to the database, ok, let's call the getConnection method on the database object. Let's check that by making a valid request using HTTPie. And we get an error, displayed as JSON, by our error handling code. This is the error you'll get if the connection details are incorrect.
<code bash>
http http://localhost/api/tasks
</code>
I actually deliberately entered the wrong password, so this would happen. If we correct this, when we make the request again, the error has gone and we get the expected response. This means the credentials are correct and we're connecting to the database successfully.

===== Connection data in .env file =====
In the front controller, we're creating a new database object and passing in the connection credentials. Having these hardcoded in here isn't a good idea, as if we check this file into source code control, the database connection details will be included. Plus, to change them, for example, when you deploy the code to a different server, you have to edit this file. Instead, we'll put these data in a separate file. There are several ways you can do this, but the simplest and most commonly used is to use a .env environment file.

Rather than write this functionality ourselves, we'll use a [[https://packagist.org/?query=dotenv|third-party package]] to do it. The most popular at the moment is [[https://packagist.org/packages/vlucas/phpdotenv|vlucas/phpdotenv]]. We can install this using Composer. 
On the command line, from the root folder of the project, not the api folder, we'll run the Composer command.
<code bash>
composer require vlucas/phpdotenv
</code>
Next, we need to create a separate file to store the database connection values - the host, name, username and password for the database. So let's create a new file, again in the root folder, not in the api folder called .env, making sure the **file name starts with a dot**. In here, we'll create a setting for the database host, the database name, the username and password. These are the values we currently have hardcoded in the front controller. **Note this isn't PHP, they're just simple key-value pairs.**
<code bash>
DB_HOST="localhost"
DB_NAME="api_db"
DB_USER="api_db_user"
DB_PASS="k5cWTeqs6GXK2hzF"
</code>
**File: ./.env**

Then, back in the index, before we connect to the database, we can load that file. We'll do this near the top, after we've enabled the exception handler. We create a Dotenv object by calling the createImmutable method of the Dotenv class in the Dotenv namespace. We're already using Composer's autoloader, so the package's classes will be loaded automatically. To this method, we pass the path of where the .env file is. It's in the parent folder of the script, which we can get by calling the dirname function, passing in the __DIR__ constant. Then we called the load method on that object. This will load the values from the .env file into the PHP $_ENV super global. So instead of passing in these hardcoded values when we create the Database object, we can pass in the values from the $_ENV superglobal. 
<code php>
<?php
declare(strict_types=1);
//init_set("display_errors", "on");
require dirname(__DIR__) . "/vendor/autoload.php";
set_exception_handler("ErroroHandler::handlerException");
$dotenv = Dotenv\Dotenv::createImmutable(dirname(__DIR__));
$dotenv->load();
$path = parse_url($_SERVER["REQUEST_URL"], PHP_URL_PATH);
$parts = explode("/", $path);
$resource = $parts[2];
$id = $parts[3] ?? null;
//echo $resource, ", ", $id;
//echo $_SERVER["REQUEST_METHOD"], "\n";
if ($resource != "tasks") {
  // header ("{$_SERVER['SERVER_PROTOCOL']} 404 Not Found");
  header_response_code (404);
  exit;
}
 
header("Content-type: application/json; charset=UTF-8");
$database = new Database($_ENV["DB_HOST"], $_ENV["DB_NAME"], $_ENV["DB_USER"], $_ENV["DB_PASS"]);
//$database->getConnection();
$controller = new TaskController;
$controller->processRequest($_SERVER['REQUEST_METHOD']], $id);
</code>
**File: ./src/Database.php**

To check this is working, let's change one of the connection settings, so it's incorrect. Let's make a request, and we get the database connection error. 
<code bash>
http http://localhost/api/tasks
</code>
If we correct this, and make the request again, now it works. Now we've checked the connection still works, we can remove this getConnection call. **Note how we're just using this third-party package for the configuration settings**. The rest of the API we'll write using plain PHP.
===== Create a Table Data Gateway class =====
Now we can connect to the database, we can use this to retrieve some data. In the task controller class, we're outputting placeholder messages for each of the API actions. Instead of working with the database directly in this class, let's create a separate class to access the task table following the table data gateway pattern - basically an object that will act as a gateway to the task table. So let's create a new file in the src folder, called TaskGateway.php.

In here, we'll add the PHP opening tag and the class definition. This class needs access to the database, so will require an object of the Database class we just added. Instead of creating one in here, we'll inject this dependency passing in an object in the constructor. So let's add the constructor method, with a single argument that's an object of the Database class. All the public methods in this class will need to connect to the database, so let's do that in the constructor. First we'll declare a private property to store the database connection, which will be a PDO object as we're using PDO, so we'll include a type declaration for that. Then in the constructor, we'll call the getConnection method on the database object and store this in the property. 
<code php>
<?php

class TaskGateway
{
  private PD= $conn;
  
  public function __construct(Database $database)
  {
    $this->conn = $database-getConnection();
  }
}
</code>
**File: ./src/TaskGateway.php**

Back in the task controller, instead of creating an object of this new class in here, we'll pass one in via the constructor and store it in a private property. So let's add the constructor method, with an argument that contains an object of the TaskGateway class. As before we'll use constructor promotion to assign this to a private property of this class, which we can do by simply prefixing this with the private visibility modifier.
<code php>
<?php
 
class TaskController
{
  public function __construct(private TaskGateway $gateway)
  {
  }
  
  public function processRequest($method, $id) 
  {
     if ($id === null) {
       if ($method == "GET") {
         echo "index";
       } elseif ($method == "POST") {
         echo "create";
       } else {
         $this->respondMethodNotAllowed("GET, POST");
       } 
     } else {
        switch ($method)
        case "GET":
          echo "show $id";
          break;
        case "Patch":
          echo "update $id";
          break;
        case "DELETE":
          echo "delete $id";
          break; 
        default:
          $this->respondMethodNotAllowed("GET, PATCH, DELETE");              
     }
  }
}

private function responseMethodNotAllowed(string $allowed_methods): void
{
  http_response_code(405);
  header(Allow: $allowed_methods");
}
</code>
**File: ./src/TaskController.php**

So when we create an object of the controller class, we need to pass in an object of the TaskGateway class. We're creating the controller object in the front controller. So before we do this, let's create an object of the TaskGateway class. Remember, this class requires a Database object in its constructor, and we're already creating an 
object of that class, so we can just pass that in. Now we can pass in the gateway object to the task controller's constructor.
<code php>
<?php
declare(strict_types=1);
//init_set("display_errors", "on");
require dirname(__DIR__) . "/vendor/autoload.php";
set_exception_handler("ErroroHandler::handlerException");
$dotenv = Dotenv\Dotenv::createImmutable(dirname(__DIR__));
$dotenv->load();
$path = parse_url($_SERVER["REQUEST_URL"], PHP_URL_PATH);
$parts = explode("/", $path);
$resource = $parts[2];
$id = $parts[3] ?? null;
//echo $resource, ", ", $id;
//echo $_SERVER["REQUEST_METHOD"], "\n";
if ($resource != "tasks") {
  // header ("{$_SERVER['SERVER_PROTOCOL']} 404 Not Found");
  header_response_code (404);
  exit;
}
 
header("Content-type: application/json; charset=UTF-8");
$database = new Database($_ENV["DB_HOST"], $_ENV["DB_NAME"], $_ENV["DB_USER"], $_ENV["DB_PASS"]);
//$database->getConnection();
$task_gateway = new TaskGateway($database);
$controller = new TaskController;
$controller->processRequest($_SERVER['REQUEST_METHOD']], $id);
</code>
**File: ./index.php**

We haven't selected any data yet, we're just setting up the structure of how this will work. Passing in dependencies like this makes each class simpler and therefore easier to maintain, and also easier to test using automated testing frameworks. Just to make sure we've wired all this up correctly, let's make a request,
<code bash>
http http://localhost/api/tasks
</code>
and this still works as before with no errors.
===== Show a list of all records =====
Now we can use the classes we just added to select some data from the database. In the task gateway class, let's add a method to get all the task records called getAll. This will return an array. Let's create a variable containing the SQL to select all the records from the task table, ordered by name, which we can do as we have an index on the name column. Then, as this is a simple SQL string that we don't have to substitute any values into, we can use the PDO query method. We previously connected to the database in the constructor, so we can simply call the query method on that object property, passing in the SQL. This will return a PDOStatement object, so to get an array of all the records we can call the fetchAll method on that, passing in the constant to fetch the data as an associative array. Finally, we'll return this method call's return value.
<code php>
<?php
 
class TaskGateway
{
  private PD= $conn;
 
  public function __construct(Database $database)
  {
    $this->conn = $database-getConnection();
  }
  
  public function getAll(): array
  {
    $sql = "SELECT * FROM task ORDER BY name";
    $stmt = $this->conn->query($sql);
    return $stmt->fetchAll(PDO::FETCH_ASSOC);
  }
}
</code>
**File: ./src/TaskGateway.php**

In the task controller, we'll call this new method when the request is for the list of tasks. So instead of printing out the index message, we'll call the getAll method on the gateway property of the class. Remember, we're assigning a gateway object to this property using the constructor. This will return an array of data, so to output this as part of the API, we'll simply encode it as JSON using the json_encode function and print it out.
<code php>
<?php
 
class TaskController
{
  public function __construct(private TaskGateway $gateway)
  {
  }
 
  public function processRequest($method, $id) 
  {
     if ($id === null) {
       if ($method == "GET") {
         //echo "index";
         echo json_encode($this->gateway->getAll());
       } elseif ($method == "POST") {
         echo "create";
       } else {
         $this->respondMethodNotAllowed("GET, POST");
       } 
     } else {
        switch ($method)
        case "GET":
          echo "show $id";
          break;
        case "Patch":
          echo "update $id";
          break;
        case "DELETE":
          echo "delete $id";
          break; 
        default:
          $this->respondMethodNotAllowed("GET, PATCH, DELETE");              
     }
  }
}
 
private function responseMethodNotAllowed(string $allowed_methods): void
{
  http_response_code(405);
  header(Allow: $allowed_methods");
}
</code>
**File: ./src/TaskController.php**

Let's give that a try. If we make a get request to the tasks endpoint, we get an empty array printed out. This is to be expected, as the table is still empty, we haven't inserted any data yet.
<code bash>
http http://localhost/api/tasks
</code>
Let's insert some records directly into the database as test data. I'll do this on the command line, but as always, you can use a GUI like phpMyAdmin if you prefer. 
<code bash>
mysql -uapi_db_user -p
</code>We'll insert into the task table, specifying the name, priority and is_completed columns. We'll leave the value for the ID column to be assigned automatically. We'll insert the values for three records, with various different values according to the column type, and if it accepts null values or not.
<code sql>
INSERT INTO task (name, priority, is_completed) VALUES
('Buy new shoes', 1, true),
('Renew Passport', 2, false),
('Paint wall', NULL, true);
</code>
That says the records were inserted OK, let's have a look at them in the task table. And we can see that values for the ID column have been assigned automatically. 
<code sql>
SELECT * FROM task;
</code>
Now we can exit from here and make the API request again.
<code bash>
http http://localhost/api/tasks
</code>
Now it shows the data from the database encoded in JSON format.
===== Configure PDO to prevent numeric values from being converted to strings =====
We just added some data to the database and displayed it encoded as JSON. However, you might have noticed that each value is displayed as a string, regardless of its data type in the database. For example, the ID and priority columns are integers, but in the JSON they're shown as strings, surrounded by quotes. According to the [[https://www.json.org/json-en.html|JSON specification]], in addition to strings, J**SON values can be numbers, boolean values and null**. So somewhere the values from the database are being converted to strings. 

The problem is not in the task controller class where we're using the [[https://www.php.net/manual/en/function.json-encode.php|json_encode function]], as this function supports these data types. Rather, this is happening when we get the data from the database. As we're using PDO, there are a couple of [[https://www.php.net/manual/en/pdo.setattribute.php|PDO attributes]] that we need to change to fix this problem. The [[https://www.php.net/manual/en/pdo.constants.php#pdo.constants.attr-emulate-prepares|EMULATE_PREPARES]] attribute controls if prepared statements are emulated or not. This is used to enable [[https://www.php.net/manual/en/pdo.prepared-statements.php|prepared statements]] for databases that don't natively support them. If this value is set to true, then it can affect how the data is returned from the database. As we're using MySQL or MariaDB, which do natively support prepared statements, we can safely set this to [[https://www.php.net/manual/en/pdo.setattribute.php#PDO::ATTR_EMULATE_PREPARES|false]].

The other setting is **[[https://www.php.net/manual/en/pdo.setattribute.php#PDO::ATTR_STRINGIFY_FETCHES|STRINGIFY_FETCHES]]**, which does exactly what we're seeing. It **converts all values to strings**. This is usually set to false, but we'll make sure of that just to be certain. We're creating the new PDO object here in the database class. Let's add these two options to the array of options we passed to the PDO constructor. First, to turn prepared statement emulation off by setting it to false, then the setting to stringify fetches to false also.
<code php>
<?php
 
class Database
{
  public function __construct(
    private string $host,
    private string $name,
    private string $user,
    private string $password
  ) {
  }

  public function getConnection(): PDO
  {
    $dsn = "mysql:host={$this->host};dbname={$this->name};charset=utf8";
 
    return new PDO($dsn, $this-user, $this->password, [
      PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
      PDO::ATTR_EMULATE_PREPARES => false,
      PDO::ATTRIB_STRINGIFY_FETCHES => false
    ]);
  }
}
</code>
**File: ./src/Database.php**

Let's give that a try. 
<code bash>
http http://localhost/api/tasks
</code> 
Now when I make the same request, the integer values for the ID and priority columns are no longer surrounded by quotes, and are shown as numbers in the JSON.
===== Convert database booleans to boolean literals in the JSON =====
We just made sure any numeric values in the database aren't converted to strings when we return them as JSON. This also includes the is_completed column, which is shown as 1 or 0. When we created the task table though, we defined this as boolean. The boolean data type in MySQL and MariaDB however, is just a synonym for a very small integer, where 1 represents true and 0 represents false. If you're happy with this representation in the JSON, and more importantly, **you document it as such so that anyone using your API knows that 1 is true and 0 is false, then you don't need to change it**. However, JSON values can also be the [[https://www.json.org/josn-en.html|boolean literals true or false]].

So we can encode these integers as booleans if we want to. __**There isn't a reliable way to do this automatically in the database code, as the data is stored in the database as a number**__. So we have to change any columns we want as boolean manually. Here in the getAll method of the task gateway class, we're fetching all the rows at once using the [[https://www.php.net/manual/en/pdostatement.fetchall.php|fetchAll method]]. Instead of this, first we'll **initialise a variable with an empty array**. Then we'll call the fetch method, passing in the option to **get the row as an associative array**. This will return an individual row, so we'll assign that to a variable and enclose this in a while loop. When there are no more rows, this will return false, and the loop will end. Inside the loop, we'll change the value of the is_completed element by simply casting its value to boolean. Then we'll append the row to the array, and after the loop return that array.
<code php>
<?php
 
class TaskGateway
{
  private PD= $conn;
 
  public function __construct(Database $database)
  {
    $this->conn = $database-getConnection();
  }
 
  public function getAll(): array
  {
    $data = [];
    
    $sql = "SELECT * FROM task ORDER BY name";
    $stmt = $this->conn->query($sql);
    // return $stmt->fetchAll(PDO::FETCH_ASSOC);
   
    while ($row = $stmt->fetch(PDO::FETCH_ASSOC) {
      $row['is_completed'] = (bool) $row['is_completed'];
      $data[] = $row;
    }
    
    return $data;
  }
}
</code>
**File: ./src/TaskGateway.php**

Let's give that a try.
<code bash>
http http://localhost/api/tasks
</code>

Now the values for the is_completed column are shown as boolean literals in the JSON.
===== Show an individual record =====
Next, we can show an individual task record. Let's add a method to the task gateway class called get. We'll pass in the ID of the record we want as an argument, which will be a string. Let's add a variable containing the SQL to select the record, which has a where clause that includes a placeholder for the ID. To avoid SQL injection, instead of the query method we used above, we'll use a prepared statement, so we'll call the prepare method on the database connection property, passing in the SQL. This will return a PDOStatement object, which we can then call the bindValue method on to replace the ID placeholder with the value of the ID argument. This particular table has integer IDs, so we'll specify that it should be inserted into the SQL string as an integer. Then we can execute the statement, then call the fetch method on it, passing in the constant to get the data as an associative array, and assigning its return value to a variable. The [[https://www.php.net/manual/en/pdostatement.fetch.php|PDO fetch method]] will return an array, as we specified, or false on failure. So if it hasn't returned false, we can convert the is_completed element to its boolean equivalent, as we did above in the getAll method. Then we can return the data variable. This variable will contain an array or boolean false, so we can declare the return type of this method to be an array or false. 
<code php>
<?php
 
class TaskGateway
{
  private PD= $conn;
 
  public function __construct(Database $database)
  {
    $this->conn = $database-getConnection();
  }
 
  public function getAll(): array
  {
    $data = [];
 
    $sql = "SELECT * FROM task ORDER BY name";
    $stmt = $this->conn->query($sql);
    // return $stmt->fetchAll(PDO::FETCH_ASSOC);
 
    while ($row = $stmt->fetch(PDO::FETCH_ASSOC) {
      $row['is_completed'] = (bool) $row['is_completed'];
      $data[] = $row;
    }
 
    return $data;
  }
  
  public function get(string $id): array | false
  {
    $sql = "SELECT * FROM task WHERE id = :id";
    $stmt = $this->conn->prepare($sql);
    $stmt->bindValue(":id", $id, PDO::PARAM_INT);
    $data = $stmt->fetch(PDO::FETCH_ASSOC);
    if ($data !== false) {
      $data['is_completed'] = (bool) $data['is_completed'];
    }
    return $data;
  }
}
</code>
**File: ./src/TaskGateway.php**

In the task controller, where we're responding to the request to get an individual task resource, we can call this new method. Let's remove the placeholder message ''echo "show $id";'' and instead call the get method we just added on the gateway property, passing in the ID. As above, we want to output this as JSON, so we'll call the json_encode method on this, and we'll just print this out.
<code php>
<?php
 
class TaskController
{
  public function __construct(private TaskGateway $gateway)
  {
  }
 
  public function processRequest($method, $id) 
  {
     if ($id === null) {
       if ($method == "GET") {
         //echo "index";
         echo json_encode($this->gateway->getAll());
       } elseif ($method == "POST") {
         echo "create";
       } else {
         $this->respondMethodNotAllowed("GET, POST");
       } 
     } else {
        switch ($method)
        case "GET":
          // echo "show $id";
          echo json_encode($this->gateway->get($id));
          break;
        case "Patch":
          echo "update $id";
          break;
        case "DELETE":
          echo "delete $id";
          break; 
        default:
          $this->respondMethodNotAllowed("GET, PATCH, DELETE");              
     }
  }
}
 
private function responseMethodNotAllowed(string $allowed_methods): void
{
  http_response_code(405);
  header(Allow: $allowed_methods");
}
</code>
**File: ./src/TaskController.php**

Let's give that a try.
<code bash>
http http://localhost/api/tasks
</code>
If we make a get request to the endpoint for an individual task using an ID that we know exists in the database, we see the JSON encoded data for that particular record.
===== Respond with 404 if the resource with the specified ID is not found =====
If we request an individual record with an ID that exists, we see the response containing the data with a status code of 200. If we make the same request with an ID that doesn't exist, however, the body of the response just contains false and the status code is still 200. 
<code bash>
http http://localhost/api/tasks/6
</code>
If the resource doesn't exist at this URL, we should get a 404 status code, along with something useful in the body of the response. In the task controller, we're using the get method of the task gateway class to retrieve the record based on the ID. This returns false if there's no record with that ID. Back in the controller, we can check for that return value. However, we don't need an individual task record only at this point, each action inside the switch block does. So instead of checking for the task existing here, we'll do it beforehand.

So let's call the get method on the gateway property, passing in the ID. We'll assign this to a variable

called task, then we can check to see if this is equal to false.

We need to make sure we use the identity comparison operator, as an empty array is the boolean equivalent

of false.

Using this operator, we make sure we're checking that the value is strictly Boolean false. If it is

false,

the task with that ID wasn't found, so we can return the 404.

However, instead of doing that in here, to keep this method cleaner, we'll add a separate method to

return a 404 response.

This will also be consistent with the method we added earlier to return the method not allowed response.

So let's add a new private method called respondNotFound.

In here, we'll set the status code to 404.

In the body of the response, we don't necessarily have to return anything, but it's helpful if we

do.

So let's just echo out some JSON that contains a message saying the task with that ID wasn't found.

We'll pass the ID in as an argument to the method, which will be a string.

While we're here, we'll set the return type declaration to void.

Back in the processRequest method, in the if block for when the task isn't found, we'll call this

new method passing in the ID.

If this does happen, we don't want to continue in this method,

so we'll simply return at this point.

Then where we are outputting the task details, if it is found we can replace this call to the get method

with the task variable.

Let's give that a try.

Now if we request a task that doesn't exist, we get a 404 status code,

and in the body of the response, we get the error message still formatted as JSON.

If we request a task that does exist, this still works. We get the task details in the response body

and the status code of 200.

So now we can request a list of all tasks, or individual ones responding with a 404 status code

if a task with the supplied ID wasn't found.
====== Summary - Building a RESTful API Service in PHP ======
===== RESTfull - (REpresentational State Transfer) =====

REST stands for representational State transfer and everything is a recourse (a single object or entity). The aim of REST is not having pretty and hackable URLs, its about meaning of URLs having a unique ways to refer to the resources.

On the web, we use HTTP's features to implement REST. When we use REST with HTTP, we use the building blocks of HTTP to implement our restful service, we use **Verbs** to say which operation should take place when we request a collection or a resource. We use the **Status Codes** to give accurate information with every response about what actually happened and we use header to send metadata about the transaction that has taken place. **Headers** are not part of the data we transfer, they are the envelope format, sender address and the data is in the body. This avoids mixing data that relates to the resource and the transaction.

| Verb | Collection | Resource | Comment |
| GET | fetch resource | fetch one/all resource | if resource is a collection, all resources will be in the container | 
| POST | create resource| | create a new resource as a collection |
| PUT | | update or create resource | **Not atomic**, provide the complete resource to update, create only if you know the GET URL | 
| PATCH | update a part of a resource | | Specific targeted update like a email |
|DELETE | delete resource | delete a single resource | |

Collections are containers that have resources inside them, like files in a directory (the directory is the container). 

**Common Status Codes**
  * **200** OK
  * **201** Created, accompanied by the location header, telling you where new resource can be found
  * **204** No Content, if you deleted something and won't give it back to UI 
  * **304** Not Modified, cached header
  * **400** Bad Request, anything the server does not understand (bad parameters, unknown endpoint, ...)
  * **404** Not Found

**HTTP Headers for Metadata** sending extra data, unrelated to the resource but important for the request, e.g. user agent or accept header.
  * Accept and Content header to negotiate the kind of content, what kinds of content understood as a client, so server responds with content type is json or plain text.

===== Building a RESTful Service in PHP =====

<code php>
<?php

// Accept header (only simple parsing example) - to respond in correct format
if(false !== strpos($_Server['HTTP_ACCEPT'], "html")) {
  $format = "html";
} else { 
  $format = "json";
}  

// Poorman's storage solution - simulating data backend ;-)
$events = unserialize(file_get_contents("events.txt"));

set_exception_handler(function ($e) use ($format) {
  http_response_code($e->getCode());
  send_output($e->getMessage(), $format);
});

// Verb
$method = $_SERVER['REQUEST_METHOD'] ?? 'unknown';

// Parse parameters here for testability -resource or collection - pars the URL segments
$pieces = explore("/", $_SERVER['PATH_INFO']);

// Route the request
switch($pieces[1]) {
  case "events":
    $func_name = "events_" . $method; //whitelist would be better of publicly - available functions
    if(function_exists($func_name)) {
      $data = $func_name();
    } else {
      throw new Exception("Method not available", 405);
    }
    break;
  default:
    throw new Exception("Unknown URL", 404);
    break;
}
send_output($data, $format); 

/**
 * Very primitive html/json output handler
 */
function send_output($data, $format) {
  if($format == "html") {
    // no header needed, because of PHP default
    print_r($data); // maybe some niche html wrapper would be nice
  } else {
    header("Content-Type: application/json");
    echo json_encode($data);
  }
}

/**
 * Fetch all events
 */
function event_GET() {
  return $GLOBALS['events'] ?? 'no events';
} 

/**
 * Store a new event (accepts an array of incoming params)
 */
function event_POST() {
  global $events;
  if(isset($_POST['name'])) {
    $event = array();
    $event['name']  = filter_var($_POST['name'], FILTER_SANITIZE_STRING);
    $GLOBALS['events'][] = $event;
    
    file_put_contents("events.zxz", serialize($GLOBALS['events']));
    return $event;
  }
}    
</code>
**index.php**

<code php>
<?php
require "index.php";
</code>
**routing.php**

<code bash>
php -S localhost:8888 routing.php
curl http://localhost:8888/events
</code>


===== Consuming a RESTful Service in PHP =====

<code php>
<?php

// create an event
$event_data = array("name" => "fabulous Event II");
$post_opts = array("http" => array(
  "method" => "POST",
  "header" => array("Accept: application/json",
                    "Content-Type: application/x-www-form-urlencoded"),
  "content" => http_build_query($event_data)
));

$url = "http://localhost:8888/events";
$context = stream_context_create($post_opts);
$post_result = file_get_contents($url, false, $context);
var_dump($post_result, $http_response_header);
                     
// get the list
$get_result = file_get_contents($url);
var_dump($get_result);
</code>
**use-rest.php**

<code bash>
php -f use-rest.php
</code>


====== PHP REST Tooling ======

  * [[https://curl.se/|curl]] is used in command lines or scripts to transfer data. [[https://curl.se/|curl]] is also [[|https://curl.se/libcurl/libcurl]] [[https://www.php.net/manual/en/book.curl.php|in PHP]]
  * [[https://httpie.io/|httpie]] is making APIs simple and intuitive for those building the tools of our time.
  * [[https://www.postman.com/|Postman]] ia a Unify API design, testing, documentation, monitoring, and discovery on one platform that integrates with the rest of your stack, including every major gateway and Git solution.
  * And [[https://www.google.com/search?q=postman+alternative&oq=postman+alternative|many Postman Alternatives]]


