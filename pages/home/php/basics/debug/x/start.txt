**[[home:|Start]]** -> **[[home:php:|PHP]]** -> **[[home:php:basics:debug:|Debugging PHP]]** -> **xDebug**

====== Xdebug ======
Xdebug works as a client server communication with [[https://xdebug.org/docs/|Xdebug]]. 
  - IDE starts to listen on a specific Port, which is 9000 or 9003, for communication with XDebug and waits for incoming calls from XDebug. 
  - Xdebug itself starts to call back on Your IDE on a specified port and transfers information about the application runtime. At some point, XDebug communicates with IDE on the specific port which Your IDE started to listen on in the first step.
  - Once the debugging session starts, then XDebug starts to communicate and send information about application runtime to IDE. The IDE and Xdebug transfer data through DBGP protocol which is created specifically for debugging process between Debugging engines like Xdebug and IDE.
Imagine you have a web server that exists in your PHP installation and a web server such as NGINX or Apache if you use one or both of them. This web server may exist in your host, if you want to debug your development host, in a docker, or even in a remote server. The first step to take is to install XDebug extension inside your PHP in your web server. And imagine here you have your IDE and browser. An IDE like Visual Studio Code or PHPstorm And a browser like Firefox or Chrome or any other browser

The first thing that happens is that your IDE starts to listen on port number 9000 or 9003, depending on your own configurations. And for sure You can change the port if you have 9000 or 9003 ports used in another service. Then you connect your IDE or browser with the web server. As we said, xdebug is now installed on the web server with php

So, when you send a request, you send an XDebug session id, this session id allows xdebug to know that this request contains debugging. This means that you want to debug not only to send a request or execute a script After that, the web server starts to call back your IDE on 9000 or 9003 port and sends it an Init Packet. This Init Packet starts the communication via DBGP Protocol.

So, as we said, the first step is that your IDE sends a request to the web server, for example, to send a request on the login route. Then Xdebug sends a Communication start to 9000 or 9003 port which the IDE listens on. After that, the IDE connects back with Xdebug and sends it information about the breakpoints or the things you want to debug.

Afterward, the web server and the IDE start to communicate via DBGP Protocol. And so, debugging process starts. Here in this part Break points start to send information about the debugging process and so on All these details you don't need to know but you just need to know an overview about it. 

After the debugging session finishes, the web server sends all the rest data to the browser to execute the code and view the login page. let's recap what we just said Firstly, the process of listening on port number 9000 or 9003 happens Secondly, you start to call xdebug from the browser by sending a request, such as sending a request on the login page. Thirdly, xdebug starts to call your IDE to initialize the debugging session. Fourthly, the IDE calls xdebug and sends it the breakpoints, for example, to inform it to make a breakpoint in this part or to debug this script and so on. Fifthly, the IDE and Xdebug initialize the protocol to start communicating with each other. And the final step is that the web server starts to execute the rest of the script after the end of the debugging session. And then sends the response to the browser to display the login page or the home page or any other page or any execution of the PHP response. Now we know how Xdebug works and deals with PHP installation. So, we're now ready to use xdebug.

Check [[https://www.youtube.com/@ramyhakam/playlists|Ramy Hakam @ YouTube]]

===== Installation of Xdebug =====
Installation of [[https://xdebug.org/docs/|Xdebug]] depends on your operating system and development environment. The official documentation contains detailed instructions. Choose those that are the most relevant for your setup. If you do need help, please don't hesitate to ask. Once installed, you can check if it's available on the command line by running PHP with the version flag. Choose those that are the most relevant for your setup or run 
<code bash>
apt update
apt -y install php-dev 
apt install php-xdebug
php -v | grep -i xdebug
php -m | grep xdebug
</code>

Alternatively run **PECL** (PHP C Extension Manager) and compiling Xdebug
<code bash>
apt -y install php-dev
pecl install xdebug
</code>
to be platform independent. A **Installation Guide Wizard** is available at **[[https://xdebug.org/wizard]]** for Linux and Unix, add the output of **php -i ** into the wizard webside. This will generate a fitting xdebug.tgz for download and a list of steps what to do for, compiling Xdebug.

Making sure xdebug is already working you will see your version of Xdebug through a terminal running **php -v**. Is there some output with xdebug, then your good to go and to at that time, you downloaded xdebug and the xdebug extension.

Find more in the [[https://xdebug.org/docs/install|xDebug Install Documntation]]

Add the following code to **composer.json**, this will not install [[https://xdebug.org/docs/|Xdebug]] but composer will warn you if it's missing.
<code json>
"require-dev": {
  "ext-xdebug": "*"
}
</code>

Check your php.ini in case of problems
<code bash>
[xdebug]
xdebug.mode=debug
xdebug.client_host=127.0.0.1
</code>

===== Configuring IDE =====
Now we have the PHP version and we have Xdebug installed. Let's now link PHP Storm with Xdebug which we have in our php. First, let's try using Xdebug n a Simple Script. Just one script like an index.php. We do it using the built-in PHP server and we do debug for it. Because of the basic information that you should know about Xdebug. That it has nothing to do with the code structure. That means, for example, you're working with Symfony, working with Zend, working with Laravel, working with any framework, even working with MVC. You create your configuration yourself. Working with any structure. At that time, you should have Xdebug working as it is. There is no difference at all. But the only difference that you might find is. Your code has become large or your trace or your files have become numerous to some extent. But Xdebug has nothing to do with the Code size or Structure. It's the same Configuration. It's the same settings, it's the same everything. Whether you're using any Framework or even Native PHP or even a Simple Script as we're going to see.
<code bash>
mkdir demo && cd demo
composer init
</code>
Looking at the project, I have it completely clean, there's nothing at all. There's nothing but composer.json. Now you can here for example a index.php.
<code php>
<?php
$var1 = "test";
$var2 = 1;

echo "Welcome to PHP and Xdebug";
</code>

==== Configuring and using Xdebug in PHP Storm ====
What's left is connecting Xdebug and PHP storm. In the **PHP Storm preferences**, you can go to PHP. You check your interpreter. There are **...** beside CLI Interpreter, in the upcoming window you'll find Xdebug already configured, within the **General Section** from the php.ini. 

Go inside PHP and go to Debug and check Pre-configuration. PHP Storm supports Two Versions or two types of Debuggers.
  * The first one is Xdebug.
  * The second one is Zend Debugger.
There are also more than two, you're supposed to use them. The most important one is actually Xdebug. Install the [[https://chromewebstore.google.com/detail/xdebug-helper-by-jetbrain/aoelhdemabeimdhedkidlnbkfhnhgnhm?pli=1|Xdebug Helper by JetBrains]] (Chrome) see **[[https://www.jetbrains.com/help/phpstorm/browser-debugging-extensions.html#xdebug-helper-extension|Browser debugging extensions]]** for more Extensions. This is an Extension that you can add inside Chrome and at the same time you'll find the same Extension. Available for any browser. For example, if you use Opera, if you use Safari. Using Firefox. You'll find there an Extension to help you that is Xdebug helper. At this point, you'll be able to do Debug or Disable with in your browser after adding the Extension (green bug). It helps you to deal with the browser actions themselves and with PHP Storm.

Inside the PHPStorm Preferences in the PHP/Debug area you'll see Xdebug works on one of the two ports, either 9000 and 9003. Sometimes Port 9000 conflicts with PHP fpm and that's why you have the 9003 port alternative. So you can use one of the two and this is the default so you don't have to change anything. Don't forget to start the listener inside your PHP Storm.

If the Configuration is okay. You can start running a php server here we're using the Built-in PHP server.
<code bash>
PHP -S localhost:8080
</code>

In the --??-- Menu you'll find the **Break at first line in PHP scripts** You can run it too tell it to break at the first line in the PHP scripts. Alternatively click near the line number to enable a breakpoint.

==== Using Xdebug in PHP Storm ====
setting xdebug.start_with_request to 'trigger' enable Debugging starts when a trigger is present

=== Conditional Break Points ===
You want to start adding a breakpoint, or a breakpoint that works only if the variable has a special condition, like a special value or bigger or smaller then a destinated value. Add a break point by clicking near the line number (PHP Storm) and define a condition. If the condition is something else, this breakpoint won't trigger. If we want to test and create a break point you will removed any other breakpoints for this line.

=== PHPUnit Debug Test Case === 
If you click on the break point icon in your PHPUnit Test eg a assertTrue, you start the test run debug, run with coverage, and also modify the configuration if you want to make a custom configuration for this test case. The first step here is to click on 'Run'. If you run, it will execute this code, and perform the assert. And then, you will find here, one test with one assertion, and the test has been successfully executed.

So, if you want to know why it didn't work, you go here and add breakpoints. And then you tell it to debug. Once you tell it to debug, where will it stop? At the first breakpoint ;-). You're running the code from the PHPUnit. Which is also here, you'll find all your traces here. From PHPUnit to the command, to the runner, the test suite, and certainly to the test case, until you reach the login service test that we're working on. But of course, it brought all your code from when you started running PHPUnit until you reached your test case.

You'll go to the implementation of your code, itself which is inside your code, not in the test. Not in the test itself but in the code. Go to 'Step in', so, you'll enter the code of your project. So, you'll move from the test to the source with the data or the values that I used inside the test case. So you're at the same time in the test and in the code, you can debug and see what the problem is, whether it's in the test or in your code.

==== Using Xdebug in Visual Studio Code ====
In this section, we want to talk about how to deal with Xdebug with Visual Studio Code. Visual Studio Code is one of the most important and popular editors usFed in the world of Web Development, especially in PHP. So we had to talk about how to deal with Xdebug through Visual Studio Code. As for the installation part and how to install Xdebug and PHP, it will be the same, whether you are using PHP Storm, Visual Studio Code, or any other editor or IDE. The only difference will be in the configurations.

The configurations for PHP or Xdebug are already present in the PHP Storm GUI. But here, you need to install the extension. So, you can go to the extensions part, search for **'[[https://marketplace.visualstudio.com/items?itemName=xdebug.php-debug|PHP Debug]]'**, and install the first one, which is the PHP debug extension. Once you've installed it, you'll start dealing with Xdebug, but you'll still need to create a launch, which is a JSON script with the Xdebug configurations. 

Go to the 'run and debug' icon. It will ask you to run and debug the script and create a certain 'launch.json' file, which is the equivalent of the settings we saw in PHP Storm. If you click here to create a launch script, it will show you the ready-made templates for the configurations. In most cases, you won't need to edit them, just like in PHP Storm. But, for example, if you have a different port, you can change the port. If you have any ready scripts, you can use them. But for most cases, you'll find that you almost don't need to modify those configurations. What are these configurations? There are several parts of the configurations here. The first configuration is "listen for xdebug", which means you let Visual Studio Code listen for incoming calls from Xdebug on port 9003. This is the port for XDebug 3, while XDebug 2 uses port 9000. Sometimes you might have a conflict between XDebug and php FPM, as explained in the first or second video. But in XDebug version 3, it works with port 9003. The same goes for "launch currently open script", meaning you want to debug the currently open script and not listen for incoming calls from browsers like Chrome, Firefox, etc. This is how you create configurations for this situation. 

The third one is to launch the built-in web server. So You activate the built-in web server for PHP. If you come here, for example, you have several options. You have the first option, which is listen for xdebug. This essentially listens for incoming calls on this port. The second one is launch currently open script. If you want to debug the currently open script Lastly, there's launch built-in webserver. Starting with the first one... And telling it that I want to launch or listen for xdebug, This means if you scroll all the way down, you'll see it says Listen for Xdebug And Xdebug simple is the project's name. So, it's the same exactly like doing a Listen in PHP Storm.

Go to the terminal, Start my server,
<code bash>
php -S localhost:8080
</code>
Then go here in the browser, And start refreshing. Ta ta. Welcome to the world of PHP and Xdebug. And there are no issues. And added a breakpoint, Just like you did in PHP Storm, Then go back here, And refresh, You'll find that the debug session has started. And it opened all the variables for you, Over here, you have the Suberglobals, Breakpoints, User-defined Constants, And almost everything is similar in the UI but with slight differences. For example, here among my variables, You'll find “$test” and “$test2”. They haven't been initialized yet, so if you come here, You have the same tools that were available in PHP Storm, You can continue to the next breakpoint. Meaning, for instance if you have multiple files and added multiple breakpoints, If you press continue here, You'll resume the program or execution, Then it will stop, At the next closest new breakpoint. And after that, if there are no breakpoints, It will go on and send the response to the browser. Alright. Here is the step-over, Just as we saw, you can step through the script you're currently on, This is a step-in or I mean step-into Which enters into the function for execution, And this is step-out, Which exits the function, And this is the restart, For the current debugging session, Finally, this stops the current debugging session. For instance, here, if you step over, You'll see $test variable now has a value. At the same time, If you step over again, Also, the $test2 variable now has a value. Over here, there's a watcher section, This means you want to watch a particular variable, And this was also available in PHP Storm, We can have a full session, With all the tools in the Debugging GUI, Whether in VScode or in PHP Storm. 

The whole idea here is that you want to add a watch, Watching means you want to know about a specific variable, And the changes that occur to it and how it functions, Whether you're in this file or any other, The variable will remain in the watch and you can monitor the changes. For example, here, I added $test to the Watch, And also, if I come here and add the second one, $test2, Then it will also be added here in the watch. Here, for example, it tells you that you're at the last line in the script, And if you go and press continue, then that's it. The debug session has ended. If you go back to the Chrome browser, you will find the response displayed here, with no issues whatsoever. Even though I've seen exactly what happened during the execution process. At the same time, you have the call stack here. This call stack is exactly the same as in PHP Storm. And here, it shows you the exact call stack, just as we saw it. For instance, if you come back here and start "listen", and if you come back again and set a breakpoint and then come here and refresh, let's see the call stack.

The call stack is essentially an index. We will see what this call stack will contain when we test the Xdebug demo project based on Symfony. Also There's a nice feature in Visual Studio Code, which is the Breakpoints. What will you find here? You can choose not to add any breakpoints at specific points you determine. Of course, you can add them if you wish. At the same time, you can specify certain parts, for instance, "Everything" means it stops at all lines. Or you can tell it to stop only at exceptions as soon as an exception occurs. as if you've set a breakpoint at that exception. This makes the debugging process easier. For instance, if you have a bug and there's an exception in this bug, but you don't know where this exception is, you can make Visual Studio Code stop at exceptions only. This means it will execute and as soon as the first exception occurs, as if you've set a breakpoint at this exception, it stops and shows you the data, the variables, and the entire context you need at the first occurrence of the exception. The same idea applies to errors, warnings, or notices. Everything you can specify, you can either set the breakpoints yourself, as we've seen, or you can specify the code to stop at a particular action or stop at everything, whether it's warnings, errors, exceptions, etc. Of course, you can also add any breakpoints, as we mentioned before. This is a nice trick available in Visual Studio Code. Actually, I don't currently know if it's available in PHP Storm or not, but the main idea is that we said we would explain all the details available in the editor itself.

Here we've seen how to start working with Xdebug from inside Visual Studio Code, and we found it's really easy. All you have to do is launch the script to set the configuration. There are variations between the configurations, whether it's "Listen for Xdebug" or "Launch Current Open Script". okay Let's try "Launch Current Open Script" now. If you come here and stop the current debug, tell it "Stop", alright? And then tell it "Launch Current Open Script", it starts to stop. Now, VS Code doesn't wait for the incoming call sent from the browser. Instead, it starts debugging the current script. The same idea applies if you go here and do "step in", it's the exact same method. And if you also execute here, there's no problem at all, but it doesn't send any response to the Chrome browser because I'm not relying on the call coming from the browser. I'm debugging the script I have here, just as we saw in PHP Storm. almost the same services, almost the same features, but maybe a slight difference in the configuration or even in the configuration process.

If you come here to the debug, it says "run and debug," then "create a launch JSON script." It's the exact method we discussed in the previous video. If you come here, it asks you to select which programming language this is for. Because in the previous video, it was a simple PHP script, and the editor directly identified the language. 
But in this larger project, there are different things, so the editor lets you choose which programming language you want to configure It’s a launch.json file. If you select PHP here, it will add the same configuration file that was in the simple project. It's the exact same, whether it's "listen for Xdebug", "launch current script" or "currently opened script", and the last option is "launch built-in web server". You can choose between them here in this select box. In the same way, if I start "Listen for Xdebug", it starts listening for me. If I come here to my code, which is in the source/ controller, Come here to the AppController, set a breakpoint, and then go to the terminal to start my server.

At the same time, you see the same data here, including local variables, super global like cookies, environment, server, GET, POST, and all these details. If you've defined any constants, they'll be here. And the watchers you've added, you can add any watch from here so you can see and watch based on the changes that have occurred. And the breakpoints we talked about, whether it's everything, exceptions, errors, warnings, or even notices. The call stack, as we saw in the previous video with simple code. But this time, as we saw in PHP Storm, you have the entire call stack, from the start with index.php, which is the entry point of the project, until we reach the AppController we have. Alright, let's start doing step debugging here and interact with the code. If I, for example, did "step over", I see the entire form. If I do another "step over", we enter the form. If I want to do an "Evaluate expression", as we saw, Let’s raise the terminal a bit up here. If we wanted to evaluate an expression, from this form, then right-click, and choose "Evaluate in debug console."

You can say here "evaluate in debug console". It will tell you the result which will be `false`. Why is that? Because, as we know before, The call is currently a `GET`. So, this `GET` means that "Form submitted" will be `false`. And at the same time "form validate" will also be `false`. But if we come here and say "Execute for me", So that it sends the response To the browser. And if you go again to the browser, you'll find it rendered for you. Suppose I came here and wrote "test". Then also "test" here and then log in, it will take me to my code, but this time it's a `Post request`. I can now do a step-over, And another step over, Now this time, if I select "form is submitted" and I do "evaluate in debug console", What will the result be? It will be `true`. Last time it was `false` because it was a `Get Request`. But this time, it became `true` because it's a `Post Request`. And at the same time, the "Form is valid". Let's try the other one also, Evaluate in debug console. And indeed, here it is also `true`. This means that I can go inside the `If body`, And fetch the data. And the data immediately appeared here.

=== Conditional Break Points in Visual Code ===
As we saw in PHP Storm, you can add a breakpoint with a specific condition. Now, how do we add it here? Let's say, for instance, we add a breakpoint here. Stop the debug session this time. And come to say, I want to add a breakpoint here. But this time I'll click "edit breakpoint". Exactly in the same way, I tell it that if  the username equals test, stop at this condition. If it doesn't equal test, continue without stopping. 
Alright, you do listen again, Go here to AppController and remove this breakpoint, And proceed to Chrome. I did refresh. You can also perform step-in and step-over and all of that. You can do everything you want in this debugging. Is an IDE specifically for PHP. Whereas VSCode is a general editor. You can use it for any Supported programming languages. That's why you need to do some extra configurations, Such as adding them to the Lunch.json file.

=== Debug PHPUnit Test Cases in Visual Code ===
You only had a simple icon where you could right-click and choose to run or debug. This time, let's see how to debug PHP unit test cases Inside Visual Studio Code, you need to add some configurations in the `launch.json` file. How is this done? If you come here in Visual Studio Code, If you want to run these tests, Let's open a new terminal here. And if we tell it.
<code bash>
/vender/bin/phpunit
</code>
it starts executing the test case. And you'll find here 1 test and one assertion, which is the only test we have so far. Also, you can use the same method in the "LeadCode Repository" 
That we used for "CodeCoverage". This time, we want to simplify the process a bit. To use "Run" for a specific test case, "Run" for a specific Class, There is a handy extension in Visual Studio Code. You can search for it. it's called [[https://marketplace.visualstudio.com/items?itemName=emallin.phpunit|PHPUnit]]. What is [[home:php:test:unit:|PHPUnit]]? It's an extension that helps you start debugging in the same way That exists in PHP Storm. For example, if I come here to this class, I want to test the class. I go to the class itself, and on my Mac, I can press Shift+Command+P, Or on Windows, press Ctrl+Shift+P, And here I can say 
<code bash>
phpunit test
</code> 
It will execute the tests found in this file. As you saw here... if we scroll up a bit, If I come here again, And press Command+Shift+P, And I told it PHPUnit, it executed for me. If I come here, for example, and want to execute this function only, It's the same. I go to the function itself, Press Control+Command+P on Mac, Or Control+Shift+P on Windows, Press PHPUnit. You'll find that it is executed only for that function. This is for the RUN process. Okay, how do you do the Debug? The idea of Debug is that you need to add some configs in Xdebug, Found in the `lunch.json` file. I come here to the `lunch.json` file, And add new configs as we mentioned we have one for listening for Xdebug, One for the current script, one for the built-in web server, And add another for PHP Unit. I added the configurations. Here the Name is "Launch Unit Tests", So I can select it from the Dropdown List, And here is its Type and Launch, The program will run PHP Unit,

The Execute of PHP Unit. And it told you that the environment here, Which is the Xdebug config, So it triggers Xdebug, And sends you the IdeKey for Visual Studio Code. Of course, these settings, as we saw in PHP Storm, You don't need to add them because they are built in. All you have to do is right-click and debug, But here you need to add some additional settings in VScode. So I added these configurations. I can press Command+S here, So I can save. 
Then I can go to `LoginServiceTest`. And then I will go to the debug part, Choose from the menu here to do the lunch unit test, And here I added a BreakPoint in the result, And tell it to run. As soon as I started running, it started debugging, And at the same time, it showed me all the data, For example, the result is uninitialized, And also `$this` I am in, `LoginServiceTest`. When I open it, you'll find all the data related to this class, And at the same time, if I come here and do a step-over, You'll find the result changed and became true, And I continued, and asserted true, that's it, the test case is done. 

We saw how you can debug your test case. It's the same method, with the same capabilities, but with a difference. Whether you will add some configurations in Visual Studio Code, Or modify some existing configurations. Alright, we finished the quick video about PHP unit, How you can test and how you can debug in Visual Studio Code. Let's see how you can debug, If Xdebug is inside Docker, Just as we did in PHP Storm.

=== Using Xdebug Inside Docker with Visual Studio Code ===
===== XDebug Modes =====

==== Develop Mode ====
Develop Mode is like an enhanced level of VAR DUMP and DIE. That means you're already using Var_dump, but it displays it a little better. To change the mode, you can change it through environment variables, or you can go to the php.ini. In the PHP ini, you have the Xdebug mode. The default is “develop”, but here we updated the mode to the debug mode.
<code bash>
[xdebug]
xdebug.mode=debug
xdebug.client_host=127.0.0.1
</code>
For example, here in the PHP ini, you have the Xdebug mode. The default is “develop”, but here we updated the mode to the debug mode. Which is the main one that you consider using all the time Because for example, you want to do step debugging. 

Like we've seen that, like step in and step over, and you move step by step in your code. This is by using the debug mode But now if you want the enhancement level of var dump and die, you can, for example, change here the mode from debug to develop. First thing, let's see the change. For example, here in our code here, let's come when we were doing var_dump, I come here, for example, and tell it to do var_dump for the request.

And I come here on the terminal, and I tell it Symfony serve, and Symfony serve here, I'm supposed to go to my code. 
If I refresh, you'll find it here, it brought you the var_dump we talked about before. You will find here that it displayed the var dump in the default form without any improvements. You can use dump and die or dd, which is available in Symfony. For example, here if we did instead of var dump, you can use DD to use the var_dump that exists in Symfony and come here if you refresh again. Then we'll move on to profile mode, which helps you see what the performance issues are in PHP.

You will find here that it displayed the var dump in the default form without any improvements. You can use dump and die or dd, which is available in Symfony. For example, here if we did instead of var dump, you can use DD to use the var_dump that exists in Symfony and come here if you refresh again. Yes, as you see this is a little enhancement level for the view. The topic looks like you're doing a var_dump, but using the DD that's inside Symfony. Now, with Xdebug, what's the difference? How can develop mode help you? If we went here in the ini, and we came back here, var_dump. We came here in the ini, we switched debug, and we changed it to develop. When I came here, of course, I have to restart PHP.
<code bash>
[xdebug]
xdebug.mode=develop
xdebug.client_host=127.0.0.1
</code>
Then I come here and tell it Symfony serve, because I edited the ini file, I have to restart, and I did a second load, you'll find that it's similar to var dump, but a little better. So I don't want to use it because it looks like you'll use var_dump, die, echo. Let's, for example, use dd to see what it will display to us. For example, here if I changed var dump to dd, will it display what's inside Symfony or what's inside xdebug? It showed me what's inside Symfony, it overrides the version of the existing var_dump. Now I've mentioned the first mode, which is develop.

Develop is when you do debug and use var dump and die, and sometimes you might have a special case where you need to use var dump and die. Or for some reason, the debugger isn't working for you. So you want to do a dump. And if for some reason you can't use dd from Symfony, or you’re using, for example, any other framework that doesn't have these functions. And that displays the var dump in a simpler way. Then you can use the develop mode that exists inside Xdebug. We've now understood the first mode, which is develop, and as we said, you won't use it in most cases. You can at the same time in the xdebug mode. You can use more than one mode. You can use both **develop,debug** and then, you can use both. **You can use more than one mode.** It doesn't have to be just one mode. 
<code bash>
[xdebug]
xdebug.mode=develop,debug
xdebug.start_with_request=yes
xdebug.client_host=127.0.0.1
</code>
You can use develop, and at the same time, you can Enable the debug mode also. And at the same time, you can display what the modes or features are inside Xdebug using xdebug info.
<code php>
<?php
//php_info();
xdebug_info();
</code>
Let's go here to the terminal and stop the server, then restart it again. And I come here in the code, and here in the index.php, we go here in the public, index.php, we can remove all of this, just comments, and tell it here, for example, xdebug, Xdebug info. Xdebug info will display your data, if you went here, for example, started the server 
again, and came here in my code, and refresh, perfect, it will display for you the Xdebug version and the rest of the services you have. You have here a development helper. "This is the develop mode. At the same time, you have here the coverage mode which is currently unavailable because we haven't enabled it yet. Here, we have the Gc Stats feature related to the PHP's garbage collector mechanism. I don't think you will need it, at least not often. 
This is the step_debugger that we talked about in previous videos and we've seen how you can debug using xdebug and PHPStorm. Here is the tracing. If you want to track all function calls and everything related to the execution or connection in your script, you can perform tracing, but generally, you won't be using it much. We could also make a dedicated video about it, discussing and learning about tracing, and how to use it. Here you can see the XDebug-related information, for example, the XDebug variables. Like here in the mode, we are in develop mode and debug.
Here we have the master value are develop and debug. And Xdebug starts with request Here the value is the default one. The default is by triggering, meaning as soon as the Xdebug trigger happens, the xdebug session starts. But you can change it to yes or 1. What does this mean? This means that if you, for instance, take this copy, and went here to the ini, told it, "Boss, add these settings but equal 1". What does this mean? Or yes, this means you want the xdebug to start with any request before executing any PHP code. Here you can see the current XDebug configurations using this nice function called xdebug_info, which is like php_info but for xdebug. Let's revert back to our code without using Xdebug info. Alright, we finished this simple video, and we talked about the first mode which is the development helper and as we said, it's an enhancement level of var dump. 

==== Profile Mode ====
When do you need to use the Profile Mode? You need it when you have performance problems. Like, for example, when your code is slow, and you want to know which part, which function, or which class in the code takes the longest time. For example, now it has integration with third parties, or there's heavy code. Like, you're doing a lot of logic, you're doing for loops inside another for loop, and you don't know why it takes a long time. Then you need to identify the areas in your code that have a performance issue or take longer. You can determine them and at the same time optimize them. 
<code bash>
[xdebug]
xdebug.mode=profile
xdebug.start_with_request=yes
xdebug.client_host=127.0.0.1
</code>
Here is the current mode profile. What does this mean that the current mode is profile? This means that **a file will be produced by XDebug** itself, and you can visualize this file either on PHP Storm or another program we will talk. The file named **/tmp/cache_grunt.out.37769.gz**, it is located in the temp by default, as long as you didn't specify the path for this file. name of the file itself because, as you see, the name here is not understandable.
It's the **process ID**, and this is what we will see now. The first one is **Profile append = 1**, meaning we want to **append data to the existing file**. Then there is **xdebug_profiler_output_name** the name will be **cash_grant.out**, here **%t and %r**, what are these? If we go to this in the documentation, here you will find that "%t" what does it mean? It refers to the **timestamp**. I want the file that comes out to have the current timestamp of this process. And then we'll find here also **"%R"**. What does "%R" mean? It **refers to the server request URI**, meaning I can have each file specific to a particular request. Here the file will appear to me, and the name of this file will be the timestamp followed by for example, the route to the Home.  Then there will also be the timestamp for the request, and at the same time, it will be followed by Home, so I will have many files, each file specific to a certain route, to make it easier for you. The one that's currently there or the default, which is **"p%**", is the PID, the **process ID** specific to PHP. Find more about this in the [[https://xdebug.org/docs/all_settings#profiler_output_name|Xdebug - all settings Documentation]] 

Modify the php.ini file in the XDebug settings so that we save the output file in a specific path and, at the same time, change the name of the file itself because, as you see, the name here is not understandable.
<code bash>
[xdebug]
xdebug.mode=profile
xdebug.profiler_append=1
xdebug.profiler_output_name=cachgrid.out.%t-%R
xdebug.output_dir=/tmp
xdebug.start_with_request=yes
xdebug.client_host=127.0.0.1
</code>
Alright, how to visualize this file? If we go back here to PHPStorm, and here, for example, **in tools**, you'll find a tool named **"Analyze Xdebug Profiler Snapshot"**. The snapshot is the file that appeared to you.

You'll find here execution statistics, from the first step to the last step. You'll find even the steps related to Symfony and your code. Okay, your entire trace is here. And at the same time, here you'll find the callees and callers, which refers to who is calling and who is being called. In all the files from the beginning, the index, you can enter here and delve in and see everything sequentially. And at the same time, you'll find here the time, all the time here. 

And here, you will find that from the beginning of the index, the index consumed all 100%, consumed 10 seconds or more, meaning almost 10 seconds and 23. You will find here the own time. Okay, what's the difference between the time and own time? The time refers to the total time taken by a function, including both the execution time of the code within the function itself and the time taken by any functions that it calls. As for the own time, this is the time taken by the code within the function itself, excluding the time taken by any functions that it calls. For example, the index here, you will find that it took only 4 ms in the own time. But in the time itself, it took all the time, which is more than 10 seconds. But as you go down, all of it increases the own time until you get to sleep. Here we will find that it consumed 97.7% of the time, own time, because it didn't call any other function. By comparing these numbers, you can identify which function has a problem in time and the same approach in memory. 

There is a program called [[https://kcachegrind.github.io/html/Home.html|KeyCache Grunt]] (KDE Linux), which features a much better UI and helps you analyse better than PHP Storm. There is a [[https://sourceforge.net/projects/qcachegrindwin/|QCacheGrind (KCacheGrind) Windows build]] and a [[https://formulae.brew.sh/formula/qcachegrind|Homebrew Version for Mac]] Version.

=== Visualise Profile Output ===
This time, we want to explore a slightly more advanced GUI. You can use it to make the same modifications in the visualization but in a more advanced way. If we go, for example, to the [[http://xdebug.org/docs/profiler|XDebug documentation]], you'll find what you can use for analyzing the profiler. There's a program named [[https://kcachegrind.sourceforge.net/html/Home.html|KCacheGrind]]. It's a visualization tool that helps you visualize the data that comes out of the profile. [[https://kcachegrind.sourceforge.net/html/Home.html|KCacheGrind]] is available and you can install it on Linux. There's an alternative named QCacheGrind available for [[https://sourceforge.net/projects/qcachegrindwin/|Windows]] and for [[https://formulae.brew.sh/formula/qcachegrind|Mac]].

You'll find here in the columns, the first thing is "inclusive time" which represents the time taken by this file named index.php, a function named "main". The time it took in total with the calls it made. So here, inclusive time is the total time taken, and at the same time, the self time is the time taken by the code inside the index.php, regardless of the calls it makes. 

Imagine you have a file named index.php that calls another file named home.php. The inclusive time for index.php is, for example, 6 seconds. Out of those 6 seconds, 2 seconds are for the code of index.php, and 4 seconds are for the code after index.php made a call to home.php. The self-time for home.php will be added to the inclusive time for index.php, so the total or sum of them is the inclusive time. So, we can differentiate between inclusive time, which represents the time for the code in the file itself, in addition to any calls to other files, and self-time, which means the time for the code in the file itself without any external calls.

Then you find here the number of calls, which is how many times this function was called. For example, you have a function named "event dispatcher - dispatch", the number of calls for this function.

Here you can see the source code when you select it, and at the same time, the most important or beautiful visualization in QGround is the "Call Graph". Call Graph presents all the output but as a graph. For example, if we go to the main and scroll all the way down and see... scroll all the way down, yes, and if we came here and said alright... and scrolled up. You'll see your entire call graph, you'll find all your call stack in detail from the moment you went to the main, from the first index.php until the last thing, terminate and response, and the response returned, and a terminate was made from the http kernel, and at the same time, it displays the inclusive time. For instance, here you have the `index.php`, which makes a call to `autoload.php`. This, in turn, references the files in the `vendor` directory using `composer`. Then, it starts the cycle of Symfony's kernel, the `HTTP kernel runner`. 
This runner has two calls: one goes to `terminate` and the other to `handle`. If you notice a thicker arrow, it signifies that this particular branch takes longer. For example, `terminate` concludes first, only after sending the response. Meanwhile, `handle` has a thicker arrow, implying it takes a more significant amount of time. 

If I **navigate to "Call" or "Cally Map"**, it provides a comprehensive overview. All the calls, like the documenter from the Symfony component, can be visualized. The main point here is that tools like QCacheGrind or KCacheGrind are very useful and can be employed for visualization.

However, is it the only tool? You can also utilize [[https://www.blackfire.io/|Blackfire]]. What is Blackfire? Before diving back into visualization, let's discuss Blackfire. Blackfire allows you to monitor, profile, and test your application before deploying it into production. It aids in identifying performance issues, time constraints, and potential problems in your code. Blackfire supports PHP, Python, and Go, and soon it will extend support to Ruby and JavaScript. While you can use Blackfire with Symfony, it's also compatible with Laravel. However, **Blackfire is a paid service**. You'll need to check their pricing to determine which package suits your needs.

On the other hand, you can use QCacheGrind for free to visualize the output from Xdebug's profile mode. Returning to QCacheGrind, you'll notice all the calls made in your file. Each function's time consumption and related calls are displayed. For instance, the event dispatcher calls two files.

By following this, we eventually reach the last file, `factory create for namespace`. I'm not familiar with its function. There's also the `php Documenter reflection`, which pertains to Symfony and vendor, but it's not our primary concern. The main takeaway is observing the time consumption.

Ifyou run into memory issue, Select memory. If we come here and look at the login service, Come and see the function named "login". Did you see how much it consumed. You'll find the memory is about 70%. All the other files barely consumed any memory, The login service alone took up 70% of the memory. Let's scroll down a bit and look at the graph visualization. If we tell it the login service, Here you have the kernel taking up 75%. If we scroll down, Compared to before, there's almost nothing. Only the login service took up 74.93% of the memory. From this, you can pinpoint exactly where the problem lies. If you check the memory per byte and choose the time, You'll find that the login service consumed 55% of the time. If you go up, you'll see that almost all the code It took negligible time, Only 28%, Compared to the login which took up 55% of the time. And of course, this will increase the consumed time in the inclusive time for everything before it, As we explained before. The idea is that we can visualize the memory, and at the same time, visualize the time. Okay, if we come here after checking the for loop and its impact on memory, We can remove it and replace it with sleep.

==== Code Coverage Mode ====
Code Coverage is a very important mode in Xdebug, if you work with PHPUnit, the code coverage mode and the code coverage mode allows you to determine the number of lines from every script you execute for each request. This is useful for many reasons the main one is, that you can perform code coverage on the actual code or determine code coverage based on tests. It means that Xdebug works with PHPUnit and uses a library called php code coverage. Together, these allow you to determine the number of lines for each script that has been tested. Meaning, it's covered by a test case. This is very beneficial for determining which parts of your code or which files in your code have been tested and which parts or files don't. This helps you say, for instance, that your project's code coverage is 90%, 50%, 20%, or 0% if you haven't conducted any tests. You can then enhance the quality of your application and at the same time, generate reports. These reports provide essential details for you, like for every file, What is its code coverage percentage? What is its test percentage? At the same time, which lines have tests and which ones don’t.

Check [[https://github.com/RamyHakam/leetcode-php|Ramy Hakam - leetcode]] @GitHub it contains many solutions to lead code problems in PHP. And you can visualize this code coverage either by using PHP Storm itself or by using a command to generate a report. For example, an HTML report. First, let's use the code coverage from within PHP Storm. The first thing you need to do is modify your mode in xdebug to coverage mode. Open PHP.ini file 
<code php>
[xdebug]
xdebug.mode=coverage
xdebug.output_dir=/tmp
xdebug.client_host=127.0.0.1
</code>
I can now run the tests with multiple options. You can run all the tests or run a specific test, or start debugging at a particular breakpoint, or you can choose to Run PHPUnit with code coverage. This means you want to generate your code coverage. And this means you'll run all the tests and see the percentage of your code that has been tested and covered by test cases. For example, if we run tests with code coverage, It will run all test cases.

But the advantage here is that you can know the percentage or what code has been tested, whether files or lines. This is the code coverage report from within PHP Storm. Now we want to generate the code coverage report from PHPUnit itself via the command. To generate these files using HTML. 
<code bash>
./vendor/bin/phpunit --coverage-html /tmp/coverage
</code>
Now you open /tmp/coverage/index.html in your browser.

And we created a beautiful Report with it, like the one we've done here. Also using phpunit. And in this Report, as we explained, it shows you the Code Coverage or percentage of Coverage available for the "Lines" or "Function" and the "Methods" or even "Classes and traits." At the same time, there's something here called **the Dashboard**, which gives you an overall summary concerning the classes and at the same time methods. This is basically a summary of your code coverage. For instance, concerning the classes, it shows you the code coverage distribution, like what percentage doesn't have any tests at all for the classes and what percentage of them are at 100%.

Simultaneously, it indicates the complexity of the test cases you've created, and it tells you about insufficient coverage so that if you want to get a quick summary of the classes that need to increase their test percentage. From the perspective of Xdebug and PHPUnit, it also points out the project risks that you need to address these risks present in these classes. These statistics are available for the classes, as we've seen, and they're also available for the methods. It tells you the coverage distribution for the methods based on which methods don't have any coverage and, for example, which methods have 100% coverage. Of course, there should be, for instance, 20 from 20-30% of the methods: how much coverage was done for them Similarly, it indicates the complexity of your test cases and the insufficient coverage. It helps you identify the list of methods that should be given more coverage and add 
new test cases. Alright, at the same time, it tells you about the project risks that need to be addressed and increases the security level of your project concerning the methods. So this is the overall overview of the code coverage report, whether it's on the dashboard or the page we discussed, showing the percentage of code coverage, whether it's in line or functions, or the overall Project code coverage.

==== Trace Mode ====
Alright, let's move on to the last mode we'll explain in Xdebug: Trace Mode. What is this mode? This is a mode you use when you want to trace the flow of what happens in any Request while working on your project. For instance, you might want to take a snapshot of how many times a function has been called, what assignments it has, the arguments that were added, the return types it provided, the number of calls for each function, and the flow in this request. 
You can think of it as profile mode but in much more detail. It provides all the details about all the methods or all the scripts executed in your request, whether it's in the request or the overall project. 

How is this useful? It's beneficial, for example, if you're new to a project. Let's say you just joined a new company, and you have a project, and you want to know where the critical parts of this project are. For instance, you want to know which functions are most frequently called in the project and which functions consume the most memory. "What are the return types or, for example, the snapshot of the arguments sent in these functions? What are the return types they produce and all these details? At the same time, it will be helpful if you have performance issues. You can use the trace mode and at the same time the profile mode to actually detect and identify the problem areas, whether in memory or time.

<code php>
[xdebug]
xdebug.mode=trace
xdebug.collect_assignments=1
xdebug.collect_return=1
xdebug.output_dir=/tmp
xdebug.trace_format=1
xdebug.trace_options=0
xdebug.trace_outpunt_name=trace.%R
xdebug.client_host=127.0.0.1
</code>
And at the same time, we set 'Collect Assignments = 1'. Meanwhile, the return type tells you what the assignments are for each function and the return types from each function. Here I tell it that your output is on profile/trace, and we'll create its folder now. At the same time, I mention trace_format and trace_options. For the output, I say 'trace' and here 'r'. 'R' as we saw is like a profiler. We said this would be in the route or URI for each request, so I can know, for example, that this file is the trace for a specific route, like login or home. And here I tell it to start XDebug with a request, so we don't need to trigger XDebug. With every request, XDebug starts a session with the XDebug server. And of course, all these configurations are detailed on [[https://xdebug.org/docs/trace|Xdebug.org]]. You can understand all their details. This is the configuration for the trace; you can, of course, modify it as you like.

Run your Application and Xdebug will create a gz trace file. If I opened it, you would find an XT file inside. Look, guys, you would find symbols that you might not entirely understand. This means that this code contains all the details of the request you made, whether it's in your code or in Symfony itself. For example, it loads some libraries related to the database, loads classes, loads controllers, runs the kernel helper, and these details. You can know all these things. So, you can only really benefit a little from this file. The XDebug gives you a simple service or script, allowing you to do minimum analysis of this file. This way, you can view it in a slightly better way. Where is that? If we come here to Chrome and go to XDebug itself, you'll find a file called '[[https://github.com/xdebug/xdebug/blob/master/contrib/tracefile-analyser.php|Trace File Analyzer]]'."

This is a class that you give this file to, and it processes it and then displays it in a better way. So you can benefit from the data inside the big file we saw. Therefore, let's use it. If you displayed it as a row and then did Ctrl+A Ctrl+Copy, came here to this folder and created a new file. Or, let's open the new file trace.php. Then paste this code like this. You begin by running this file through PHP, and you give it the name of the file you want to read. At the same time, you can give it some arguments. First, let's display the file without any arguments. So, tell it here: PHP, okay, trace.php, and come here, give it the name.
<code bash>
php trace.php trace._trace_login.xt
</code>
It's telling you the top 25 calls sorted by 'time OWN.' What's 'time own'? As we explained in the profile video, we talked about the difference between inclusive_time, memory, own_time, and memory. Of course, you can watch the profile mode video if you don't know the difference between them.

You have **3 arguments** you can add. If we did clear here and did nano trace.php to see the script itself, you'd find that it tells you that the arguments you can add are three arguments. 
  * The first argument, which is the '**file name**' we added. 
  * The second argument, as I said, is the '**sort key**'. You can modify it to '**calls**', '**inclusive time**', '**inclusive memory**', '**own time**', or '**own memory**'. 
  * The third argument is the **elements count**. So if you want to display, for example, 25 or 100, and so on.

And at the same time, using the profiler, you can also identify problem areas, whether in the UI, using PHPStorm, or using Kcachegrind or QcacheGrind. If you're new to the project, you benefit from knowing which functions are most used in your request flow, or for the project as a whole. The last mode in Xdebug is the 'GC State', which you probably don't need much. It's about the [[https://xdebug.org/docs/garbage_collection|Garbage Collector]] statistics. It's a built-in mode in PHP that gives you a little profiler so you can know the uses of the [[https://xdebug.org/docs/garbage_collection|Garbage Collector]] currently in your PHP, when it gets triggered, how many variables it should clean, how long it takes to clean, and how much memory is released. You only benefit from this if you have a performance issue in a particular case and suspect it might be related to PHP memory. For example, if you assign many variables, you want to know if those assigns are released by PHP itself. to know the mechanism PHP uses in your project or how the garbage collector works. So, we've previewed all the modes except the garbage collector because, as I said, you don't need it much, but we still had to mention it briefly.

===== Xdebug with Docker =====
We installed Xdebug at the beginning on a local machine. This time we want to talk about how you can use Xdebug inside Docker and have the PHPStorm or Vs later on your host machine interact with it from inside Docker. You might need this if your development environment is entirely within Docker and not on your host machine. After we've covered the modes available in Xdebug and explored how you can use them and how you can analyze the data extracted from them the next thing we need to discuss is how to use Xdebug from inside a Docker Container. This means that not always your development environment will be on your local host it might be inside a Docker Container.

databases, or web servers like Nginx, Apache, or even PHP itself. All of these are available inside the docker containers, which you can download and run on Docker, then begin your development process. At the same time, you might be using PHP Storm, VS code, or other editors locally on your computer. So how can you use Xdebug when it's inside a Docker container within your Docker environment? How will you make it interact with your IDE or editor, whether it's PHP Storm or VS code?

Here is a [[https://github.com/RamyHakam/docker-tutorials|special Docker repository]]. If you're unfamiliar with Docker or want to understand more, I have a very quick [[https://www.youtube.com/watch?v=dTZZ-4PibHg&list=PLdYYj2XLw5Bmx7lN1flO4eXGGyieUkfBa|crash course available on my YouTube channel]]. About it, you'll find all the Docker-related details and fundamentals. The repository we'll use to demonstrate how to use Xdebug from inside Docker is the same one I used in this course.

open a new terminal there, then navigate to "docker-tutorials" and run the command 
<code bash>
docker compose build
</code>
It should start building all the containers, and once that's done, it should work you'll find this repository named "Docker Tutorials" on my GitHub account, and you can use it however you like. Now run the command 
<code bash>
Docker compose up
</code>
to start the Docker environment. If you check the code, you'll find that I have a Nginx server and PHP. And if you check the **docker-compose file**, there are two services. The first service is the php-server, where we will integrate Xdebug, and the second service is the nginx service, which is my web server.

If you open a new terminal and run the command 
<code bash>
docker ps
</code>
you'll see two containers. The first one is for nginx, which is the web server as we mentioned, and the second one is for PHP. The nginx container runs on port 8080 and communicates with the PHP container on port 9000. Now, if we go to the browser, we can open localhost on port 8080.

I can also do it inside the docker at once. Also, I can install Xdebug through PECL and then use it from inside the docker file so my container does the Xdebug install. For me okay There's just a small but crucial thing left, which is how to configure Xdebug after installation and enable Xdebug at the same time. There's a quick command you can use that does 'xdebug enable'. But we want the host to be the one you work on, which is the local host. Okay, how is this done? Let's quickly create a config file named xdebug.ini and add the settings. This configuration is the one we used in almost all the previous videos. What does it represent? First, I tell it to enable Xdebug. In the second line, I set the mode to develop and debug. At the same time, you can use any mode we use, like profile, trace, coverage, etc. then you tell it to start the Xdebug session with every request and say 'yes' But here, the new settings are 'discover client host = 0'. This means I don't want Xdebug to search for the client host by itself, but I'll determine the Xdebug client host, which is 'host.docker.internal'. This is a special DNS name that refers to the host inside your machine. We must distinguish between the development machine host itself and the docker host. 
The idea here is you're telling Xdebug from inside Docker that your client is on 'Host docker internal'. Then Docker itself will understand that then connect between Xdebug and your host, which is the Local host. And at the same time, there's a small trick for Linux users. You have to specify 'Host docker internal' and map it to the 'Host Gateway'. See it here If we go to the docker-compose file. Now, let's say, for example, in PHP, I defined something called Extra Hosts. And all we want here, is that .. we can copy this XDebug. Then I tell it here that the Docker Host Internal Copy it here just like this. The Docker Host Internal refers to the Host Gateway. Alright, the whole idea here is that I'm saying this config is specifically for Linux because it's a special case in Linux and at the same time, this option is available in docker version 20.10. Okay, the main thing I'm saying is, the mapping of the docker host internal is there on the host gateway, so the docker will understand that it and also maps to localhost. Okay, so if it doesn't work for you on Linux, you can add this option. Alright, now let's go and check the configurations. okay These configurations are already with us, we just need to copy these settings inside the docker container itself. So how we can do that? I come here to the docker file, and after I install Xdebug, I can tell it to COPY. PHP Xdebug.ini and I specify where to send it. Have it sent to the PHP Ini directory and add it to the config.d so it adds it to the settings files that are inside the container itself. And add it to the extension related to Xdebug. So this Xdebug file is added inside the PHP .ini file of the PHP version that's inside the container.
<code bash>
zend_extension=xdebug.so
xdebug.mode=develop,debug
xdebug.start_with_request=yes
xdebug.discover_client_host=0
xdebug.client_host=host.docker.internal
</code>
**xdebug.ini**

